[{"content":"","date":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"本博客记录数学、计算机等方面的笔记, 以及一些随笔.\n","date":null,"permalink":"/","section":"一边吐血一边奔跑着的马拉松","summary":"本博客记录数学、计算机等方面的笔记, 以及一些随笔.","title":"一边吐血一边奔跑着的马拉松"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E5%AD%A6/","section":"Tags","summary":"","title":"数学"},{"content":"趣题: 符合要求的最小的 n # 题目 # 从 $1, 2, \u0026hellip;, n$ 中任意删去 $2023$ 个不同的数, 从剩下的数中仍然能找到 $2023$ 个数, 满足它们的和为 $n$ . 求满足该性质最小的 $n$ .\nSolution 1 # 首先 $n \\geq 2023 + 2023 = 4046$ . 如果删除 $1, 2, \u0026hellip;, 2023$ , 那么有 $n\\geq 2024 + 2025 + \u0026hellip; + 4046 = 6139805$ . 下面证明 $n = 6139805$ 满足要求. 把$1, 2, \u0026hellip;, 6069$ 分成如下这些组: ${1, 6069}, {2, 6068}, \u0026hellip;, {3034, 3036}, {3035}$ .\n如果没有删去 $3035$ , 那么其它 $3034$ 组中至少还剩余 $3034 - 2023 = 1011$ 个完整的组. 取这 $1011$ 组加上 $3035$ , 共 $2023$ 个数, 和恰为 $6139805$ . 如果删去了 $3035$ , 设其它 $3034$ 组中剩余 $M\\geq 3034 - 2022 = 1012$ 个完整的组, 记这 $M$ 组中前 $M - 1010$ 个大数为 $x_1 \u0026gt; x_2 \u0026gt; \u0026hellip; \u0026gt; x_{M - 1010}$ . 由于共删除了 $2023$ 个数, 且在 $1, 2, \u0026hellip;, 6069$ 中至少删除了 $3035 - M$ 个数, 故在 $6070, 6071, \u0026hellip;, 6139805$ 中至多删除了 $M - 1012$ 个数. 考虑数列 ${x_i + x_1 - 3035}, i = 2, \u0026hellip;, M - 1010$ , 至少已有一个没有被删掉, 不妨设为 $x_2 + x_1 - 3035$ . 取 $x_1, x_2$ 所在组中的较小数, 再从 $M - 2\\geq 1010$ 中取出 $1010$ 组, 共 $2023$ 个数, 和恰为 $6139805$ . 综上所述, $n$ 最小为 $6139805$ .\n","date":"10 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%9811_%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9A%84n/","section":"Posts","summary":"趣题: 符合要求的最小的 n # 题目 # 从 $1, 2, \u0026hellip;, n$ 中任意删去 $2023$ 个不同的数, 从剩下的数中仍然能找到 $2023$ 个数, 满足它们的和为 $n$ .","title":"趣题: 符合要求的最小的 n"},{"content":"","date":null,"permalink":"/tags/%E6%A6%82%E7%8E%87/","section":"Tags","summary":"","title":"概率"},{"content":"趣题: 点在同一个半圆的概率 # 题目 # 随机在圆上生成 $n$ 个点, 这 $n$ 个点在同一个半圆的概率是多少?\nSolution 1 # 对于任意一个点, 考虑剩余 $n - 1$ 个点是否在从它出发顺时针的半圆上, 这个概率是 $\\frac{1}{2^{n - 1}}$ , 而每个点确定的圆弧都可能成为符合要求的那个半圆, 并且相互之间独立, 故答案为 $\\frac{n}{2^{n - 1}}$ .\nFollow up # 随机在圆内生成 $n$ 个点, 这 $n$ 个点在同一个半圆的概率是多少?\n答案还是 $\\frac{n}{2^{n - 1}}$ , 其实圆内某些点是否在同一个半圆, 这与它们所在半径的端点是否在同一个半圆是等价的, 所以答案不变. 这也提供了另一种思路: 考虑 $n$ 个点所在的 $n$ 条半径, 以及半径反向延长的那 $n$ 条半径, 我们的问题变成了: 从 $n$ 条直径的 $2n$ 条半径中选出 $n$ 个, 求它们相邻概率. 这个概率是 $\\frac{2n}{2^n} = \\frac{2}{2^{n - 1}}$ . 更详细的讨论可以参考这里. ","date":"10 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%9810_%E7%82%B9%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%9C%86%E7%9A%84%E6%A6%82%E7%8E%87/","section":"Posts","summary":"趣题: 点在同一个半圆的概率 # 题目 # 随机在圆上生成 $n$ 个点, 这 $n$ 个点在同一个半圆的概率是多少?","title":"趣题: 点在同一个半圆的概率"},{"content":"Information Retrieval # Some notes on Information Resource Management @THU, mainly about IR models.\nBoolean Model # The Boolean Model (also known as the Pure Boolean Model) is a set-theoretic model. The basic idea is to represent documents and queries as sets of terms. The Boolean operators are used to combine the terms in the query to produce the set of documents that satisfy the query.\nBoolean Model has no ranking as its result of a query is only \u0026ldquo;YES\u0026rdquo; or \u0026ldquo;NO\u0026rdquo;.\nFuzzy Model # The Fuzzy Model (also known as the Extended Boolean Model) is another type of set-theoretic model. It introduces membership values to represent the degree of association of a term within a document.\nIn the Fuzzy Model, the relationship between each term and document is no longer strictly \u0026ldquo;present\u0026rdquo; or \u0026ldquo;absent,\u0026rdquo; but is described using membership values. This implies that a term can appear in a document to varying degrees, capturing the similarity between documents and queries more accurately.\nThe Fuzzy Model holds an advantage in handling fuzzy queries, as it allows for partial matching and fuzzy matching. It is suitable for more complex queries and more realistic information retrieval needs. The membership values in the Fuzzy Model typically range from $0$ to $1$, reflecting the importance or relevance of a term within a document.\nSpecifically, for a document\u0026rsquo;s degree of membership in the set of terms $A$, denoted as $v(A)$, it follows that:\n$v(A \\cup B) = \\max(v(A), v(B))$ $v(A \\cap B) = \\min(v(A), v(B))$ $v(\\neg A) = 1 - v(A)$ In practice, the membership function can be defined using term weights, such as term frequency, TF-IDF, and others.\nVector Space Model # The Vector Space Model (VSM) is an algebraic model. It represents documents and queries as vectors in a multi-dimensional space. The similarity between documents and queries is measured by the cosine of the angle between the vectors.\nThe weight of a term in a document is typically computed using binary weights, raw term frequency or TF-IDF.\nProbabilistic Model # The Probabilistic Model is a rigorous formalized model designed to predict the probability of documents being relevant to a given query. This model ranks the retrieved documents based on the probabilities associated with the relevance of documents to the query. This model relies on accurate probability estimates (which can be challenging to obtain). The probabilistic model is currently a dominant retrieval model.\nUsually we use Naive Bayes to estimate the probability of relevance of a document to a query. Consider the Bayes\u0026rsquo; Theorem: $$ P(R|D) = \\frac{P(D|R)P(R)}{P(D)} $$ We can classify a document $D$ as relevant if $$ \\frac{P(D|R)}{P(D|NR)} \u0026gt; \\frac{P(NR)}{P(R)} $$ Left-hand side is the likelihood of a document being relevant given the query, and right-hand side is the prior probability of a document being relevant. Do some math, we can get $$ \\begin{aligned} \\frac{P(D|R)}{P(D|NR)}\u0026amp;=\\prod_{i: d_i = 1}\\frac{p_i}{s_i} \\cdot \\prod_{i: d_i = 0}\\frac{1-s_i}{1-p_i}\\\\ \u0026amp;=\\prod_{i: d_i = 1}\\frac{p_i(1-s_i)}{s_i(1-p_i)} \\cdot \\prod_{i}\\frac{1-p_i}{1-s_i} \\end{aligned} $$ So we can use $\\prod_{i: d_i = 1}\\frac{p_i(1-s_i)}{s_i(1-p_i)}$ to estimate how likely a document is relevant to a query.\nWhen it comes to calculating the score function, we have $$ \\frac{p_i(1-s_i)}{s_i(1-p_i)} = \\frac{\\frac{pi}{1-pi}}{\\frac{s_i}{1-s_i}} = \\frac{\\frac{r}{R-r}}{\\frac{n-r}{(N-n) - (R-r)}} $$ This is Robertson-Sparck Jones weighting scheme and in practice a $0.5$ is added to the numerator and denominator to avoid division by zero.\n","date":"10 August 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/notes-on-information-retrieval/","section":"Posts","summary":"Information Retrieval # Some notes on Information Resource Management @THU, mainly about IR models.","title":"Notes on Information Retrieval"},{"content":"","date":null,"permalink":"/tags/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2/","section":"Tags","summary":"","title":"信息检索"},{"content":"","date":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"机器学习"},{"content":"","date":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法"},{"content":"","date":null,"permalink":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/","section":"Tags","summary":"","title":"计算机"},{"content":"机器学习: NFL定理 # \u0026ldquo;No Free Lunch Theorem\u0026rdquo;, 简称 NFL 定理, 是由 David Wolpert 和 William Macready 于 1997 年提出的, 它对机器学习的局限性提供了深刻的洞见.\nNFL 定理告诉我们, 不同算法的期望性能是相同的. 具体而言, 考虑离散的样本空间 $\\mathcal{X}$ 和假设空间 $\\mathcal{H}$ , 如果想要学习的真实目标函数为 $f$ , 那么对于给定模型 $\\mathfrak{L}$ , 其训练集外误差为 $$ E_{ote}\\left(\\mathfrak{L}|X,f\\right) =\\sum_{h}\\sum_{x\\in \\mathcal{X}-X}P\\left(x\\right)\\mathbb{I}\\left(h\\left(x\\right)\\neq f\\left(x\\right)\\right)P\\left(h\\mid X,\\mathfrak{L}\\right) $$ 假定 $f$ 服从均匀分布, 那么对误差项求和, 有 $$ \\begin{aligned} \\sum_{f}E_{ote}\\left(\\mathfrak{L}|X,f\\right)\n\u0026amp; =\\sum_{f}\\sum_{h}\\sum_{x\\in \\mathcal{X}-X}P\\left(x\\right)\\mathbb{I}\\left(h\\left(x\\right)\\neq f\\left(x\\right)\\right)P\\left(h\\mid X,\\mathfrak{L}\\right) \\\\ \u0026amp;=\\sum_{x\\in{\\cal X}-X}P(x)\\sum_{h}P(h\\mid X,{\\mathfrak{L}})\\sum_{f}\\mathbb{I}(h(x)\\neq f(x)) \\\\ \u0026amp;=\\sum_{x\\in{\\cal X}-X}P\\left(x\\right)\\sum_{h}P\\left(h|X,{\\mathfrak{L}}\\right)\\frac{1}{2}2\\left|X\\right| \\\\ \u0026amp;=\\frac{1}{2}2^{\\left|\\mathcal{X}\\right|}\\sum_{x\\in\\mathcal{X}-X}P\\left(x\\right)\\sum_{h}P\\left(h\\mid X,\\mathfrak{L}\\right) \\\\ \u0026amp;=2^{|\\mathcal{X}|-1}\\sum\\limits_{x\\in\\mathcal{X}-X}P(x) \\cdot 1 \\end{aligned} $$ 可以发现总误差 (平均误差) 与算法 $\\mathfrak{L}$ 没有关系.\n","date":"10 August 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0_nfl%E5%AE%9A%E7%90%86/","section":"Posts","summary":"机器学习: NFL定理 # \u0026ldquo;No Free Lunch Theorem\u0026rdquo;, 简称 NFL 定理, 是由 David Wolpert 和 William Macready 于 1997 年提出的, 它对机器学习的局限性提供了深刻的洞见.","title":"机器学习: NFL定理"},{"content":"","date":null,"permalink":"/tags/leetcode/","section":"Tags","summary":"","title":"LeetCode"},{"content":"LeetCode-2209 用地毯覆盖后的最少白色砖块 # Solution 1 # 记 $dp[i][j]$ 代表在 $floor[0:i]$ 这一段使用 $j$ 条地毯覆盖后的最少白色砖块数. 状态转移考虑是否在最右侧放置地毯即可. 代码如下:\nclass Solution: def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -\u0026gt; int: n = len(floor) dp = [[0] * (numCarpets + 1) for _ in range(n)] dp[0][0] = floor[0] == \u0026#39;1\u0026#39; for i in range(1, n): for j in range(0, numCarpets + 1): dp[i][j] = dp[i - 1][j] + (floor[i] == \u0026#39;1\u0026#39;) if j \u0026gt; 0: if i \u0026gt;= carpetLen: dp[i][j] = min(dp[i][j], dp[i - carpetLen][j - 1]) else: dp[i][j] = min(dp[i][j], 0) return dp[n - 1][numCarpets] ","date":"9 August 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2209-%E7%94%A8%E5%9C%B0%E6%AF%AF%E8%A6%86%E7%9B%96%E5%90%8E%E7%9A%84%E6%9C%80%E5%B0%91%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97/","section":"Posts","summary":"LeetCode-2209 用地毯覆盖后的最少白色砖块 # Solution 1 # 记 $dp[i][j]$ 代表在 $floor[0:i]$ 这一段使用 $j$ 条地毯覆盖后的最少白色砖块数.","title":"LeetCode-2209 用地毯覆盖后的最少白色砖块"},{"content":"","date":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python"},{"content":"","date":null,"permalink":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Tags","summary":"","title":"动态规划"},{"content":"LeetCode-2188 完成比赛的最少时间 # Solution 1 # 完成比赛相当于把圈数划分成连续的若干段, 其总时间等于各子段所需要的时间加上 \u0026ldquo;划分\u0026rdquo; (也就是题中的换胎操作) 所需要的时间. 定义 $cost[i]$ 也就是连续跑 $i$ 圈所花费的最少时间. 需要注意的是, 由指数的特性, 如果 $cost[i] \\geq cost[i - 1] + cost[1] + changeTime$ , 那么就没必要计算 $cost[i + 1], \u0026hellip; cost[n]$ 了.\n代码如下:\nclass Solution: def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -\u0026gt; int: def geometric_series_sum(r, k): return k if r == 1 else int((1 - r**k) / (1 - r)) cost = [inf] * (numLaps + 1) for i in range(1, numLaps + 1): cost[i] = min( cost[i], min([f * geometric_series_sum(r, i) for f, r in tires]), ) if cost[i] \u0026gt; cost[i - 1] + cost[1] + changeTime: break dp = [inf] * (numLaps + 1) for i in range(1, numLaps + 1): dp[i] = cost[i] for j in range(1, i): dp[i] = min(dp[i], dp[j] + cost[i - j] + changeTime) return dp[numLaps] ","date":"9 August 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2188-%E5%AE%8C%E6%88%90%E6%AF%94%E8%B5%9B%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/","section":"Posts","summary":"LeetCode-2188 完成比赛的最少时间 # Solution 1 # 完成比赛相当于把圈数划分成连续的若干段, 其总时间等于各子段所需要的时间加上 \u0026ldquo;划分\u0026rdquo; (也就是题中的换胎操作) 所需要的时间.","title":"LeetCode-2188 完成比赛的最少时间"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E8%AE%BA/","section":"Tags","summary":"","title":"数论"},{"content":"趣题: 找出所有符合要求的 n # 题目 # 设 $1 = d_1 \u0026lt; d_2 \u0026lt; \u0026hellip; \u0026lt; d_k = n$ 是合数 $n$ 的全部正因数, 若对任意 $1\\leq i\\leq k-2$ , 均有 $d_i\\mid d_{i + 1} + d_{i + 2}$ , 求 $n$ .\nSolution 1 # 首先, $d_2$ 为 $n$ 最小的素因子, 记作为 $p$ . $d_{k - 2}\\mid d_{k-1} + d_k$ , 由于 $d_{k - 2}\\mid d_k = n$ , $d_{k - 2}\\mid d_{k - 1}$ , 即 $\\frac{n}{d_3}\\mid \\frac{n}{d_2}$ , 有 $d_2\\mid d_3$ , $p$ 也是 $d_3$ 的最小素因子. 假设 $d_3$ 有其它素因子 $q \u0026gt; p$ , 那么 $d_2 = p \u0026lt; q \u0026lt; d_3$ , 这与 $d_2, d_3$ 之间没有其他 $n$ 的正因数矛盾. 故 $d_3$ 只有 $p$ 这一素因子, $d_3$ 只能为 $p^2$ . 又因为 $p\\mid d_3 + d_4$ , 故 $p\\mid d_4$ , 同样可证 $d_4$ 只有 $p$ 这一素因子, $d_4$ 只能为 $p^3$ . 以此类推, $d_i$ 只能为 $p^{i - 1}$ . 由于 $d_k = n$ , 有 $p^{k - 1} = n$ , 故 $n$ 为素数的 $t$ 次方 ($t\\geq 2$) . 不难验证 $n = p^t(t\\geq 2)$ 时满足题给性质. 综上, $n$ 为素数的 $t$ 次方 ($t\\geq 2$) .\n","date":"2 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%989_%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E7%AC%A6%E5%90%88%E8%A6%81%E6%B1%82%E7%9A%84-n/","section":"Posts","summary":"趣题: 找出所有符合要求的 n # 题目 # 设 $1 = d_1 \u0026lt; d_2 \u0026lt; \u0026hellip; \u0026lt; d_k = n$ 是合数 $n$ 的全部正因数, 若对任意 $1\\leq i\\leq k-2$ , 均有 $d_i\\mid d_{i + 1} + d_{i + 2}$ , 求 $n$ .","title":"趣题: 找出所有符合要求的 n"},{"content":"","date":null,"permalink":"/tags/c++/","section":"Tags","summary":"","title":"C++"},{"content":"LeetCode-2681 英雄的力量 # Solution 1 # 不要求序列连续, 所以可以先将数组排序, 以下讨论均基于排序后的 $nums$ . 考虑单个元素组成的序列, 这部分的值和为 $\\sum_{0\\leq i \u0026lt; n}nums^3[i]$ . 对于更多元素的序列, 假设最小值为 $nums[i]$ , 最大值为 $nums[j]$ , 那么一个序列的值为 $nums[i]\\times nums^2[j]$ , 这样的序列有 $2^{j - i - 1}$ 个. 这部分的值和即为 $$ \\sum_{0\\leq i \u0026lt; j \u0026lt; n}nums[i]\\times nums^2[j]\\times 2^{j - i - 1} $$ 直接计算的话时间复杂度是 $O(n^2)$ , 考虑使用前缀和优化. 将上式改写为 $$ \\sum_{0\\leq i \u0026lt; n - 1}[\\frac{nums[i]}{2^{i+1}}(\\sum_{i \u0026lt; j \u0026lt; n}nums^2[j]\\times 2^j)] \\= \\sum_{0\\leq i \u0026lt; n - 1}[\\frac{nums[i]}{2^{i+1}}(\\sum_{0 \u0026lt; j \\leq n - 1}nums^2[j]\\times 2^j - \\sum_{0 \u0026lt; j \\leq i} nums^2[j]\\times 2^j) ] $$ 可以使用 $O(n)$ 的时间预处理出 $\\sum_{0\\leq j \\leq i}nums^2[j]\\times 2^j$ , 从而可以在 $O(n)$ 的时间内计算出答案. 需要注意的是, 取模意义下的除法需要使用逆元进行处理.\nusing ll = long long; const int MOD = 1e9 + 7; class Solution { public: // 快速幂 ll power(ll x, ll n) { ll result = 1; while (n \u0026gt; 0) { if (n % 2 == 1) { result = (result * x) % MOD; } x = (x * x) % MOD; n /= 2; } return result; } // 逆元 ll inverse(ll x) { return power(x, MOD - 2); } int sumOfPower(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end()); int n = nums.size(); vector\u0026lt;ll\u0026gt; sum(n, 0); for (int i = 0; i \u0026lt; n; i++) { sum[i] = ((nums[i] * 1LL) % MOD * nums[i] % MOD * power(2, i)) % MOD; if (i \u0026gt; 0) { sum[i] = (sum[i] + sum[i - 1]) % MOD; } } ll ans = 0; for (int i = 0; i \u0026lt; n - 1; i++) { ll coef = (nums[i] * 1LL * (sum[n - 1] - sum[i])) % MOD; coef = (coef * inverse(power(2, i + 1))) % MOD; ans = (ans + coef) % MOD; } for (int v : nums) { ans = (ans + ((v * 1LL * v) % MOD) * v) % MOD; } return ans \u0026gt;= 0? ans: ans + MOD; } }; Solution 2 # 记 $dp[i]$ 为以 $nums[i]$ 为最大值 (也就是结尾) 的序列的最小值的和, 那么有 $$ dp[i] = nums[i] + \\sum_{j = 0}^{i - 1}dp[j] $$ 目标即为 $$ \\sum_{i = 0}^{n - 1}dp[i]\\times nums^2[i] $$\nusing ll = long long; const int MOD = 1e9 + 7; class Solution { public: int sumOfPower(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); int dp = 0, preSum = 0; int res = 0; for (int i = 0; i \u0026lt; n; i++) { dp = (nums[i] + preSum) % MOD; preSum = (preSum + dp) % MOD; res = (int) ((res + (ll) nums[i] * nums[i] % MOD * dp) % MOD); if (res \u0026lt; 0) { res += MOD; } } return res; } }; ","date":"1 August 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2681-%E8%8B%B1%E9%9B%84%E7%9A%84%E5%8A%9B%E9%87%8F/","section":"Posts","summary":"LeetCode-2681 英雄的力量 # Solution 1 # 不要求序列连续, 所以可以先将数组排序, 以下讨论均基于排序后的 $nums$ .","title":"LeetCode-2681 英雄的力量"},{"content":"趣题: 包含(1, 0)的圆弧 # 题目 # 在单位圆 $x^2 +y^2 =1$ 上按均匀分布随机取 $n$ 个点($n \\geq 2$), 这 $n$ 个点可以把单位圆分成 $n$ 段圆弧, 求包含点 $(1.0)$ 的圆弧的长度的数学期望和方差.\nSolution 1 # 不妨设 $n$ 个点的弧度分别为 $0\\leq \\xi_1, \\xi_2, \u0026hellip;\\xi_n \\leq 2\\pi$ , 记 $\\xi_1^{*}=min{\\xi_1, \u0026hellip;, \\xi_n}$ , $\\xi_n^{*}=max{\\xi_1, \u0026hellip;, \\xi_n}$ , 那么包含 $(1, 0)$ 的圆弧的长度为 $\\xi_1^{*} + 2\\pi - \\xi_n^{*}$ . $$P(\\xi_1^{*} \u0026gt; x) = \\prod_{1\\leq i\\leq n}P(\\xi_i \u0026gt; x) = (1 - \\frac{x}{2\\pi})^n$$ $$P(\\xi_n^{*} \u0026lt; x) = \\prod_{1\\leq i\\leq n}P(\\xi_i \u0026lt; x) = (\\frac{x}{2\\pi})^n$$ 计算 $E[\\xi_1^{*}]$ : $$ E[\\xi_1^{*}] = \\int_{0}^{2\\pi}xf(x)dx = \\int_{0}^{2\\pi}xdF(x) = \\int_{0}^{2\\pi}\\int_{0}^{x}dydF(x) = \\int_{0}^{2\\pi}\\int_{y}^{2\\pi}df(x)dy = \\int_{0}^{2\\pi}P(\\xi_1^{*} \u0026gt; y)dy = \\int_{0}^{2\\pi}(1 - \\frac{y}{2\\pi})^ndy = \\frac{2\\pi}{n+1} $$ 类似地, $$E[\\xi_n^{*}] = 2\\pi - \\frac{2\\pi}{n+1}$$ 故 $$E[\\xi_1^{*} + 2\\pi - \\xi_n^{*}] = \\frac{4\\pi}{n + 1}$$\n对于方差, 有 $Var[X] = E[X^2] - E^2[X]$ . 考虑计算 $E[(\\xi_1^{*} + 2\\pi - \\xi_n^{*})^2] = 4\\pi^2+4\\pi E[xi_1^{*}] - 4\\pi E[\\xi_n^{*}] + E[{\\xi_1^{*}}^2] + E[{\\xi_n^{*}}^2] - 2E[\\xi_1^{*} \\xi_n^{*}]$ . 重点计算 $E[\\xi_1^{*} \\xi_n^{*}]$ . 考虑 $$F(x, y) = P(\\xi_1^{*} \\leq x, \\xi_n^{*} \\leq y) \\= P(\\xi_n^{*}\\leq y) - P(x\u0026lt; \\xi_1^{*}, \\xi_n^{*}\\leq y) \\= P(\\xi_n^{*}\\leq y) - \\prod_{1\\leq i\\leq n}P(x\u0026lt;\\xi_i\\leq y) \\= (\\frac{y}{2\\pi})^n - (\\frac{y - x}{2\\pi})^n$$ 有 $$ f(x, y) = \\frac{\\partial^2 F(x, y)}{\\partial x \\partial y} =\\frac{n(n - 1)}{(2\\pi)^n}(y - x)^{n-2}$$ 计算 $$E[\\xi_1^{*} \\xi_n^{*}] = \\int_{0}^{2\\pi}\\int_{0}^{2\\pi}xyf(x, y)dxdy =\\frac{4\\pi^2}{n+2} $$ 对于 $E[{\\xi_1^{*}}^2]$ , 类似 $E[\\xi_1^{*}]$ , 计算得 $E[{\\xi_1^{*}}^2] = \\frac{8\\pi^2}{(n + 1)(n+ 2)}$ . 同理 $E[{\\xi_n^{*}}^2] = 4\\pi^2 - \\frac{8\\pi^2}{n+ 2}$ . 故 $$Var(x) = \\frac{8\\pi^2(n -1)}{(n+1)^2(n+2)}$$\n","date":"1 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%988_%E5%8C%85%E5%90%AB1-0%E7%9A%84%E5%9C%86%E5%BC%A7/","section":"Posts","summary":"趣题: 包含(1, 0)的圆弧 # 题目 # 在单位圆 $x^2 +y^2 =1$ 上按均匀分布随机取 $n$ 个点($n \\geq 2$), 这 $n$ 个点可以把单位圆分成 $n$ 段圆弧, 求包含点 $(1.","title":"趣题: 包含(1, 0)的圆弧长度的期望和方差"},{"content":"趣题: 好点个数的期望值 # 题目 # 在区间 $[0,1]$ 上按均匀分布独立地画 $n$ 个点 ($n\\geq 3$). 定义一个点 $P$ 的邻居为最靠近 $P$ 的点. 若一个点的邻居的邻居是它本身, 那么我们称这个点是好点. 求好点个数的数学期望.\nSolution 1 # 由好点的定义, 如果 $A$ 是好点, 它的邻居是 $B$ , 那么 $B$ 也满足好点的性质, 故好点是成对出现的. 记 $\\epsilon_{i, j}$ 为点 $i, j$ 是否为一对好点 (以取值 $1$ 或 $0$ 表示) , 则好点个数 $$Y = \\sum_{1\\leq i\u0026lt;{j}\\leq n}{2\\epsilon_{i, j}}$$ 有 $$E[Y] = \\sum_{1\\leq i\u0026lt;{j}\\leq n}{2E[\\epsilon_{i, j}]} = n(n - 1)E[\\epsilon_{1, 2}]$$ $E[\\epsilon_{1,2}]$ 即为 $X_1, X_2$ 互为邻居的概率. 假设 $X_1 \\leq X_2$ , 我们计算 $X_1, X_2$ 互为邻居的概率($E[\\epsilon_{1, 2}]$ 是这个概率的两倍). 有以下三种可能的情况:\n$X_1, X_2$ 在区间中间; $X_1, X_2$ 在区间最左侧; $X_1, X_2$ 在区间最右侧; 以第一种情况为例, 计算 $$P(X_2 - X_1 \\leq X_1, \\X_2 - X_1 \\leq 1 - X_2,\n\\X_3\\in[0, X_1 - (X_2 -1)]\\cup[X_2 + (X_2 - X_1), 1], \\\u0026hellip;, \\X_n\\in[0, X_1 - (X_2 -1)]\\cup[X_2 + (X_2 - X_1), 1]) $$ 这是一个略烦琐的二重积分, 计算结果为 $\\frac{1}{3n}$ . 第二、三种情况的计算结果均为 $\\frac{1}{6n(n - 1)}$ . 所以 $$E[Y] = n(n - 1)E[\\epsilon_{1,2}] \\= n(n - 1)\\times 2(\\frac{1}{3n} + \\frac{1}{6n(n - 1)} + \\frac{1}{6n(n - 1)}) \\= \\frac{2n}{3}$$\nSolution 2 # 记目标期望为 $f(n)$ . 假设 $X_1 \\leq X_2 \\leq \u0026hellip;\\leq X_n$ , 记 $Y_1 = X_2 - X_1 , \u0026hellip;, Y_{n - 1} = X_n - X_{n - 1}$ , 则 $Y_i$ 独立同分布. 因为 $X_1$ 的邻居只可能是 $X_2$ , 如果 $Y_1 \\leq Y_2$ , 则 $X_1, X_2$ 是一对好点, 且 $X_3$ 的邻居只可能是 $X_4$ , 这时问题化归为 $n - 2$ 个点的情况; 如果 $Y_1 \u0026gt; Y_2$ , 则 $X_2$ 的邻居只可能是 $X_3$, 化归到了 $n - 1$ 个点的情况. 显然 $Y_1 \\leq Y_2$ 与 $Y_1 \u0026gt; Y_2$ 概率相等, 故有递推式 $f(n) = \\frac{1}{2}[f(n-1) + 2] + \\frac{1}{2}f(n - 2)$ . 不难得到 $f(n) = \\frac{2n}{3}$ .\n","date":"1 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%987_%E5%A5%BD%E7%82%B9%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%80%BC/","section":"Posts","summary":"趣题: 好点个数的期望值 # 题目 # 在区间 $[0,1]$ 上按均匀分布独立地画 $n$ 个点 ($n\\geq 3$).","title":"趣题: 好点个数的期望值"},{"content":"","date":null,"permalink":"/tags/%E4%BB%A3%E6%95%B0/","section":"Tags","summary":"","title":"代数"},{"content":"趣题: 取整函数项的和 # 题目 # 计算 $$f(n) =\\sum_{k = 1}^{\\infin}\\lfloor\\frac{n+2^k}{2^{k+1}}\\rfloor$$\nSolution 1 # 计算发现 $f(0) = 0, f(1) = 1, f(2) = 2, f(3) = 3$ , 不妨猜测 $f(n) = n$ . 考虑 $f(n + 1)$ , 记 $g(n, k) = \\lfloor\\frac{n+1+2^k}{2^{k+1}}\\rfloor - \\lfloor\\frac{n+2^k}{2^{k+1}}\\rfloor$ , 有 $g(n)$ 取值为 $0$ 或 $1$ , 当且仅当 $2^{k+1} \\mid n + 1 + 2^k$ 时取 $1$ . 由于 $2^{k+1}\\mid n + 1 + 2^k$ , 有 $2^{k} \\mid n + 1$ 且 $2^{k+1}\\nmid n + 1 $ , 故 $2^k\\parallel n + 1$ . 在 $n$ 取定时这样的 $k$ 唯一, 故 $f(n+1) - f(n) = \\sum_{k = 1}^{\\infin}g(n, k) = 1$ , 从而 $f(n) = n$ .\nSolution 2 # 由 Hermite 恒等式 $$ \\sum_{i=0}^{n}\\lfloor x + \\frac{i}{n}\\rfloor = \\lfloor nx\\rfloor $$ 取 $n = 2$ 有 $$\\lfloor x\\rfloor + \\lfloor x + \\frac{1}{2}\\rfloor= \\lfloor 2x\\rfloor $$ 因此有裂项 $$ \\lfloor\\frac{n+2^k}{2^{k+1}}\\rfloor = \\lfloor\\frac{n}{2^{k+1}} + \\frac{1}{2}\\rfloor = \\lfloor\\frac{n}{2^k}\\rfloor - \\lfloor\\frac{n}{2^{k+1}}\\rfloor $$ 故 $$f(n) = \\lim_{k\\to\\infin}\\lfloor n\\rfloor - \\lfloor\\frac{n}{2^{k+1}}\\rfloor = n$$\n","date":"1 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%986_%E5%8F%96%E6%95%B4%E5%87%BD%E6%95%B0%E9%A1%B9%E7%9A%84%E5%92%8C/","section":"Posts","summary":"趣题: 取整函数项的和 # 题目 # 计算 $$f(n) =\\sum_{k = 1}^{\\infin}\\lfloor\\frac{n+2^k}{2^{k+1}}\\rfloor$$","title":"趣题: 取整函数项的和"},{"content":"","date":null,"permalink":"/tags/%E4%B8%8D%E7%AD%89%E5%BC%8F/","section":"Tags","summary":"","title":"不等式"},{"content":"","date":null,"permalink":"/tags/%E8%B4%AA%E5%BF%83/","section":"Tags","summary":"","title":"贪心"},{"content":"趣题: 证明存在系数使得不等式成立 # 题目 # 设 $a_1, a_2, \u0026hellip; , a_n(n\\geq 2)$ 为实数, 证明: 可以选取 $\\epsilon_1, \\epsilon_2, \u0026hellip;, \\epsilon_n\\in{-1, 1}$ , 使得 $$ (\\sum_{i = 1}^{n}a_i)^2+(\\sum_{i = 1}^{n}\\epsilon_i a_i)^2\\leq (n+1)\\sum_{i=1}^{n}a_i^2 $$\nSolution 1 # 由对称性不妨假设 $a_1\\geq a_2\\geq \u0026hellip;\\geq 0$ . 考虑如下的 $\\epsilon_i$ 取法:\n$\\epsilon_1 = 1$ ; $\\epsilon_{k + 1}$ 取和 $\\sum_{i = 1}^{k}\\epsilon_i a_i$ 相反的符号; 由于 $a_1\\geq a_2\\geq \u0026hellip;\\geq 0$ , 故 $\\vert \\sum_{i=1}^{k}\\epsilon_i a_i\\vert$ 不增, 故有 $\\vert \\sum_{i=1}^{k}\\epsilon_i a_i\\vert \\leq a_1$ , 从而有 $(\\sum_{i=1}^{n}\\epsilon_i a_i)^2\\leq a_1^2\\leq \\sum_{i=1}^n a_i^2$ . 又由柯西不等式有 $(\\sum_{i = 1}^{n}a_i)^2 \\leq n\\sum_{i=1}^na_i^2$ , 所以 $$ (\\sum_{i = 1}^{n}a_i)^2+(\\sum_{i = 1}^{n}\\epsilon_i a_i)^2\\leq (n+1)\\sum_{i=1}^{n}a_i^2 $$ 成立.\n","date":"1 August 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%985_%E8%AF%81%E6%98%8E%E5%AD%98%E5%9C%A8%E7%B3%BB%E6%95%B0%E4%BD%BF%E5%BE%97%E4%B8%8D%E7%AD%89%E5%BC%8F%E6%88%90%E7%AB%8B-copy/","section":"Posts","summary":"趣题: 证明存在系数使得不等式成立 # 题目 # 设 $a_1, a_2, \u0026hellip; , a_n(n\\geq 2)$ 为实数, 证明: 可以选取 $\\epsilon_1, \\epsilon_2, \u0026hellip;, \\epsilon_n\\in{-1, 1}$ , 使得 $$ (\\sum_{i = 1}^{n}a_i)^2+(\\sum_{i = 1}^{n}\\epsilon_i a_i)^2\\leq (n+1)\\sum_{i=1}^{n}a_i^2 $$","title":"趣题: 证明存在系数使得不等式成立"},{"content":"趣题: 证明一个式子不为整数 # 题目 # 设 $a,b\\in \\Z$ , 证明 $\\frac{2a^2 - 1}{b^2 + 2}\\notin\\Z$ .\nSolution 1 # 假设 $\\frac{2a^2 - 1}{b^2 + 2}\\in \\Z$ , 则有 $b^2 + 2 \\mid 2a^2 - 1$ , 因为 $2a^2 - 1$ 为奇数, 故 $b$ 为奇数. 考虑模 $4$ 的情况, $b^2 \\equiv 1\\ mod\\ 4$ , $b^2 + 2\\equiv 3\\ mod\\ 4$ , 故 $b^2 + 2$ 必有一个形如 $4k + 3$ 的素因子, 不妨记为 $p$ , 有 $-b^2\\equiv 2\\ mod\\ p$ ; 又因为 $b^2 + 2 \\mid 2a^2 - 1$ , 故 $-1 \\equiv -2a^2\\equiv a^2b^2\\ mod\\ p$ , 有 $a, b$ 均与 $p$ 互质. 由费马小定理, 有 $(ab)^{p-1}\\equiv 1\\ mod\\ p$ . 而 $(ab)^{p - 1} \\equiv (ab)^{4k+2} \\equiv (a^2b^2)^{2k+1} \\equiv (-1)^{2k+1} \\equiv -1\\ mod\\ p$ , 这与 $(ab)^{p-1}\\equiv 1\\ mod\\ p$ 矛盾, 故假设不成立, 即 $\\frac{2a^2 - 1}{b^2 + 2}\\notin\\Z$ .\n","date":"31 July 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%984_%E8%AF%81%E6%98%8E%E4%B8%80%E4%B8%AA%E5%BC%8F%E5%AD%90%E4%B8%8D%E4%B8%BA%E6%95%B4%E6%95%B0/","section":"Posts","summary":"趣题: 证明一个式子不为整数 # 题目 # 设 $a,b\\in \\Z$ , 证明 $\\frac{2a^2 - 1}{b^2 + 2}\\notin\\Z$ .","title":"趣题: 证明一个式子不为整数"},{"content":"LeetCode-2791 树中可以形成回文的路径数 # Solution1 # 允许路径上的字符重新排列后组成回文串, 因此我们只关心路径上字符的数量, 更准确地说是只关心字符数量的奇偶性, 通过状态压缩可以用一个数代表一条路径的字符状态 (不妨用 $xor$ 来表示, 可以发现路径的拼接和裁剪相当于作异或操作) . 考虑从 $A$ 到 $B$ 的路径值 $xor(A, B)$ 可以表示为两条路径的异或和 $xor(LCA(A, B), A) \\oplus xor(LCA(A, B), B)$ ; 进一步地, 将 $xor(LCA(A,B), A)$ 表示成 $xor(0, LCA(A, B)) \\oplus xor(0, A)$ , 同样处理 $xor(LCA(A,B), B)$ , 则有 $$xor(A, B) \\= xor(0, LCA(A, B)) \\oplus xor(0, A) \\oplus xor(0, LCA(A, B)) \\oplus xor(0, B) \\= xor(0, A) + xor(0, B) $$ 故在深度优先搜索计算异或值时计数即可.\nusing ll = long long; class Solution { public: long long countPalindromePaths(vector\u0026lt;int\u0026gt;\u0026amp; parent, string s) { int n = parent.size(); ll ans = 0; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; e[n]; for (int i = 1; i \u0026lt; n; i++) { e[parent[i]].emplace_back(i, 1 \u0026lt;\u0026lt; (s[i] - \u0026#39;a\u0026#39;)); } unordered_map\u0026lt;int, int\u0026gt; cnt; function\u0026lt;void(int, int)\u0026gt; dfs = [\u0026amp;](int x, int xor_x) { ans += cnt[xor_x]; for (int i = 0; i \u0026lt; 26; i++) { ans += cnt[xor_x ^ (1 \u0026lt;\u0026lt; i)]; } cnt[xor_x]++; for (auto y : e[x]) { dfs(y.first, xor_x ^ y.second); } }; dfs(0, 0); return ans; } }; ","date":"31 July 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2791-%E6%A0%91%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E5%9B%9E%E6%96%87%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/","section":"Posts","summary":"LeetCode-2791 树中可以形成回文的路径数 # Solution1 # 允许路径上的字符重新排列后组成回文串, 因此我们只关心路径上字符的数量, 更准确地说是只关心字符数量的奇偶性, 通过状态压缩可以用一个数代表一条路径的字符状态 (不妨用 $xor$ 来表示, 可以发现路径的拼接和裁剪相当于作异或操作) .","title":"LeetCode-2791 树中可以形成回文的路径数"},{"content":"","date":null,"permalink":"/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/","section":"Tags","summary":"","title":"状态压缩"},{"content":"LeetCode-2790 长度递增组的最大数目 # Solution 1 # 二分搜索答案. 考虑从大到小排序后的数组与目标数组的差异, 注意前面少的可以用后面多的补.\nusing ll = long long; class Solution { public: int maxIncreasingGroups(vector\u0026lt;int\u0026gt;\u0026amp; usageLimits) { sort(usageLimits.begin(), usageLimits.end(), greater\u0026lt;int\u0026gt;()); auto check = [\u0026amp;](int m) { int res = 0; for (int i = 0; i \u0026lt; usageLimits.size(); i++) { res = min(res + usageLimits[i] - max(m - i, 0), 0); } return res \u0026gt;= 0; }; ll left = 2, right = usageLimits.size() + 1; while (left \u0026lt; right) { ll mid = left + (right - left) / 2; if (check(mid)) { left = mid + 1; } else { right = mid; } } return left - 1; } }; Solution 2 # 考虑如下的构造方法:\n考虑一个形如上三角矩阵的网格, 我们从数量小的数字开始填格子; 前 $k$ 行至多形成 $k$ 组, 需要 $\\frac{k(k+1)}{2}$ 个数字; 统计数字数量是否够就可以. 这种构造方法的精妙之处在于, 从数量小的数字开始填, 详细的思路讲解参见0x3f的周赛讲解:证明题？构造题！【力扣周赛 355】\nusing ll = long long; class Solution { public: int maxIncreasingGroups(vector\u0026lt;int\u0026gt;\u0026amp; usageLimits) { sort(usageLimits.begin(), usageLimits.end()); ll res = 0, ans = 0; for (int v: usageLimits) { res += v; if (res \u0026gt;= (ans + 1) * (ans + 2) / 2) { ans++; } } return ans; } }; ","date":"29 July 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2790-%E9%95%BF%E5%BA%A6%E9%80%92%E5%A2%9E%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2790 长度递增组的最大数目 # Solution 1 # 二分搜索答案.","title":"LeetCode-2790 长度递增组的最大数目"},{"content":"","date":null,"permalink":"/tags/%E6%9E%84%E9%80%A0/","section":"Tags","summary":"","title":"构造"},{"content":"","date":null,"permalink":"/tags/sql/","section":"Tags","summary":"","title":"SQL"},{"content":"SQL 计算次日留存率 # 计算留存率是 SQL 的典型题目, 这里以牛客网的题目为例. 数据表如下:\n{ \u0026#34;question_practice_detail\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;编号\u0026#34;, \u0026#34;device_id\u0026#34;: \u0026#34;用户使用的设备编号\u0026#34;, \u0026#34;quest_id\u0026#34;: \u0026#34;题目编号\u0026#34;, \u0026#34;result\u0026#34;: \u0026#34;答题结果\u0026#34;, \u0026#34;date\u0026#34;: \u0026#34;日期\u0026#34; } ] } 要求返回的结果为:\n{ \u0026#34;result\u0026#34;: [ { \u0026#34;avg_ret\u0026#34;: \u0026#34;平均留存率\u0026#34; } ] } Solution 1 # 为了找出所有在 \u0026ldquo;第二天\u0026rdquo; 刷了题的用户, 我们可以将 question_practice_detail 表自连接, 连接规则为 device_id 相同且 date 相差一天. 为了统计方便, 我们使用 LEFT JOIN, 这样表中包含了有第二天记录的用户, 也包含了没有第二天记录的用户. 其中 date1 为第一天的日期, date2 为第二天的日期. 为了避免重复计算, 我们使用 DISTINCT 去重. 最后, 我们只需要计算 date2 的个数除以 date1 的个数即可.\nSELECT COUNT(date2) / COUNT(date1) AS avg_ret FROM ( SELECT DISTINCT qpd.device_id, qpd.date AS date1, uniq_id_date.date AS date2 FROM question_practice_detail AS qpd LEFT JOIN ( SELECT DISTINCT device_id, date FROM question_practice_detail ) AS uniq_id_date ON qpd.device_id = uniq_id_date.device_id AND DATE_ADD(qpd.date, INTERVAL 1 DAY) = uniq_id_date.date ) AS id_last_next_date; Solution 2 # 使用 LEAD 函数结合 PARTITION BY 找出每一个用户第二次刷题的数据记为 date2, 然后使用 DATEDIFF 函数计算 date2 与 date1 的差值, 如果差值为 1, 则记为 1, 否则记为 0. 最后求平均值即可.\nSELECT AVG(IF(DATEDIFF(date2, date1) = 1, 1, 0)) AS avg_ret FROM ( SELECT DISTINCT device_id, date AS date1, LEAD(date) OVER (PARTITION BY device_id ORDER BY date) AS date2 FROM ( SELECT DISTINCT device_id, date FROM question_practice_detail ) AS uniq_id_date ) AS id_last_next_date; ","date":"24 July 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/sql/sql-%E8%AE%A1%E7%AE%97%E6%AC%A1%E6%97%A5%E7%95%99%E5%AD%98%E7%8E%87/","section":"Posts","summary":"SQL 计算次日留存率 # 计算留存率是 SQL 的典型题目, 这里以牛客网的题目为例.","title":"SQL 计算次日留存率"},{"content":"","date":null,"permalink":"/tags/%E7%BB%84%E5%90%88/","section":"Tags","summary":"","title":"组合"},{"content":"囚犯与黑白手套 # 题目 # A hundred prisoners are gathered together by their warden. Each prisoner gets two gloves: one black and one white. They are told that they have one night in order to plan a strategy, after which no communication between them will be possible. In the morning, they are told, each prisoner will have a distinct real number painted on his forehead. Each prisoner will be able to see the numbers painted on all other prisoners, but not his own. What each prisoner needs to do is to decide which glove to put on which hand. Once all prisoners have donned all gloves, they will be placed in a long line, one beside the other, ordered according to the value of the number on their foreheads, and will be asked to hold hands. If the pairs of hands holding each other all have same-colored gloves, all 100 prisoners will be set free.\nYour goal is to design a strategy that will maximize the probability of this happening.\n解答 # 100% 获得自由的策略是存在的. 囚犯们可以给自己编上从 1 到 100 的号码. 约定奇数号码的囚犯的默认戴法是左黑右白 (BW), 偶数号码的囚犯的默认戴法是左白右黑 (WB). 在排成一列后, 每个人统计自己看到的编号序列的逆序对个数, 如果是奇数那么就交换左右手的手套. 可以证明, 对于相邻的人, 他们看见的逆序对个数奇偶性相同, 当且仅当他们的编号的奇偶性不同. 考虑 $\u0026hellip;, x, y, \u0026hellip;$ , 为例. 设前面 $a$ 个数中有 $p_1$ 个大于 $x$ 的数, 有 $p_2$ 个大于 $y$ 的数, 后面 $b$ 个数中有 $q_1$ 个小于 $x$ 的数, 有 $p_2$ 个小于 $y$ 的数. 那么 $x$ 看到的逆序对个数是 $p_2 + q_2$ , $y$ 看到的逆序对个数是 $p_1 + q_1$ . 考虑 $100$ 个数中大于 $x$ 的数的个数, 为 $p_1 + b - q_1 + I(x \u0026lt; y)$ , 与 $x$ 的奇偶性相同; 类似, $100$ 个数中大于 $y$ 的数的个数为 $q_1 + b - q_2 + I(y \u0026lt; x)$ , 与 $y$ 的奇偶性相同. 那么 $p_1 + q_1 \\equiv p_1 - q_1\\equiv x - b - I(x \u0026lt; y)$ , $p_2 + q_2 \\equiv p_2 - q_2\\equiv y - b - I(y \u0026lt; x)$ , 有 $(p_1 + q_1) - (p_2 + q_2)\\equiv (x - y) + (I(y \u0026lt; x) - I(x - y))\\equiv (x - y) + (I(y \u0026lt; x) + I(x - y))\\equiv x - y - 1$ . 因此, 对于相邻的人, 他们看见的逆序对个数奇偶性相同, 当且仅当他们的编号的奇偶性不同. 综上, 这样的策略总是能够保证相邻的手套颜色一致.\n","date":"26 February 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%983_%E5%9B%9A%E7%8A%AF%E4%B8%8E%E9%BB%91%E7%99%BD%E6%89%8B%E5%A5%97/","section":"Posts","summary":"囚犯与黑白手套 # 题目 # A hundred prisoners are gathered together by their warden.","title":"趣题: 囚犯与黑白手套"},{"content":"","date":null,"permalink":"/tags/codeforces/","section":"Tags","summary":"","title":"CodeForces"},{"content":"CodeForces-1179B Tolik and His Uncle # 题目大意 # 有一个 $n\\times m$ 的矩阵 (下标从 $1$ 开始). 从 $(x, y)$ 可以使用方向向量 $(dx, dy)$ 到达 $(x + dx, y + dy)$ . 从 $(1, 1)$ 出发, 遍历所有格点, 同时要求方向向量不能重复. 如果存在这样的走法, 输出点的顺序; 否则输出 $-1$ .\nSolution 1 # 从 $1\\times m$ 的情况入手, 可以发现行走路径可以是 $(1, 1)\\rightarrow (1, m)\\rightarrow (1, 2)\\rightarrow (1, m - 1)\\rightarrow \u0026hellip;$ . 推广到 $n\\times m$ , 按照 $(1, 1)\\rightarrow (n, m)\\rightarrow (1, 2)\\rightarrow (n, m - 1)\\rightarrow \u0026hellip;\\rightarrow (1,m)\\rightarrow (n, 1)\\rightarrow (2, m)\\rightarrow\u0026hellip;$ . 对于 $n$ 为奇数的情况, 最后再在 $\\lfloor \\frac{n + 1}{2}\\rfloor$ 行内部重复 $1\\times m$ 的走法即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; if (n \u0026amp; 1) { for (int i = 1; i \u0026lt;= n / 2; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d %d\\n\u0026#34;, i, j); printf(\u0026#34;%d %d\\n\u0026#34;, n + 1 - i, m + 1 - j); } } for (int j = 1; j \u0026lt;= m; j++) { if (j \u0026amp; 1) { printf(\u0026#34;%d %d\\n\u0026#34;, n / 2 + 1, 1 + j / 2); } else { printf(\u0026#34;%d %d\\n\u0026#34;, n / 2 + 1, m + 1 - j / 2); } } } else { for (int i = 1; i \u0026lt;= n / 2; i++) { for (int j = 1; j \u0026lt;= m; j++) { printf(\u0026#34;%d %d\\n\u0026#34;, i, j); printf(\u0026#34;%d %d\\n\u0026#34;, n + 1 - i, m + 1 - j); } } } return 0; } ","date":"24 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1179b-tolik-and-his-uncle/","section":"Posts","summary":"CodeForces-1179B Tolik and His Uncle # 题目大意 # 有一个 $n\\times m$ 的矩阵 (下标从 $1$ 开始).","title":"CodeForces-1179B Tolik and His Uncle"},{"content":"CodeForces-584C Marina and Vasya # 题目大意 # 给定长度均为 $n$ 的字符串 $s_1, s_2$ 和整数 $t$ . 记 $f(a, b)$ 为 $a[i] \\not = b[i]$ 的 $i$ 的个数. 构造 $s_3$ 使得 $f(s1, s3) = f(s2, s3) = t$ . 如果不存在这样的字符串, 返回 $-1$ .\nSolution 1 # 记 $x = n - f(s1, s2)$ 为 $s1, s2$ 相同的字符数. 记 $y = n - t$ . 如果 $x \\geq y$ , 那么 $s3$ 由 $s1, s2$ 相同的一部分与和它们都不相同的一部分构成. 如果 $x \u0026lt; y$ , 那么需要从剩余的 $n - x = f(s1, s2)$ 分拆出两个大小为 $y$ 的部分. 如果做不到这样的分拆, 应当返回 $-1$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, t; string s1, s2; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; t \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; s2; t = n - t; set\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { if (s1[i] == s2[i]) { s.insert(i); } } int x = s.size(); if (2 * (t - x) + x \u0026gt; n) { printf(\u0026#34;-1\\n\u0026#34;); return 0; } string ans = \u0026#34;\u0026#34;; int cnt = t; for (int i = 0; i \u0026lt; n; i++) { if (s.count(i)) { if (cnt \u0026gt; 0) { ans.push_back(s1[i]); cnt--; } else { ans.push_back(\u0026#39;a\u0026#39; + (s1[i] - \u0026#39;a\u0026#39; + 1) % 26); } } else { ans.push_back(\u0026#39;a\u0026#39;); while (ans[i] == s1[i] || ans[i] == s2[i]) { ans[i]++; } } } if (cnt == 0) { cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } cnt = t - s.size(); bool is_one = true; // 是否在拆第一部分 for (int i = 0; i \u0026lt; n; i++) { if (!s.count(i)) { if (cnt \u0026gt; 0) { if (is_one) { ans[i] = s1[i]; cnt--; } else { ans[i] = s2[i]; cnt--; } } if (cnt == 0 \u0026amp;\u0026amp; is_one) { cnt = t - s.size(); is_one = false; } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"23 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-584c-marina-and-vasya/","section":"Posts","summary":"CodeForces-584C Marina and Vasya # 题目大意 # 给定长度均为 $n$ 的字符串 $s_1, s_2$ 和整数 $t$ .","title":"CodeForces-584C Marina and Vasya"},{"content":"CodeForces-1324E Sleeping Schedule # 题目大意 # 给定 $h, l, r$ 和长度为 $n$ 的数组 $a$ . 对于每个 $a_i$ , 你可以用 $a_i - 1$ 替换它. 记 $s$ 为经过操作的 $a$ 的前缀和数组, 如果 $l\\leq (s_i% h)\\leq r$ , 就得到一分. 求总得分的最大值.\nSolution 1 # 用 $dp[i][j]$ 表示 $a_0, \u0026hellip;, a_i$ 中有 $j$ 个数被替换时的最大得分. 动态规划即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, h, l, r; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; h \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; int a[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; if (i \u0026gt; 0) { a[i] += a[i - 1]; } } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n + 1, 0)); dp[0][0] = (l \u0026lt;= a[0] % h) \u0026amp;\u0026amp; (r \u0026gt;= a[0] % h); dp[0][1] = (l \u0026lt;= (a[0] - 1) % h) \u0026amp;\u0026amp; (r \u0026gt;= (a[0] - 1) % h); for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= i + 1; j++) { dp[i][j] = ((l \u0026lt;= (a[i] - j) % h) \u0026amp;\u0026amp; (r \u0026gt;= (a[i] - j) % h)) + (j \u0026gt; 0 ? max(dp[i - 1][j - 1], dp[i - 1][j]) : dp[i - 1][j]); } } int ans = 0; for (int j = 0; j \u0026lt;= n; j++) { ans = max(ans, dp[n - 1][j]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"13 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1324e-sleeping-schedule/","section":"Posts","summary":"CodeForces-1324E Sleeping Schedule # 题目大意 # 给定 $h, l, r$ 和长度为 $n$ 的数组 $a$ .","title":"CodeForces-1324E Sleeping Schedule"},{"content":"","date":null,"permalink":"/tags/c/","section":"Tags","summary":"","title":"C"},{"content":"leptjson note3 # 从零开始的 JSON 库教程 笔记.\nJSON 字符串语法 # JSON 字符串语法与 C 语言相似, 用双引号将字符串括起来 (例如 \u0026quot;Hello\u0026quot;) . 在字符串使用双引号作为间隔时, 怎么表示一个带有双引号的字符串呢? 为了解决这个问题, 我们引入转义字符 (escape character). JSON 的转义字符与 C 语言相同, 为 \\ . JSON 的字符串语法如下:\nstring = quotation-mark *char quotation-mark\rchar = unescaped /\rescape (\r%x22 / ; \u0026#34; quotation mark U+0022\r%x5C / ; \\ reverse solidus U+005C\r%x2F / ; / solidus U+002F\r%x62 / ; b backspace U+0008\r%x66 / ; f form feed U+000C\r%x6E / ; n line feed U+000A\r%x72 / ; r carriage return U+000D\r%x74 / ; t tab U+0009\r%x75 4HEXDIG ) ; uXXXX U+XXXX\rescape = %x5C ; \\\rquotation-mark = %x22 ; \u0026#34;\runescaped = %x20-21 / %x23-5B / %x5D-10FFFF 即 JSON 字符串是由前后两个双引号夹着零至多个字符构成. 字符为无转义字符或转义序列. 转义序列有 9 种, 均以反斜线开始，如常见的 \\n 代表换行符. 比较特殊的是 \\uXXXX, 其中 XXXX 为 16 进位的 UTF-16 编码, 本单元暂时不处理这种转义序列.\n字符串表示 # C 语言中的字符串一般表示为空结尾字符串 (null-terminated string) , 即以空字符 \\0 代表字符串的结束. 然而, JSON 字符串允许含有空字符 (例如 \u0026quot;Hello\\u0000World\u0026quot;, 解析后为 11 个字符) . 因此, 我们分配内存来存储解析后的字符, 并且记录字符的数目 (即字符串长度) . 由于大部分 C 程序假设字符串为空结尾字符串, 我们在解析的结果最后再加上一个 \\0 .\n具体实现时, lept_value 实际上是一种变体类型 (variant type) . 我们通过 type 来决定它现时是哪种类型. 由于一个值不可能同时为数字和字符串, 因此可以使用 C 语言中的 union 来节省内存:\ntypedef struct { union { struct { char* s; size_t len; }s; /* string */ double n; /* number */ }u; lept_type type; }lept_value; 内存管理 # 由于字符串的长度不是固定的, 因此需要动态分配内存. 使用标准库 \u0026lt;stdlib.h\u0026gt; 中的 malloc() , realloc() 和 free() 来管理内存. 当一个值为字符串时, 我们需要把参数中的字符串复制一份:\nvoid lept_set_string(lept_value* v, const char* s, size_t len) { assert(v != NULL \u0026amp;\u0026amp; (s != NULL || len == 0)); // 非空指针 以及 0 长度的字符串都是合法的 lept_free(v); // 先释放内存 v-\u0026gt;u.s.s = (char*)malloc(len + 1); memcpy(v-\u0026gt;u.s.s, s, len); // 复制字符串 v-\u0026gt;u.s.s[len] = \u0026#39;\\0\u0026#39;; // 用 \u0026#39;\\0\u0026#39; 结尾 v-\u0026gt;u.s.len = len; v-\u0026gt;type = LEPT_STRING; } 再看看 lept_free() :\nvoid lept_free(lept_value* v) { assert(v != NULL); if (v-\u0026gt;type == LEPT_STRING) free(v-\u0026gt;u.s.s); v-\u0026gt;type = LEPT_NULL; } 现在仅当值是字符串类型时才处理. 在 lept_free(v) 之后, 会设置类型为 null 以避免重复释放.\n由于会检查 v 的类型, 在调用所有访问函数之前, 必须初始化该类型, 为此加入 lept_free(v) , 用宏实现:\n# define lept_init(v) do { (v)-\u0026gt;type = LEPT_NULL; } while(0) 前两个单元中缺少写入的 API , 在这里补全:\n# define lept_set_null(v) lept_free(v) int lept_get_boolean(const lept_value* v); void lept_set_boolean(lept_value* v, int b); double lept_get_number(const lept_value* v); void lept_set_number(lept_value* v, double n); const char* lept_get_string(const lept_value* v); size_t lept_get_string_length(const lept_value* v); void lept_set_string(lept_value* v, const char* s, size_t len); lept_free(v) 会把类型设置为 null, 因此这里用一个宏来提供 lept_set_null 这个 API.\n缓冲区与堆栈 # 解析字符串 (以及之后的数组、对象) 时, 需要把解析的结果先储存在一个临时的缓冲区, 最后再用 lept_set_string() 把缓冲区的结果存进值中. 在完成解析一个字符串之前, 缓冲区的大小是不能预知的, 因此使用动态数组 (dynamic array) . 缓冲区可以复用, 以先进后出的方式访问, 即是一个动态的堆栈 (stack) 结构. 把一个动态堆栈的数据放进 lept_context 中:\ntypedef struct {\rconst char* json;\rchar* stack;\rsize_t size, top;\r}lept_context; 其中, size 为当前的堆栈容量, top 是栈顶的位置. 在创建 lept_context 的时候初始化 stack 并最终释放内存:\nint lept_parse(lept_value* v, const char* json) { lept_context c; int ret; assert(v != NULL); c.json = json; c.stack = NULL; /* \u0026lt;- */ c.size = c.top = 0; /* \u0026lt;- */ lept_init(v); lept_parse_whitespace(\u0026amp;c); if ((ret = lept_parse_value(\u0026amp;c, v)) == LEPT_PARSE_OK) { /* ... */ } assert(c.top == 0); /* \u0026lt;- */ free(c.stack); /* \u0026lt;- */ return ret; } 在释放时, 加入断言, 确保所有数据都被弹出.\n接下来实现堆栈的压入和弹出操作, 和普通的堆栈不一样, 这个堆栈以字节形式储存, 每次可以压入任意大小的数据, 并返回数据起始的指针:\n# ifndef LEPT_PARSE_STACK_INIT_SIZE # define LEPT_PARSE_STACK_INIT_SIZE 256 # endif static void* lept_context_push(lept_context* c, size_t size) { void* ret; assert(size \u0026gt; 0); if (c-\u0026gt;top + size \u0026gt;= c-\u0026gt;size) { // 空间不足 if (c-\u0026gt;size == 0) // 堆栈容量为 0 , 初始化 c-\u0026gt;size = LEPT_PARSE_STACK_INIT_SIZE; while (c-\u0026gt;top + size \u0026gt;= c-\u0026gt;size) // 扩展为 1.5 倍大小 c-\u0026gt;size += c-\u0026gt;size \u0026gt;\u0026gt; 1; /* c-\u0026gt;size * 1.5 */ c-\u0026gt;stack = (char*)realloc(c-\u0026gt;stack, c-\u0026gt;size); } ret = c-\u0026gt;stack + c-\u0026gt;top; // c-\u0026gt;stack 的类型是 char*, c-\u0026gt;top 的类型是 size_t, 可以相加 // ret 就是数据起始的指针 c-\u0026gt;top += size; return ret; } static void* lept_context_pop(lept_context* c, size_t size) { assert(c-\u0026gt;top \u0026gt;= size); return c-\u0026gt;stack + (c-\u0026gt;top -= size); // 弹出数据 } void* 作为返回值时, 表示返回任意类型的指针.\n解析字符串 # 先备份栈顶, 将解析到的字符压栈, 最后计算出长度并一次性弹出所有字符并设置到值中. 部分实现如下:\n# define PUTC(c, ch) do { *(char*)lept_context_push(c, sizeof(char)) = (ch); } while(0) static int lept_parse_string(lept_context* c, lept_value* v) { size_t head = c-\u0026gt;top, len; const char* p; EXPECT(c, \u0026#39;\\\u0026#34;\u0026#39;); p = c-\u0026gt;json; for (;;) { char ch = *p++; switch (ch) { case \u0026#39;\\\u0026#34;\u0026#39;: len = c-\u0026gt;top - head; lept_set_string(v, (const char*)lept_context_pop(c, len), len); c-\u0026gt;json = p; return LEPT_PARSE_OK; case \u0026#39;\\0\u0026#39;: c-\u0026gt;top = head; return LEPT_PARSE_MISS_QUOTATION_MARK; default: PUTC(c, ch); } } } ","date":"13 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/projects/leptjson/leptjson-note3/","section":"Posts","summary":"leptjson note3 # 从零开始的 JSON 库教程 笔记.","title":"leptjson note3"},{"content":"CodeForces-1286A Garland # 题目大意 # 有一个由 $1, 2, \u0026hellip;, n$ 的排列, 其中一部分元素被删除了 (用 $0$ 表示) . 在所有可能的排列中, 输出奇偶性不同的相邻元素对的最小数量.\nSolution 1 # 用 $dp[i][j][k][l]$ 表示 $p_0, \u0026hellip;, p_i$ , 有 $j$ 个奇数, $k$ 个偶数, 最后一个元素奇偶性为 $l$ 的所有排列中, 不同的相邻元素对的最小数量. 利用动态规划计算. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int a[n]; for (int\u0026amp; v : a) { cin \u0026gt;\u0026gt; v; } int dp[n][(n + 1) / 2 + 1][n / 2 + 1][2]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; (n + 1) / 2 + 1; j++) { for (int k = 0; k \u0026lt; n / 2 + 1; k++) { for (int l = 0; l \u0026lt; 2; l++) { dp[i][j][k][l] = 1e9; } } } } if (a[0] == 0) { dp[0][1][0][1] = 0; dp[0][0][1][0] = 0; } else if (a[0] \u0026amp; 1) { dp[0][1][0][1] = 0; } else { dp[0][0][1][0] = 0; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; (n + 1) / 2 + 1; j++) { for (int k = 0; k \u0026lt; n / 2 + 1; k++) { if (a[i] == 0) { if (j \u0026gt; 0) { dp[i][j][k][1] = min(dp[i][j][k][1], dp[i - 1][j - 1][k][1]); dp[i][j][k][1] = min(dp[i][j][k][1], dp[i - 1][j - 1][k][0] + 1); } if (k \u0026gt; 0) { dp[i][j][k][0] = min(dp[i][j][k][0], dp[i - 1][j][k - 1][1] + 1); dp[i][j][k][0] = min(dp[i][j][k][0], dp[i - 1][j][k - 1][0]); } } else if (a[i] \u0026amp; 1) { if (j \u0026gt; 0) { dp[i][j][k][1] = min(dp[i][j][k][1], dp[i - 1][j - 1][k][1]); dp[i][j][k][1] = min(dp[i][j][k][1], dp[i - 1][j - 1][k][0] + 1); } } else { if (k \u0026gt; 0) { dp[i][j][k][0] = min(dp[i][j][k][0], dp[i - 1][j][k - 1][1] + 1); dp[i][j][k][0] = min(dp[i][j][k][0], dp[i - 1][j][k - 1][0]); } } } } } int ans = 1e9; for (int j = 0; j \u0026lt; (n + 1) / 2 + 1; j++) { for (int l = 0; l \u0026lt; 2; l++) { ans = min(ans, dp[n - 1][j][n - j][l]); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"12 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1286a-garland/","section":"Posts","summary":"CodeForces-1286A Garland # 题目大意 # 有一个由 $1, 2, \u0026hellip;, n$ 的排列, 其中一部分元素被删除了 (用 $0$ 表示) .","title":"CodeForces-1286A Garland"},{"content":"CodeForces-1359D Yet Another Yet Another Task # 题目大意 # 给定长度为 $n$ 的数组 $a$ (其中 $-30\\leq a_i\\leq 30$) . 设 $b$ 是 $a$ 的一个非空连续子数组, 求 $sum(b) - max(b) $ 的最大值.\nSolution 1 # 寻找子段和减去子段最大值的最大值, 当子段最大值固定为 $m$ 时, 问题转化为寻找一个有约束的最大子段和, 这个约束就是元素值不能超过 $m$ . 同样运用贪心算法, 在 $sum \u0026lt; 0$ 的情况之外, 当 $a[i] \u0026gt; m$ 时同样将 $sum$ 重置为 $0$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin \u0026gt;\u0026gt; n; int a[n]; for (int \u0026amp;v: a) { cin \u0026gt;\u0026gt; v; } int ans = 0, sum = 0; for (int i = 1; i \u0026lt;= 30; i++) { sum = 0; for (int v: a) { if (v \u0026gt; i) { sum = 0; } else { sum += v; if (sum \u0026lt; 0) { sum = 0; } else { ans = max(ans, sum - i); } } } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"12 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1359d-yet-another-yet-another-task/","section":"Posts","summary":"CodeForces-1359D Yet Another Yet Another Task # 题目大意 # 给定长度为 $n$ 的数组 $a$ (其中 $-30\\leq a_i\\leq 30$) .","title":"CodeForces-1359D Yet Another Yet Another Task"},{"content":"","date":null,"permalink":"/tags/atcoder/","section":"Tags","summary":"","title":"Atcoder"},{"content":"Atcoder-ARC119C ARC Wrecker 2 # 题目大意 # 给定长度为 $n$ 的数组 $a$ . 对于 $a$ 的子数组 $b$ , 可以进行如下操作:\n选择相邻的两个数, 同时 $+1$ 或 $-1$ 如果经过若干次操作能够使得 $b$ 中元素全部变为 $0$ , 那么称 $b$ 是 $a$ 的一个好子数组. 求 $a$ 的好子数组的数量.\nSolution 1 # 一个数组是好子数组当且仅当它奇数项的和与偶数项的和相等. 如果把 $a$ 的奇数项变为其相反数, 那么问题转化为求 $a$ 和为 $0$ 的子数组个数, 这个问题很常规, 可以使用哈希表解决. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin \u0026gt;\u0026gt; n; ll a[n]; map\u0026lt;ll, ll\u0026gt; book; book[0]++; ll sum = 0, ans = 0; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; if (i \u0026amp; 1) { a[i] = -a[i]; } sum += a[i]; if (book.count(sum)) { ans += book[sum]; } book[sum]++; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return 0; } ","date":"10 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/atcoder/atcoder-arc119c-arc-wrecker-2/","section":"Posts","summary":"Atcoder-ARC119C ARC Wrecker 2 # 题目大意 # 给定长度为 $n$ 的数组 $a$ .","title":"Atcoder-ARC119C ARC Wrecker 2"},{"content":"CodeForces-1695C Zero Path # 题目大意 # 给定一个 $n\\times m$ 的矩阵, 矩阵元素由 $1$ 和 $-1$ 构成. 判断是否存在从 $(0, 0)$ 到 $(n - 1, m - 1)$ 的路径满足路径和为 $0$ .\nSolution 1 # 从 $(0, 0)$ 到 $(n - 1, m - 1)$ 的路径长为 $n + m - 1$ , 只有当 $n + m - 1$ 为偶数时, 路径和才有可能为 $0$ . 把路径中的某两步交换一下, 会使得路径长度 $+2$ , 不变或 $-2$ . 求出从 $(0, 0)$ 到 $(n - 1, m - 1)$ 的最大路径和与最小路径和, 类似介值定理, 此时存在路径和为 $0$ 的路径当且仅当最大路径和 $\\geq 0$ 且最小路径和 $\\leq 0$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a[n][m]; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { cin \u0026gt;\u0026gt; a[i][j]; } } bool ans = false; if ((n + m) \u0026amp; 1) { int max_dp[n][m], min_dp[n][m]; max_dp[0][0] = min_dp[0][0] = a[0][0]; for (int i = 1; i \u0026lt; n; i++) { max_dp[i][0] = min_dp[i][0] = max_dp[i - 1][0] + a[i][0]; } for (int j = 1; j \u0026lt; m; j++) { max_dp[0][j] = min_dp[0][j] = max_dp[0][j - 1] + a[0][j]; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; m; j++) { max_dp[i][j] = max(max_dp[i - 1][j], max_dp[i][j - 1]) + a[i][j]; min_dp[i][j] = min(min_dp[i - 1][j], min_dp[i][j - 1]) + a[i][j]; } } ans = max_dp[n - 1][m - 1] \u0026gt;= 0 \u0026amp;\u0026amp; min_dp[n - 1][m - 1] \u0026lt;= 0; } printf(\u0026#34;%s\\n\u0026#34;, ans ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); } return 0; } ","date":"10 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1695c-zero-path/","section":"Posts","summary":"CodeForces-1695C Zero Path # 题目大意 # 给定一个 $n\\times m$ 的矩阵, 矩阵元素由 $1$ 和 $-1$ 构成.","title":"CodeForces-1695C Zero Path"},{"content":"CodeForces-1442A Extreme Subtraction # 题目大意 # 给定数组 $a$ , 每次可以选择它的一段前缀或后缀, 让这些元素 $-1$ . 询问能否将 $a$ 中元素全部变为 $0$ .\nSolution 1 # 首先, 操作的顺序对结果没有影响, 因此, 可以把操作视作:\n对前缀进行操作 对后缀进行操作 如果只对后缀进行操作就能让数组变为 $0$ , 那么这个数组必须是单调不减的. 假设经过前缀操作后, $a_i$ 变成了 $0$ , 应当有 $a_{i - 1} \\geq a_i$ . 因此, 可以先找到 $a$ 的一个单调不增的最长前缀 $a_0, \u0026hellip; ,a_l$, 显然这个前缀可以变为 $0$ . 类似, 我们可以找到 $a$ 单调不减的最长后缀 $a_r, \u0026hellip;, a_{n - 1}$ . 此时问题转化为: 对 $a_{l + 1}, \u0026hellip;, a_{r-1}$ 进行一系列前缀操作, 即让它们分别减去 $d_{l+1}, \u0026hellip; ,d_{r - 1}$ , 要求 $a_l \\geq d_{l+1} \\geq\u0026hellip;\\geq d_{r - 1}$ , 且 $0 = a_l \\leq a_{l+1} - d_{l+1} \\leq \u0026hellip;\\leq a_{r - 1} - d_{r - 1}\\leq a_r$ . 遍历 $a_{l+1}, \u0026hellip;, a_{r - 1}$ , 逐步寻找可行的 $d$ 即可. 这是一个构造性的解法. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; int a[n]; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } int l; for (l = 0; l \u0026lt; n - 1;) { if (a[l + 1] \u0026lt;= a[l]) { l++; } else { break; } } int r; for (r = n - 1; r \u0026gt; 0;) { if (a[r - 1] \u0026lt;= a[r]) { r--; } else { break; } } if (r - l \u0026lt;= 1) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; continue; } bool ans = true; int d = a[l]; a[l] = 0; for (int i = l + 1; i \u0026lt; r; i++) { d = min(d, min(a[i], a[i] - a[i - 1])); a[i] -= d; if (a[i] \u0026lt; a[i - 1]) { ans = false; break; } } if (a[r - 1] \u0026gt; a[r]) { ans = false; } printf(\u0026#34;%s\\n\u0026#34;, ans? \u0026#34;YES\u0026#34;: \u0026#34;NO\u0026#34;); } return 0; } Solution 2 # 考虑原数组的差分数组. 如果最终数组元素全为 $0$ , 那么差分数组的元素同样全为 $0$ . 考虑两种操作对差分数组 $d$ 的影响:\n对前缀 $a_0, \u0026hellip;, a_i$ 进行操作, 那么 $d_0$ 减 $1$ 且 $d_{i+1}$ 加 $1$ 对后缀 $a_i, \u0026hellip;, a_{n-1}$ 进行操作, 那么 $d_{i}$ 减 $1$ (且 $d_{n}$ 加 $1$ , 不过 $d_{n}$ 与本题无关) 由此, 通过前缀操作可以将 $d$ 中的负数 (首项除外) 变为 $0$ , 通过后缀操作可以将 $d$ 中的正数变为 $0$ . 所以, 当且仅当 $d_0 \\geq \\sum_{v\\in d, v \u0026lt; 0}\\vert v\\vert$ 时, 可以通过操作使得数组元素全部变为 $0$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int n; cin \u0026gt;\u0026gt; n; int a[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int res = 0; for (int i = n - 1; i \u0026gt;= 1; i--) { a[i] -= a[i - 1]; if (a[i] \u0026lt; 0) { res -= a[i]; } } printf(\u0026#34;%s\\n\u0026#34;, a[0] \u0026gt;= res ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); } return 0; } ","date":"10 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1442a-extreme-subtraction/","section":"Posts","summary":"CodeForces-1442A Extreme Subtraction # 题目大意 # 给定数组 $a$ , 每次可以选择它的一段前缀或后缀, 让这些元素 $-1$ .","title":"CodeForces-1442A Extreme Subtraction"},{"content":"CodeForces-1361B Johnny and Grandmaster # 题目大意 # 给定 $p$ 和长度为 $n$ 的数组 $k$ . 把数组 $k$ 划分成两部分 $A,B$, 求 $\\vert \\sum_{v\\in A}p^{v} - \\sum_{v\\in B}p^{v}\\vert$ 的最小值.\nSolution 1 # 由于幂次的特性, 不难想到贪心. 取最大元素的放入一个子数组中, 然后取稍小的元素尽可能将其抵消. 比较 tricky 的部分是用栈 + 拆分实现这个过程. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; ll mypow(ll p, ll k) { ll res = 1; while (k) { if (k \u0026amp; 1) { res = (res * p) % MOD; k--; } k /= 2; p = p * p % MOD; } return res; } int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { ll ans = 0; ll n, p; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; p; vector\u0026lt;ll\u0026gt; a(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } if (p == 1) { cout \u0026lt;\u0026lt; (n \u0026amp; 1) \u0026lt;\u0026lt; endl; continue; } sort(a.begin(), a.end(), greater\u0026lt;ll\u0026gt;()); stack\u0026lt;int\u0026gt; s; s = stack\u0026lt;int\u0026gt;(); int i = 0; for (i = 0; i \u0026lt; n; i++) { if (s.empty()) { s.push(a[i]); } else { if (a[i] \u0026lt; s.top()) { bool isEnd = false; ll cnt = 1; for (int j = 0; j \u0026lt; s.top() - a[i] \u0026amp;\u0026amp; !isEnd; j++) { cnt *= p; if (cnt \u0026gt;= n - i) { isEnd = true; break; } } if (isEnd) { break; } else { s.pop(); while (cnt--) { s.push(a[i]); } } } if (a[i] == s.top()) { s.pop(); } } } while (!s.empty()) { ans = (ans + mypow(p, s.top())) % MOD; s.pop(); } for (int k = i; k \u0026lt; n; k++) { ans = (ans - mypow(p, a[k]) + MOD) % MOD; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"10 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1361b-johnny-and-grandmaster/","section":"Posts","summary":"CodeForces-1361B Johnny and Grandmaster # 题目大意 # 给定 $p$ 和长度为 $n$ 的数组 $k$ .","title":"CodeForces-1361B Johnny and Grandmaster"},{"content":"LeetCode-2561 重排水果 # Solution 1 # 能使果篮相等的充要条件是每个数出现的次数都是偶数. 交换可以直接将最大值与最小值交换, 也可以借助最小值为中间值进行交换. 代码如下:\n#define ll long long typedef pair\u0026lt;int, int\u0026gt; pii; class Solution { public: long long minCost(vector\u0026lt;int\u0026gt;\u0026amp; b1, vector\u0026lt;int\u0026gt;\u0026amp; b2) { ll ans = 0; map\u0026lt;int, int\u0026gt; bk, bk1, bk2; int mc = 1e9 + 10; // min_cost for (int v : b1) { bk[v]++; bk1[v]++; mc = min(mc, v); } for (int v : b2) { bk[v]++; bk2[v]++; mc = min(mc, v); } for (auto\u0026amp; v : bk) { if (v.second \u0026amp; 1) { return -1; } v.second /= 2; } vector\u0026lt;int\u0026gt; a1, a2; for (auto\u0026amp; v : bk1) { if (v.second \u0026gt; bk[v.first]) { for (int i = 0; i \u0026lt; v.second - bk[v.first]; i++) { a1.push_back(v.first); } } } for (auto\u0026amp; v : bk2) { if (v.second \u0026gt; bk[v.first]) { for (int i = 0; i \u0026lt; v.second - bk[v.first]; i++) { a2.push_back(v.first); } } } sort(a1.begin(), a1.end()); sort(a2.begin(), a2.end(), greater\u0026lt;int\u0026gt;()); for (int i = 0; i \u0026lt; a1.size(); i++) { ans += min(min(a1[i], a2[i]), 2 * mc); } return ans; } }; ","date":"9 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2561-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/","section":"Posts","summary":"LeetCode-2561 重排水果 # Solution 1 # 能使果篮相等的充要条件是每个数出现的次数都是偶数.","title":"LeetCode-2561 重排水果"},{"content":"LeetCode-2560 打家劫舍 IV # Solution 1 # 求每次窃取过程中最大金额的最小值, 注意到如果 $k$ 可行, 那么 $k+1$ 同样可行, 并且可以在线性时间内判断一个解是否可行, 因此用二分搜索寻找左边界. 一次窃取过程中最大金额的最小值一定是某个房屋的价值, 可以证明二分搜索的结果一定是某个房屋的价值. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; nums; int k; bool check(int v) { // 贪心, 尽可能选靠左的房屋 int cnt = k; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] \u0026lt;= v) { cnt--; i++; } if (cnt == 0) { return true; } } return false; } int minCapability(vector\u0026lt;int\u0026gt;\u0026amp; _nums, int _k) { nums = _nums; k = _k; int l = 0; int r = 1e9 + 10; while (l \u0026lt; r) { int m = l + (r - l) / 2; if (check(m)) { r = m; } else { l = m + 1; } } return l; } }; ","date":"9 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2560-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iv/","section":"Posts","summary":"LeetCode-2560 打家劫舍 IV # Solution 1 # 求每次窃取过程中最大金额的最小值, 注意到如果 $k$ 可行, 那么 $k+1$ 同样可行, 并且可以在线性时间内判断一个解是否可行, 因此用二分搜索寻找左边界.","title":"LeetCode-2560 打家劫舍 IV"},{"content":"","date":null,"permalink":"/tags/%E4%BA%8C%E5%88%86/","section":"Tags","summary":"","title":"二分"},{"content":"LeetCode-2552 统计上升四元组 # Solution 1 # 对于 $j \u0026lt; k$ , 需要知道的是 $i \u0026lt; j$ 且 $nums[i] \u0026lt; nums[k]$ 的 $i$ 的个数, 以及 $l \u0026gt; k$ 且 $nums[l] \u0026gt; nums[j]$ 的个数. 用二位前缀和 $f[i][j]$ 表示下标 $\\leq i$ 且值 $\\leq j$ 的元素个数. 对称地, 有 $g[i][j]$ . 最终答案即为 $$ \\sum_{j\u0026lt;k,\\ nums[j] \u0026gt; nums[k]}f[j - 1][nums[k] - 1]\\times g[k + 1][nums[j] + 1] $$ 代码如下:\n#define ll long long ll f[4010][4010], g[4010][4010]; class Solution { public: long long countQuadruplets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); ll ans = 0; for (int i = 0; i \u0026lt;= n + 1; i++) { for (int j = 0; j \u0026lt;= n + 1; j++) { f[i][j] = 0; g[i][j] = 0; } } for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { f[i][j] = ((i == 0) ? 0 : f[i - 1][j]) + (nums[i] \u0026lt;= j ? 1 : 0); } } for (int i = n - 1; i \u0026gt;= 0; i--) { for (int j = n; j \u0026gt;= 0; j--) { g[i][j] = ((i == n - 1) ? 0 : g[i + 1][j]) + (nums[i] \u0026gt;= j ? 1 : 0); } } for (int i = 1; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n - 1; j++) { if (nums[i] \u0026gt; nums[j]) { ans += f[i - 1][nums[j] - 1] * g[j + 1][nums[i] + 1]; } } } return ans; } }; ","date":"9 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2552-%E7%BB%9F%E8%AE%A1%E4%B8%8A%E5%8D%87%E5%9B%9B%E5%85%83%E7%BB%84/","section":"Posts","summary":"LeetCode-2552 统计上升四元组 # Solution 1 # 对于 $j \u0026lt; k$ , 需要知道的是 $i \u0026lt; j$ 且 $nums[i] \u0026lt; nums[k]$ 的 $i$ 的个数, 以及 $l \u0026gt; k$ 且 $nums[l] \u0026gt; nums[j]$ 的个数.","title":"LeetCode-2552 统计上升四元组"},{"content":"CodeForces-1141F2 Same Sum Blocks (Hard) # 题目大意 # 给定数组 $a_1, a_2,\u0026hellip;, a_n$, 找出尽可能多的不相交子数组, 要求它们的和相同.\nSolution 1 # 因为 $n\\leq 1500$ , 暴力计算所有子数组的和, 并用哈希表存储相同和的子数组的左右端点. 对于和相同的一系列子数组, 转化成为一个常见的问题: 选取最多的不相交区间. 这个问题可以用贪心解决. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { int n; cin \u0026gt;\u0026gt; n; int a[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } map\u0026lt;int, vector\u0026lt;pii\u0026gt;\u0026gt; book; for (int i = 1; i \u0026lt;= n; i++) { int sum = 0; for (int j = i; j \u0026lt;= n; j++) { sum += a[j]; book[sum].push_back(make_pair(i, j)); } } int res = -1, ans = -1; for (auto\u0026amp; it : book) { sort(it.second.begin(), it.second.end(), [\u0026amp;](pii x, pii y) { return x.second \u0026lt; y.second; }); int cnt = 0; int last_r = -1; for (auto [l, r] : it.second) { if (l \u0026gt; last_r) { cnt++; last_r = r; } } if (cnt \u0026gt; ans) { res = it.first; ans = cnt; } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; int last_r = -1; for (auto [l, r] : book[res]) { if (l \u0026gt; last_r) { cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; last_r = r; } } return 0; } ","date":"9 February 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1141f2-same-sum-blocks-hard/","section":"Posts","summary":"CodeForces-1141F2 Same Sum Blocks (Hard) # 题目大意 # 给定数组 $a_1, a_2,\u0026hellip;, a_n$, 找出尽可能多的不相交子数组, 要求它们的和相同.","title":"CodeForces-1141F2 Same Sum Blocks (Hard)"},{"content":"LeetCode-2543 判断一个点是否可以到达 # Solution 1 # 逆向考虑, 从 $(targetX, targetY)$ 到达 $(1, 1)$ , 每次操作可以从 $(x, y)$ 变成:\n$(x, x + y)$ $(x + y, x)$ $(x / 2, y)$, 如果 $x$ 为偶数 $(x, y / 2)$, 如果 $y$ 为偶数 如果后两种可行, 那么优先使用这两种操作. 因为更小尺度上的操作同样能够完成更大尺度上的操作. 此外, 前两种操作不会影响 $GCD(x, y)$ , 类似辗转相除, 可以依据这一点判定是否可以到达 $(1, 1)$ .\n代码如下:\nclass Solution { public: bool isReachable(int targetX, int targetY) { int res = __gcd(targetX, targetY); return (res \u0026amp; (res - 1)) == 0; } }; ","date":"29 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2543-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE/","section":"Posts","summary":"LeetCode-2543 判断一个点是否可以到达 # Solution 1 # 逆向考虑, 从 $(targetX, targetY)$ 到达 $(1, 1)$ , 每次操作可以从 $(x, y)$ 变成:","title":"LeetCode-2543 判断一个点是否可以到达"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Coin Piles」.\nCoin Piles # Problem # Suppose that you are blind-folded in a room and are told that there are 1000 coins on the floor. 980 of the coins have tails up and the other 20 coins have heads up. Can you separate the coins into two piles so to guarantee both piles have equal number of heads? Assume that you cannot tell a coin\u0026rsquo;s side by touching it, but you are allowed to turn over any number of coins.\nSolution # 把硬币分成 $20$ 枚和 $980$ 枚的两堆, 然后把 $20$ 枚的那一堆翻面即可. 假设 $20$ 枚这一堆的硬币中有 $x$ 枚正面朝上的硬币, 那么反面后有 $20 - x$ 枚正面朝上的硬币, 而 $980$ 枚那一堆硬币中也恰好有 $20 - x$ 枚正面朝上的硬币. 这样两堆硬币中正面朝上的硬币数量就相等了.\n","date":"26 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/coin-piles/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Coin Piles"},{"content":"LeetCode-1825 求出 MK 平均值 # Solution 1 # 用三个 multiset 分别维护容器中最小的 k 个数, 中间 m - 2 * k 个数以及最大的 k 个数. 代码如下:\n#define ll long long class MKAverage { private: queue\u0026lt;int\u0026gt; q; multiset\u0026lt;int\u0026gt; left, mid, right; ll sum; int m; int k; public: MKAverage(int m, int k) { sum = 0; this-\u0026gt;m = m; this-\u0026gt;k = k; } void addElement(int num) { q.push(num); if (q.size() \u0026lt;= m - 2 * k) { sum += num; mid.insert(num); return; } else if (q.size() == m + 1) { int out = q.front(); q.pop(); if (left.count(out)) { left.erase(left.find(out)); } else if (right.count(out)) { right.erase(right.find(out)); } else { sum -= out; mid.erase(mid.find(out)); sum += *right.begin(); mid.insert(*right.begin()); right.erase(right.begin()); } } if (num \u0026lt;= *mid.begin()) { left.insert(num); if (left.size() \u0026gt; k) { right.insert(*mid.rbegin()); sum -= *mid.rbegin(); mid.erase(prev(mid.end())); sum += *left.rbegin(); mid.insert(*left.rbegin()); left.erase(prev(left.end())); } } else if (num \u0026gt;= *mid.rbegin()) { right.insert(num); if (right.size() \u0026gt; k) { left.insert(*mid.begin()); sum -= *mid.begin(); mid.erase(mid.begin()); sum += *right.begin(); mid.insert(*right.begin()); right.erase(right.begin()); } } else { mid.insert(num); sum += num; if (left.size() \u0026lt; k) { left.insert(*mid.begin()); sum -= *mid.begin(); mid.erase(mid.begin()); } else { right.insert(*mid.rbegin()); sum -= *mid.rbegin(); mid.erase(prev(mid.end())); } } } int calculateMKAverage() { if (q.size() \u0026lt; m) { return -1; } return sum / (m - 2 * k); } }; ","date":"18 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1825-%E6%B1%82%E5%87%BA-mk-%E5%B9%B3%E5%9D%87%E5%80%BC/","section":"Posts","summary":"LeetCode-1825 求出 MK 平均值 # Solution 1 # 用三个 multiset 分别维护容器中最小的 k 个数, 中间 m - 2 * k 个数以及最大的 k 个数.","title":"LeetCode-1825 求出 MK 平均值"},{"content":"","date":null,"permalink":"/tags/%E8%AE%BE%E8%AE%A1/","section":"Tags","summary":"","title":"设计"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Quant Salary」.\nQuant Salary # Problem # Eight quants from different banks are getting together for drinks. They are all interested in knowing the average salary of the group. Nevertheless, being cautious and humbleindividuals, everyone prefers not to disclose his or her own salary to the group. Can youcome up with a strategy for the quants to calculate the average salary without knowing other people\u0026rsquo;s salaries?\nSolution # 第一个人随便选一个很大的数, 加上自己的工资传给第二个人, 之后每个人都加上自己的工资传给后一个人, 最后第一个人减去这个数就能得到所有人的总工资, 从而可以计算出平均工资了.\n","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/quant-salary/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Quant Salary"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Light Switches」.\nLight Switches # Problem # There is a light bulb inside a room and four switches outside.All switches are currentlyat off state and only one switch controls the light bulb. You may turn any number of switches on or off any number of times you want. How many times do you need to gointo the room to figure out which switch controls the light bulb?\nSolution # 解决重点在于二进制. 官方给的解答如下: 灯泡有亮灭的状态, 除此之外亮的时间长了会发热, 又有冷热两种状态. 打开开关 1 和 2, 过一段时间后关闭 2 打开 3, 然后立刻进入房间中查看灯泡.\n亮, 热: 开关 1 亮, 冷: 开关 3 灭, 热: 开关 2 灭, 冷: 开关 4 ","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/light-switches/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Light Switches"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Last Ball」.\nLast Ball # Problem # A bag has 20 blue balls and 14 red balls. Each time you randomly take two balls out.(Assume each ball in the bag has equal probability of being taken). You do not put thesetwo balls back. Instead, if both balls have the same color, you add a blue ball to the bag;if they have different colors，you add a red ball to the bag. Assume that you have anunlimited supply of blue and red balls, if you keep on repeating this process, what willbe the color of the last ball left in the bag? What if the bag has 20 blue balls and 13 redballs instead?\nSolution # 可能的变化情况有三种:\nBB→B: $N_B$ 减 $1$, $N_R$ 不变 RR→B: $N_B$ 不变, $N_R$ 减 $2$ BR→R: $N_B$ 减 $1$, $N_R$ 不变 由于每次操作都会在使得球变少的同时保持 $N_R$ 的奇偶性不变, 因此最终留下的球的颜色只取决于初始 $N_R$ 的奇偶性. 在本题中, $N_B = 20, N_R = 14$ 时, 最终剩下的球为蓝色; $N_B = 20, N_R = 13$ 时, 最终剩下的球为红色.\n","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/last-ball/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Last Ball"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Message Delivery」.\nMessage Delivery # Problem # You need to communicate with your colleague in Greenwich via a messenger service.Your documents are sent in a padlock box.Unfortunately the messenger service is not secure, so anything inside an unlocked box will be lost (including any locks you placeinside the box) during the delivery. The high-security padlocks you and your colleague each use have only one key which the person placing the lock owns.How can you securely send a document to your colleague?\nSolution # 分四步进行:\n用自己的锁锁上, 寄给同事 同事用他的锁锁上, 寄回来 解除自己的锁, 寄给同事 解除同事的锁 补充 # 送信问题可以看成 RSA 算法的 demo.\n","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/message-delivery/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Message Delivery"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Door to Offer」.\nDoor to Offer # Problem # You are facing two doors. One leads to your job offer and the other leads to exit. In frontof either door is a guard. One guard always tells lies and the other always tells the truth.You can only ask one guard one yes/no question. Assuming you do want to get the job offer, what question will you ask?\nSolution # 利用嵌套问题来解决. 随便找一个卫兵, 问他: \u0026ldquo;如果我问你这扇门是否通往 Offer, 你会回答 \u0026lsquo;是\u0026rsquo; 吗?\u0026rdquo; 如果回答是 \u0026lsquo;是\u0026rsquo; , 那么这扇门通往 Offer, 否则不通往 Offer.\n","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/door-to-offer/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Door to Offer"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Calendar Cubes」.\nCalendar Cubes # Problem # You just had two dice custom-made. Instead of numbers 1 - 6, you place single-digit numbers on the faces of each dice so that every morning you can arrange the dice in a way as to make the two front faces show the current day of the month. You must use both dice (in other words, days 1 - 9 must be shown as 01 - 09), but you can switch the order of the dice if you want. What numbers do you have to put on the six faces of each of the two dice to achieve that?\nSolution # 考虑 11 和 22 可知, 两个骰子都应该有 1 和 2 . 因为有 01, 02, \u0026hellip;, 09 . 如果只有第一个骰子有 0 , 那么第二个骰子不能够表示出 01, 02, \u0026hellip;, 09 的所有情况, 因此两个骰子都需要有 0 , 并且一个拥有 3, 4, 5, 一个拥有 6, 7, 8. 注意到印有 6 的骰子可以当作印有 9 的骰子使用, 我们可以验证 (0, 1, 2, 3, 4, 5) 和 (0, 1, 2, 6, 7, 8) 的组合能够表示所有的合法日期.\n","date":"17 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/calendar-cubes/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Calendar Cubes"},{"content":"LeetCode-2358 最大价值和与最小价值和的差值 # Solution 1 # 以 $u$ 为根的子树中, 从根节点出发, 不去掉叶子节点的最长路径为 $f[u]$ ; 从根节点出发, 去掉叶子节点的最长路径为 $g[u]$ . 则有: $$\\begin{cases} f[u] = \\underset{v\\in e[u]}{max}(f[v] + price[u])\\ g[u] = \\underset{v\\in e[u]}{max}(g[v] + price[u]) \\end{cases} $$\n用递归函数进行计算. 在考虑 $v$ 更新 $f[u], g[u]$ 之前, 以 $u$ 为根的子树中的最大价值和 $ans=max(ans, f[u] + g[v], f[v] + g[u])$ . 代码如下:\n#define ll long long typedef pair\u0026lt;ll, ll\u0026gt; pll; class Solution { public: long long maxOutput(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, vector\u0026lt;int\u0026gt;\u0026amp; price) { vector\u0026lt;int\u0026gt; e[n]; for (auto \u0026amp;edge : edges) { e[edge[0]].push_back(edge[1]); e[edge[1]].push_back(edge[0]); } long long ans = 0; function\u0026lt;pll(int, int)\u0026gt; dp = [\u0026amp;](int sn, int fa) { long long f = price[sn], g = 0; for (int fn : e[sn]) if (fn != fa) { pll p = dp(fn, sn); long long ff = p.first, gg = p.second; ans = max({ans, f + gg, ff + g}); f = max(f, ff + price[sn]); g = max(g, gg + price[sn]); } return pll(f, g); }; dp(0, -1); return ans; } }; ","date":"17 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2358-%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC%E5%92%8C%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BB%B7%E5%80%BC%E5%92%8C%E7%9A%84%E5%B7%AE%E5%80%BC/","section":"Posts","summary":"LeetCode-2358 最大价值和与最小价值和的差值 # Solution 1 # 以 $u$ 为根的子树中, 从根节点出发, 不去掉叶子节点的最长路径为 $f[u]$ ; 从根节点出发, 去掉叶子节点的最长路径为 $g[u]$ .","title":"LeetCode-2358 最大价值和与最小价值和的差值"},{"content":"","date":null,"permalink":"/tags/%E5%9B%BE%E8%AE%BA/","section":"Tags","summary":"","title":"图论"},{"content":"leptjson note2 # 从零开始的 JSON 库教程 笔记.\n重构 # 使用宏的方式简化重复部分高的函数.\nJSON 数字语法 # JSON number 类型的语法如下:\nnumber = [ \u0026#34;-\u0026#34; ] int [ frac ] [ exp ]\rint = \u0026#34;0\u0026#34; / digit1-9 *digit\rfrac = \u0026#34;.\u0026#34; 1*digit\rexp = (\u0026#34;e\u0026#34; / \u0026#34;E\u0026#34;) [\u0026#34;-\u0026#34; / \u0026#34;+\u0026#34;] 1*digit number 以十进制表示, 由四部分组成:\n负号, 注意这部分里正号是不合法的 整数, 这部分是必需的 小数 指数, 指数部分由大写 E 或小写 e 开始, 之后可有正负号, 之后是一或多个数字 (0-9) 数字表示方式 # 用双精度浮点数存储 JSON 中的数字. 为 lept_value 添加成员:\ntypedef struct { double n; lept_type type; }lept_value; 只有当 type == LEPT_NUMBER 时, n 才表示 JSON 数字的数值. 因此, 获取该值的 API 如下:\ndouble lept_get_number(const lept_value* v) { assert(v != NULL \u0026amp;\u0026amp; v-\u0026gt;type == LEPT_NUMBER); return v-\u0026gt;n; } 用断言来保证调用 API 时类型正确.\n单元测试 # 十进制转换至二进制 # 把十进制表示的字符串转换为二进制的 double . 为了简单起见, 使用标准库的 strtod 来进行转换.\nC 库函数 double strtod(const char *str, char **endptr) 把参数 str 所指向的字符串转换为一个浮点数 (类型为 double 型) . 如果 endptr 不为空, 则指向转换中最后一个字符后的字符的指针会存储在 endptr 引用的位置. 该函数返回转换后的双精度浮点数. 如果没有执行有效的转换, 则返回零 (0.0) . strtod 可转换 JSON 所要求的格式, 但一些 JSON 不容许的格式, strtod 也可转换, 因此需要自行进行格式校验.\n# include \u0026lt;stdlib.h\u0026gt; /* NULL, strtod() */ static int lept_parse_number(lept_context* c, lept_value* v) { char* end; /* \\TODO validate number */ v-\u0026gt;n = strtod(c-\u0026gt;json, \u0026amp;end); if (c-\u0026gt;json == end) // end 指向位置与原指针相同, 转换失败 return LEPT_PARSE_INVALID_VALUE; c-\u0026gt;json = end; // 指向数字后的字符串 v-\u0026gt;type = LEPT_NUMBER; return LEPT_PARSE_OK; } 由于 lept_parse_number() 内部将会校验输入是否正确的值, 因此 lept_parse_value() 可以这样编写:\nstatic int lept_parse_value(lept_context* c, lept_value* v) { switch (*c-\u0026gt;json) { case \u0026#39;t\u0026#39;: return lept_parse_true(c, v); case \u0026#39;f\u0026#39;: return lept_parse_false(c, v); case \u0026#39;n\u0026#39;: return lept_parse_null(c, v); default: return lept_parse_number(c, v); case \u0026#39;\\0\u0026#39;: return LEPT_PARSE_EXPECT_VALUE; } } ","date":"17 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/projects/leptjson/leptjson-note2/","section":"Posts","summary":"leptjson note2 # 从零开始的 JSON 库教程 笔记.","title":"leptjson note2"},{"content":"leptjson note1 # 从零开始的 JSON 库教程 笔记.\nJSON # JSON (JavaScript Object Notation, JavaScript 对象表示法) , 是一种存储和交换文本信息的语法.\n{ \u0026#34;title\u0026#34;: \u0026#34;Design Patterns\u0026#34;, \u0026#34;subtitle\u0026#34;: \u0026#34;Elements of Reusable Object-Oriented Software\u0026#34;, \u0026#34;author\u0026#34;: [ \u0026#34;Erich Gamma\u0026#34;, \u0026#34;Richard Helm\u0026#34;, \u0026#34;Ralph Johnson\u0026#34;, \u0026#34;John Vlissides\u0026#34; ], \u0026#34;year\u0026#34;: 2009, \u0026#34;weight\u0026#34;: 1.8, \u0026#34;hardcover\u0026#34;: true, \u0026#34;publisher\u0026#34;: { \u0026#34;Company\u0026#34;: \u0026#34;Pearson Education\u0026#34;, \u0026#34;Country\u0026#34;: \u0026#34;India\u0026#34; }, \u0026#34;website\u0026#34;: null } 从上面的例子可以看出, JSON 是树状结构.\nJSON 包含 6 种数据类型:\nnull: 表示为 null boolean: 表示为 true 或 false numebr: 一般的浮点数表示方式 string: 表示为 \u0026ldquo;\u0026hellip;\u0026rdquo; array: 表示为 [\u0026hellip;] object: 表示为 {\u0026hellip;} 需要实现的 JSON 库需要完成 3 个需求:\n把 JSON 文本解析为一个树状数据结构 (parse) 提供接口访问该数据结构 (access) 把数据结构转换成 JSON 文本 (stringify) 本单元实现 null 和 boolean 的解析.\n编译环境 # 使用 CMake 进行配置.\n头文件与 API 设置 # Include 防范 # 利用宏加入 Include Guard 避免重复声明:\n# ifndef LEPTJSON_H__ # define LEPTJSON_H__ /* ... */ # endif /* LEPTJSON_H__ */ 宏的名字必须是唯一的, 通常习惯以 _H__ 作为后缀.\n如果项目有多个文件或目录结构, 可以用项目名称_目录_文件名称_H__这种命名方式. 枚举类型 # JSON 中有 6 种数据类型，如果把 true 和 false 当作两个类型, 就是 7 种. 声明枚举类型:\ntypedef enum { LEPT_NULL, LEPT_FALSE, LEPT_TRUE, LEPT_NUMBER, LEPT_STRING, LEPT_ARRAY, LEPT_OBJECT } lept_type; 因为 C 语言没有 C++ 的命名空间 (namespace) 功能, 一般会使用项目的简写作为标识符的前缀. 通常枚举值用全大写 (如 LEPT_NULL) , 而类型及函数则用小写 (如 lept_type) .\n数据结构 # 声明 JSON 的数据结构. 最终需要实现树的数据结构, 本单元只需要存储一个 lept_type.\ntypedef struct { lept_type type; }lept_value; API: 解析 JSON # int lept_parse(lept_value* v, const char* json); 传入的 JSON 文本为 C 字符串, 同时不应当被改动, 因此使用 const char* 类型.\n返回值的枚举类型:\nenum { LEPT_PARSE_OK = 0, LEPT_PARSE_EXPECT_VALUE, LEPT_PARSE_INVALID_VALUE, LEPT_PARSE_ROOT_NOT_SINGULAR }; 获取访问结果的函数:\nlept_type lept_get_type(const lept_value* v); JSON 语法子集 # 此单元的 JSON 语法子集:\nJSON-text = ws value ws\rws = *(%x20 / %x09 / %x0A / %x0D)\rvalue = null / false / true null = \u0026#34;null\u0026#34;\rfalse = \u0026#34;false\u0026#34;\rtrue = \u0026#34;true\u0026#34; 其中, %xhh 表示以 16 进制表示的字符, / 是多选一, * 是零或多个, () 用于分组. 语法解释:\nJSON 文本组成为 空白 + 值 + 空白. 空白由零或多个空格符、制表符、换行符、回车符组成. 值取 null, false 或 true, 它们分别有对应的字面值 (literal) . JSON 解析器需要判断输入是否是一个合法的 JSON, 如果输入的 JSON 不合法, 需要产生相应的错误码. 此单元中, 错误码如下:\n若一个 JSON 只含有空白, 传回 LEPT_PARSE_EXPECT_VALUE . 若一个值之后, 在空白之后还有其他字符, 传回 LEPT_PARSE_ROOT_NOT_SINGULAR . 若值不是那三种字面值, 传回 LEPT_PARSE_INVALID_VALUE . 单元测试 # 宏编写技巧 # 测试文件 test.h 中的宏 EXPECT_EQ_BASE 如下:\n#define EXPECT_EQ_BASE(equality, expect, actual, format) \\ do {\\ test_count++;\\ if (equality)\\ test_pass++;\\ else {\\ fprintf(stderr, \u0026#34;%s:%d: expect: \u0026#34; format \u0026#34; actual: \u0026#34; format \u0026#34;\\n\u0026#34;, __FILE__, __LINE__, expect, actual);\\ main_ret = 1;\\ }\\ } while(0) 反斜线 \\ 代表该行未结束, 会串接下一行. 宏里如果有多个语句, 需要用 do { /*...*/ } while(0) 包裹成单个语句. 否则会有如下问题:\n# define M() a(); b() if (cond) M(); else c(); /* 预处理后 */ if (cond) a(); b(); /* b(); 在 if 之外 */ else /* \u0026lt;- else 缺乏对应 if */ c(); 如果只用 { } 也不行:\n# define M() {a(); b();} /* 预处理后 */ if (cond) { a(); b(); }; /* 最后的分号代表 if 语句结束 */ else /* else 缺乏对应 if */ c(); 使用 do { /*...*/ } while(0) 才正确:\n# define M() do { a(); b(); } while(0) /* 预处理后 */ if (cond) do { a(); b(); } while(0); else c(); 实现解析器 # 用 lept_context 存储参数:\ntypedef struct { const char* json; }lept_context; /* ... */ int lept_parse(lept_value* v, const char* json) { lept_context c; int ret; assert(v != NULL); c.json = json; v-\u0026gt;type = LEPT_NULL; lept_parse_whitespace(\u0026amp;c); // 跳过第一段空白 if ((ret = lept_parse_value(\u0026amp;c, v)) == LEPT_PARSE_OK) { // 解析出 null lept_parse_whitespace(\u0026amp;c); // 跳过第二段空白 if (*c.json != \u0026#39;\\0\u0026#39;) // 空白之后还有其它字符, 返回状态为 LEPT_PARSE_ROOT_NOT_SINGULAR ret = LEPT_PARSE_ROOT_NOT_SINGULAR; } return ret; } 这里我们实现的 JSON 解释器需要完整鉴别 JSON 文本是否符合规范.\n解析函数: 由于 JSON 的语法很简单, 在跳过空白后, 只需要读取第一个字符就可以知道值的类型, 然后调用相关的分析函数.\n// 如果首字符等于给定值, 指针指向后一个字符 #define EXPECT(c, ch) do { assert(*c-\u0026gt;json == (ch)); c-\u0026gt;json++; } while(0) typedef struct { const char* json; }lept_context; /* ws = *(%x20 / %x09 / %x0A / %x0D) */ // lept_parse_whitespace 跳过 json 开头的空格 static void lept_parse_whitespace(lept_context* c) { const char *p = c-\u0026gt;json; while (*p == \u0026#39; \u0026#39; || *p == \u0026#39;\\t\u0026#39; || *p == \u0026#39;\\n\u0026#39; || *p == \u0026#39;\\r\u0026#39;) p++; c-\u0026gt;json = p; } static int lept_parse_null(lept_context* c, lept_value* v) { EXPECT(c, \u0026#39;n\u0026#39;); if (c-\u0026gt;json[0] != \u0026#39;u\u0026#39; || c-\u0026gt;json[1] != \u0026#39;l\u0026#39; || c-\u0026gt;json[2] != \u0026#39;l\u0026#39;) return LEPT_PARSE_INVALID_VALUE; c-\u0026gt;json += 3; v-\u0026gt;type = LEPT_NULL; return LEPT_PARSE_OK; } static int lept_parse_true(lept_context* c, lept_value* v) { EXPECT(c, \u0026#39;t\u0026#39;); if (c-\u0026gt;json[0] != \u0026#39;r\u0026#39; || c-\u0026gt;json[1] != \u0026#39;u\u0026#39; || c-\u0026gt;json[2] != \u0026#39;e\u0026#39;) { return LEPT_PARSE_INVALID_VALUE; } c-\u0026gt;json += 3; v-\u0026gt;type = LEPT_TRUE; return LEPT_PARSE_OK; } static int lept_parse_false(lept_context* c, lept_value* v) { EXPECT(c, \u0026#39;f\u0026#39;); if (c-\u0026gt;json[0] != \u0026#39;a\u0026#39; || c-\u0026gt;json[1] != \u0026#39;l\u0026#39; || c-\u0026gt;json[2] != \u0026#39;s\u0026#39; || c-\u0026gt;json[3] != \u0026#39;e\u0026#39;) { return LEPT_PARSE_INVALID_VALUE; } c-\u0026gt;json += 4; v-\u0026gt;type = LEPT_FALSE; return LEPT_PARSE_OK; } static int lept_parse_value(lept_context* c, lept_value* v) { switch (*c-\u0026gt;json) { case \u0026#39;n\u0026#39;: return lept_parse_null(c, v); case \u0026#39;t\u0026#39;: return lept_parse_true(c, v); case \u0026#39;f\u0026#39;: return lept_parse_false(c, v); case \u0026#39;\\0\u0026#39;: return LEPT_PARSE_EXPECT_VALUE; // 空字符串 default: return LEPT_PARSE_INVALID_VALUE; // 此单元中, 不合语法 } } 关于断言 # 断言 (assertion) 是 C 语言中常用的防御式编程方式, 用以减少编程错误. 最常用的是在函数开始的地方检测所有参数. 有时候也可以在调用函数后, 检查上下文是否正确. assert(cond) 运行时鉴定条件是否为真, 断言失败会令程序直接崩溃.\n如果某个错误是由于程序员错误编码所造成的 (例如传入不合法的参数) , 那么应用断言; 如果某个错误是由运行时的环境所造成的, 程序员无法避免, 就要处理运行时错误 (例如开启文件失败) . ","date":"16 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/projects/leptjson/leptjson-note1/","section":"Posts","summary":"leptjson note1 # 从零开始的 JSON 库教程 笔记.","title":"leptjson note1"},{"content":"LeetCode-1819 序列中不同最大公约数的数目 # Solution 1 # 对于 $x$ , 如果它是某个子序列 $(a_0, a_1, \u0026hellip;, a_k)$ 的最大公约数, 那么它也一定是 $(a_0, a_1, \u0026hellip;, a_k, a_{k + 1} = x * y)$ 的最大公约数. 因此, 要验证 $x$ 是否为原数组的某个子序列的最大公约数, 验证数组中 $x$ 的倍数的最大公约数是否等于 $x$ 即可. 代码如下:\nclass Solution { public: int countDifferentSubsequenceGCDs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { bool s[200010] = {false}; for (int num: nums) { s[num] = true; } int ans = 0; for (int i = 1; i \u0026lt;= 2e5; i++) { int res = -1; for (int j = 1; j \u0026lt; (2e5 + 10) / i; j++) { if (s[i * j]) { res = res == -1? j: __gcd(res, j); } if (res == 1) { ans++; break; } } } return ans; } }; ","date":"14 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1819-%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-1819 序列中不同最大公约数的数目 # Solution 1 # 对于 $x$ , 如果它是某个子序列 $(a_0, a_1, \u0026hellip;, a_k)$ 的最大公约数, 那么它也一定是 $(a_0, a_1, \u0026hellip;, a_k, a_{k + 1} = x * y)$ 的最大公约数.","title":"LeetCode-1819 序列中不同最大公约数的数目"},{"content":"CodeForces-1718A2 Burenka and Traditions (hard version) # 题目大意 # 给定长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n (0\\leq a_i\u0026lt;2^{30})$ . 每次操作可以将 $a_l, \u0026hellip;, a_r$ 全部异或某个数, 代价为 $\\lfloor \\frac{r - l + 1}{2}\\rfloor$ . 求使得 $a$ 元素全变为 $0$ 的最小代价.\nSolution 1 # 操作的代价与区间长度有关, 当区间长度为 $2k$ 时, 代价为 $k$ , 同样的代价可以对 $k$ 个长度为 $2$ 的区间分别进行操作; 当区间长度为 $2k + 1$ 时, 代价为 $k + 1$ , 同样的代价可以操作 $1$ 个长度为 $1$ 的区间和 $k$ 个长度为 $2$ 的区间. 因此, 最优的操作应当由代价为 $1$ 的操作构成. 如果对全部元素进行单元素操作, 那么总代价为 $n$ . 我们需要寻找的就是可以合并操作的元素. 对于一个异或和为 $0$ 的子区间, 可以用区间长度 $-1$ 的代价把区间变为 $0$ . 因此, 统计原数组中最多有多少个不相交的子区间异或和为 $0$ 即可, 最终答案即为 $n-$ 减去这个数. 可以利用前缀和以及哈希表完成统计. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin \u0026gt;\u0026gt; t; while (t--) { int n; cin \u0026gt;\u0026gt; n; int a[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int ans = n; set\u0026lt;int\u0026gt; s; int xs = 0; for (int v : a) { xs = xs ^ v; if (s.count(xs) || xs == 0) { // 前缀和之差的区间 或 前缀和区间 ans--; s.clear(); // 为了统计不相交的区间个数, 把哈希表重置 xs = 0; // 前缀和重置 } s.insert(xs); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return 0; } ","date":"8 January 2023","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1718a2-burenka-and-traditions-hard-version/","section":"Posts","summary":"CodeForces-1718A2 Burenka and Traditions (hard version) # 题目大意 # 给定长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n (0\\leq a_i\u0026lt;2^{30})$ .","title":"CodeForces-1718A2 Burenka and Traditions (hard version)"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Box Packing」.\nBox Packing # Problem # Can you pack 53 bricks of dimensions 1×1×4 into a 6×6×6 box?\nSolution # 这里我们讨论的摆放方式只包括竖直、平放 (占据完整 $1\\times 1\\times 1$ 方块) 的方式. 放入 $52$ 个砖块的解法不难想到, 再进一步却很难. 事实上, 不可能在 $6\\times 6\\times 6$ 的盒子内放进 $53$ 块 $1\\times 1\\times 4$ 的砖块.\n在给出证明之前, 先介绍一个二维版本的经典问题:\n去掉左上角和右下角的国际象棋棋盘, 能否不重叠地摆放 $31$ 个 $1\\times 2$ 的多米诺骨牌? 这个问题是染色法的代表题目. 把棋盘染成黑白交错的颜色, 那么去掉的左上角和右下角的格子是同色的. 一个骨牌会恰好占据一个黑色方块和一个白色方块, 然而这个残缺的棋盘中黑白格子数量不对等, 因此不能够摆放 $31$ 个骨牌. 同样的, 我们可以把 $6\\times 6\\times 6$ 的盒子切割成 $27$ 块 $2\\times 2\\times 2$ 的中等块, 并把它们间隔染成黑白色. 此时黑白色的中等块数量也是不对等的. 注意到一个 $1\\times 1\\times 4$ 的砖块必定会占用 $2$ 单位体积的黑色块与白色块, 因此想要放入 $53$ 块砖块至少分别需要 $53\\times 2=106$ 体积的白色块与黑色块, 然而其中必有一种颜色体积至多为 $13 \\times 2 \\times 2 \\times 2 = 104 \u0026lt; 106$ . 根据这一点可以断定, 不存在放入 $53$ 块砖块的方法.\n","date":"4 January 2023","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/box-packing/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Box Packing"},{"content":"我的二〇二二碎片 # 过去的一年对我而言是支离破碎的, 就让我用碎片来回忆2022吧.\n大学: 我以为那是雪花\n# 漫画: 再见絵梨 # 这篇漫画中完美地诠释了藤本树心中的电影. 作为一个电影狂, 藤本树用电影化的镜头, 紧扣 \u0026ldquo;拍电影\u0026rdquo; , 构筑了影像与现实交错的世界. 其叙事结构之精巧, 让我看到最后一页时才想到: 我是剧中人吗? 动画: 再见！绝望先生 # (我的2022充满了 \u0026ldquo;再见\u0026rdquo;) 久米田康治原作, SHAFT改编为动画, 监督则是新房昭之. 在我看来, 新房与久米田风格之契合, 不输于与西尾维新. 这部动画充满了对当时日本的社会现象的嘲讽 (以及不少自嘲) . 看似无厘头而伏笔重重的剧情设计, 清新脱俗的笑点安排, 以及对社会、人性的深入思考, 让稍显复古的《再见！绝望先生》在今日仍不过时. 值得一提的是, 久米田康治在故事的开头就画好了结局, 这种随时下车不烂尾的职业精神值得所有漫画家学习. 游戏: 十三机兵防卫圈 # 虽然是游戏, 但我其实并没有玩过, 只是看完了它的全剧情流程. 于我而言, 《十三机兵防卫圈》的美主要来源于叙事. 作为科幻作品, 它的许多点子其实不算新颖, 但数量繁多而交错的叙事线路, 让故事变得惊心动魄, 一次又一次的反转让人直呼过瘾. \u0026ldquo;抽丝剥茧\u0026rdquo; 就是这款神作最大的乐趣. 音乐: 踊り子 # 因为《电锯人》第一部动画的开播了解到了 Vaundy, 因为漫画《电锯人》第二部漫画开始连载了解到了小松菜奈, 没想到两人在《踊り子》这首歌中早有合作. 《踊り子》的 MV 中旋律和画面的结合相当出彩. 无人的深夜, 开车兜风思考人生, 大概就是这种感觉. 世界杯: 阿根廷夺冠 # 阿根廷一路上的许多比赛, 我都坚持看下来了, 惟独决赛加时赛下半场开始, 我失去了继续观看的勇气 (缺乏勇气的人自然不配享受胜利那一刻的极致喜悦). 当听到阿根廷夺冠的那一刻, 我的内心突然平静. 我知道, 格策的绝杀再也不会伤害到我了. 有人说阿根廷的胜利是属于天才的胜利, 但在我看来恰恰相反, 是凡人撑起了这支伤痕累累的球队, 无论是球场上拼命逼抢的队员, 还是球场下永不放弃的球迷们. 直接引用贺炜在决赛后的解说词吧:\n四年一度的世界杯，就像年轮一样，一圈一圈地篆刻着历史的脚步，享受着巨星的叱咤风云或者黯然神伤，也讲述着我们自己生命的推演。要知道梅西这一代的运动员，在上一次阿根廷队夺冠的时候，他们都还没有出生，但他们给阿根廷这个国家带来的关于世界杯的美好记忆，却是传承了下来。 电视机前的观众朋友们，问问我们自己，4年前陪你看球的人现在还在联系吗？4年后看球的自己许过的愿望都实现了吗？我们为什么深爱着足球这一项运动？因为他不仅展现了球员们励志的奋斗故事，还寄托了我们普通人平凡生活中的英雄梦想。我们恭喜阿根廷，我们也向法国队送上祝福，不论今晚你支持的球队是胜是负，都希望今天晚上的感悟，能够帮助你勇敢面对明天早上推开门之后真实的生活。这才是这项运动真正的魅力，我爱足球，我想你们也是。 波斯湾的故事讲完了，4年之后让我们相约在落基山尼亚加拉瀑布尤卡坦半岛，让我们一起去玛雅文明曾经存在过的地方。观众朋友们，4年之后让我们在美加莫世界杯再见！\n总结 # 2022 似乎充满了 \u0026ldquo;再见\u0026rdquo; . 人们在城市中迎来黎明, 又在浑浑噩噩中送别了夕阳. 有些话不太适合放在年终总结里, 我只希望这过去十年里最坏的一年, 不会是接下来十年最好的一年.\n","date":"1 January 2023","permalink":"/posts/%E9%9A%8F%E7%AC%94/%E6%88%91%E7%9A%84%E4%BA%8C%E4%BA%8C%E4%BA%8C%E7%A2%8E%E7%89%87/","section":"Posts","summary":"我的二〇二二碎片 # 过去的一年对我而言是支离破碎的, 就让我用碎片来回忆2022吧.","title":"我的二〇二二碎片"},{"content":"","date":null,"permalink":"/tags/%E9%9A%8F%E7%AC%94/","section":"Tags","summary":"","title":"随笔"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Infinite Sequence」.\nInfinite Sequence # Problem # If x ^ x ^ x ^ x ^ x \u0026hellip; = 2 , what is x?\nSolution # 记 $y = x^{x^{\\dots}}$ , 则 $y = x^y$ , 故 $x^2=2$ , 因此 $x = \\sqrt 2$ (排除 $-\\sqrt 2$).\nMore about the sequence # $x^{x^{\\dots}} = y$ has an solution only when $y\\in [\\frac{1}{e},e]$ , which also means that $x^{x^{\\dots}}$ is convergent only for $x\\in [e^{-e}, e^{\\frac{1}{e}}]$ .\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/infinite-sequence/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Infinite Sequence"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Horse Race」.\nHorse Race # Problem # There are 25 horses, cach of which runs at a constant speed that is different from the other horses\u0026rsquo;. Since the track only has 5 lanes, each race can have at most 5 horses. If you need to find the 3 fastest horses, what is the minimum number of races needed to identify them?\nSolution # 首先, 每 $5$ 匹马分成一组, 进行比赛. 将五个组的小组第一 (不妨设为 $1,6,11,16,21$) 再进行一次比赛 (设结果是 $1\u0026gt;6\u0026gt;11\u0026gt;16\u0026gt;21$), 排第四、第五的马所在小组不可能有马在前三; 排第三的马所在的小组只有它自身 ($11$) 可能进前三; 排第二的马所在的小组的第一第二 ($6, 7$) 都可能进前三; 排第一的马是所有马的第一名, 同时它所在的小组第二第三 ($2, 3$) 可能进前三. 让 $2, 3, 6,7,11$ 再进行一次比赛可以知道所有马的第二第三. 综上, 想要找到最快的三匹马, 需要 $5+1+1=7$ 轮比赛.\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/horse-race/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Horse Race"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Trailing Zeros 」.\nTrailing Zeros # Problem # How many trailing zeros are there in 100! (factorial of 100)?\nSolution # 末尾 $0$ 的个数取决于因子 $2$ 的指数和因子 $5$ 的指数的最小值, 在 $100!$ 中 $5$ 的指数显然更小, 为 $\\sum_{k =0}^{+\\infty}\\lfloor \\frac{100!}{5^k}\\rfloor = 24$ . 因此 $100!$ 末尾 $0$ 的个数为 $24$ .\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/trailing-zeros/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Trailing Zeros"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Defective Ball」.\nDefective Ball # Problem # You have 12 identical balls. One of the balls is heavier OR lighter than the rest (you don\u0026rsquo;t know which). Using just a balance that can only show you which side of the tray is heavier, how can you determine which ball is the defective one with 3 measurements?\nSolution # 经典的称硬币问题, 事实上, 加强问题 (有可能不存在假币) 也是可以解决的. 我们来讨论这个加强问题. 需要用 $3$ 次称量找出有瑕疵的球, 应该考虑决策树的深度的最小值. 因此每次将称量后的可能状态尽可能均分. 用 $i+$ 代表第 $i$ 个球有瑕疵并且更重的情况, 用 $i-$ 代表第 $i$ 个球有瑕疵并且更轻的情况, 最后还有所有球都没有瑕疵的情况, 记作 A .\n第一次称量, 选取 $(1, 2, 3, 4)$ 与 $(5, 6, 7, 8)$ , 可能的结果集合是:\n左侧重: ${1+, 2+, 3+, 4+, 5-, 6-, 7-, 8-}$ 右侧重: ${1-, 2-, 3-, 4-, 5+, 6+, 7+, 8+}$ 一样重: ${9+, 9-, 10+, 10-, 11+, 11-, 12+, 12-, A}$ 一结果为左的后续称量 # 如果第一次称量结果为左侧重, 那么第二次称量, 选取 $(1, 2, 6)$ 和 $(3, 4, 5)$ , 可能的结果集合是:\n左侧重: ${1+, 2+, 5-}$ 右侧重: ${3+, 4+, 6-}$ 一样重: ${7-, 8-}$ 以 ${1+, 2+, 5-}$ 为例, 将 $(1)$ 和 $(2)$ 对比, 如果左侧重, 说明 ${1+}$ ; 如果右侧重, 说明 ${2+}$ ; 如果一样重, 说明 ${5-}$ . 其它两种情况类似.\n一结果为右的后续称量 # 一结果为左的对称情况, 同上\n一结果为平衡的后续称量 # 如果第一次称量结果为平衡, 那么第二次称量, 选取 $(9, 10, 11)$ 与 $(1, 2, 3)$ , 注意这种情况下 $(1, 2, 3)$ 都是没有瑕疵的球. 可能的结果集合:\n左侧重: ${9+, 10+, 11+}$ 右侧重: ${9-, 10-, 11-}$ 一样重: ${12+, 12-, A}$ 以 ${9+, 10+, 11+}$ 为例, 将 $(9)$ 和 $(10)$ 对比, 如果左侧重, 说明 ${9+}$ ; 如果右侧重, 说明 ${10+}$ ; 如果一样重, 说明 ${11+}$ . 其它两种情况类似.\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/defective-ball/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Defective Ball"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Burning Ropes」.\nBurning Ropes # Problem # You have two ropes, each of which takes I hour to burn. But either rope has different densities at different points, so there\u0026rsquo;s no guarantee of consistency in the time it takes different sections within the rope to burn. How do you use these two ropes to measure 45 minutes?\nSolution # 同时点燃第一根绳子的两端与第二根绳子的一段, 在第一根绳子燃尽时, 点燃第二根绳子的另一端. 这样第二根绳子燃尽时刚好过去 $45$ 分钟.\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/burning-ropes/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Burning Ropes"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Card Game」.\nCard Game # Problem # A casino offers a card game using a norrnal deck of 52 cards. The rule is that you turn over two cards each time. For each pair, if both are black, they go to the dealer\u0026rsquo;s pile; if both are red, they go to your pile; if one black and one red, they are discarded. The process is repeated until you two go through all 52 cards. If you have more cards in your pile, you win $100; otherwise (including ties) you get nothing. The casino allows you to negotiate the price you want to pay for the game. How much would you be willing to pay to play this game?\nSolution # 由于对称性, 无论过程如何, 最终两堆的卡牌数一定相同 (平局, get nothing). 因此不应该支付任何代价来玩这个游戏.\n","date":"30 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/card-game/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Card Game"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Birthday Problem」.\nBirthday Problem # Problem # You and your colleagues know that your boss A\u0026rsquo;s birthday is one of the following 10 dates:\nMar 4, Mar 5, Mar 8 Jun 4, Jun 7 Sep 1, Sep 5 Dec 1, Dec 2, Dec 8 A told you only the month of his birthday, and told your colleague C only the day. After that, you first said: \u0026ldquo;I don\u0026rsquo;t know A\u0026rsquo;s birthday; C doesn\u0026rsquo;t know it either.\u0026rdquo; After hearing what you said, C replied: \u0026ldquo;I didn\u0026rsquo;t know A\u0026rsquo;s birthday, but now I know it.\u0026rdquo; You smiled and said: \u0026ldquo;Now I know it, too.\u0026rdquo; After looking at the 10 dates and hearing your comments, your administrative assistant wrote down A\u0026rsquo;s birthday without asking any questions. So what did the assistant write?\nSolution # 不妨列一个表格:\n1 2 4 5 7 8 Mar 0 0 1 1 0 1 Jun 0 0 1 0 1 0 Sep 1 0 0 1 0 0 Dec 1 1 0 0 0 1 把整个过程分成三个阶段. 记原文中 \u0026ldquo;You\u0026rdquo; 为 B.\nB 自己仅凭月份不能确定生日(这句话在本题中没有信息量) , 但 B 断定 C 同样不能确定, 这直接排除了 Jun (Jun 7) 和 Dec (Dec 2) . 在排除 Jun 和 Dec 后, C 确定了生日, 因此排除了 Mar 5 和 Sep 5 . 得到这个信息后, B 确定了生日, 说明 B 知道的月份是 Sep . 最终助手写下的生日是 Sep 1.\n","date":"29 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/birthday-problem/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Birthday Problem"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「River Crossing」.\nRiver Crossing # Problem # Four people, A, B, C and D need to get across a river. The only way to cross the river is by an old bridge, which holds at most 2 people at a time. Being dark, they can\u0026rsquo;t cross the bridge without a torch, of which they only have one. So each pair can only walk at the speed of the slower person. They need to get all of them across to the other side as quickly as possible. A is the slowest and takes 10 minutes to cross; B takes 5 minutes; C takes 2 minutes; and D takes I minute. What is the minimum time to get all of them across to the other side?\nSolution # 解决问题的关键在于让 A 和 B 两个人一起过桥, 并且留在对岸. 因此需要先让 C, D 中的一个人过去, 在 A 和 B 过河后再把手电筒带回来. 最优规划之一如下:\nC, D 过桥 D 回来 A, B 过桥 C 回来 C, D 过桥 总共耗时 $17$ 分钟. 把 C 和 D 的位置对换也是最优解.\n","date":"29 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/river-crossing/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"River Crossing"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Tiger and Sheep」.\nTiger and Sheep # Problem # One hundred tigers and one sheep are put on a magic island that only has grass. Tigers can eat grass, but they would rather eat sheep. Assume:\nA. Each time only one tiger caneat one sheep， and that tiger itself will become a sheep after it eats the sheep. B. All tigers are smart and perfectly rational and they want to survive. So will the sheep be eaten?\nSolution # 如果 $k$ 只老虎的情况, 羊会被吃, 那么 $k + 1$ 只老虎的情况下羊不会被吃; 如果 $k$ 只老虎的情况, 羊不会被吃, 那么 $k + 1$ 只老虎的情况下羊会被吃; 因此 $100$ 只老虎的情况与 $1$ 只老虎的情况相反. 显然后一种情况下羊会被吃, 因此 $100$ 只老虎的情况下羊不会被吃.\n","date":"29 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/tiger-and-sheep/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Tiger and Sheep"},{"content":"","date":null,"permalink":"/tags/%E5%8D%9A%E5%BC%88/","section":"Tags","summary":"","title":"博弈"},{"content":" A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目. 本文介绍的是来自第二章的「Screwy Pirates」.\nScrewy pirates # Problem # Five pirates looted a chest full of 100 gold coins. Being a bunch of democratic pirates, they agree on the following method to divide the loot: The most senior pirate will propose a distribution of the coins. All pirates, including the most senior pirate, will then vote. If at least 50% of the pirates (3 pirates in this case) accept the proposal, the gold is divided as proposed. If not, the most senior pirate will be fed to shark and the process starts over with the next most senior pirate. The process is repeated until a plan is approved. You can assume that all pirates are perfectly rational: they want to stay alive first and to get as much gold as possible second. Finally, being blood-thirsty pirates, they want to have fewer pirates on the boat if given a choice between otherwise equal outcomes. How will the gold coins be divided in the end?\nSolution # 假设序号大的海盗级别更高. 考虑 $2$ 个人的情况, 因为只需要一票, 可以按照 $(0, 100)$ 进行分配; 考虑 $3$ 个人的情况, 按照 $(0, 0, 100)$ 分配只能得到一票, 如果按照 $(1, 0, 99)$ 分配则可以得到 $1$ 号海盗的一票. 这是因为如果 $1$ 号海盗不接受这个提案, 问题回归到 $2$ 个人的情况, 他将什么也得不到; 考虑 $4$ 个人的情况, 为了凑齐两票, 按照 $(0, 1, 0, 98)$ 分配, 与 $3$ 个人的情况相比, $2$ 号海盗会接受这个提案; 回到原问题, $5$ 号海盗给出 $(1, 0, 1, 0, 98)$ 的提案即可. 用归纳法不难证明, 在 $n$ 不超过 99 的情况下, 最优的分配是 $1 , 3, \u0026hellip;, 2n-1$ 号海盗各分到一枚金币, $n$ 号海盗分到剩余的金币.\n","date":"29 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/quant/screwy-pirates/","section":"Posts","summary":"A Practical Guide To Quantitative Finance Interviews 收录了一些量化面试中的经典题目.","title":"Screwy Pirates"},{"content":"Atcoder-ABC275F Erase Subarrays # 题目大意 # 给定 $n, m$ 和长度为 $n$ 的整数数组 $a$ . 每次操作中, 你可以删除数组 $a$ 中的一个非空连续子数组. 对于 $x = 1, 2, \\dots ,m$ , 输出使得剩余数组元素之和为 $x$ 的最少操作次数. 如果无法使 $a$ 的剩余数组元素之和等于 $x$ , 则输出 $-1$ .\nSolution 1 # 定义 $dp[i][j][k]$ 为数组 $a_0, a_1, \u0026hellip;, a_i$ 中删除连续非空子数组使得剩余元素和为 $j$ , 且是否删除了 $a_i$ 的最少操作次数, 其中 $k = 0$ 代表保留 $a_i$ , $k = 1$ 代表删除 $a_i$ . 有: $$ \\begin{cases} dp[i][j][0] = min(dp[0][j - a_i][1], dp[0][j - a_i][0]);\\ dp[1][j][1] = min(dp[0][j][1], dp[0][j][0] + 1);\\end{cases} $$ 对于 $x$ , 答案是 $min(dp[n - 1][x][0], dp[n - 1][x][1])$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a[n]; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; } int dp[2][3001][2]; for (int j = 0; j \u0026lt;= m; j++) { for (int k = 0; k \u0026lt;= 1; k++) { dp[0][j][k] = 1e9; } } dp[0][a[0]][0] = 0; dp[0][0][1] = 1; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt;= m; j++) { dp[1][j][0] = j \u0026gt;= a[i] ? min(dp[0][j - a[i]][1], dp[0][j - a[i]][0]) : 1e9; dp[1][j][1] = min(dp[0][j][1], dp[0][j][0] + 1); } for (int j = 0; j \u0026lt;= m; j++) { dp[0][j][0] = dp[1][j][0]; dp[0][j][1] = dp[1][j][1]; } } for (int j = 1; j \u0026lt;= m; j++) { int res = min(dp[0][j][0], dp[0][j][1]); cout \u0026lt;\u0026lt; (res \u0026gt;= 1e9 ? -1 : res) \u0026lt;\u0026lt; endl; } return 0; } ","date":"22 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/atcoder/atcoder-abc275f-erase-subarrays/","section":"Posts","summary":"Atcoder-ABC275F Erase Subarrays # 题目大意 # 给定 $n, m$ 和长度为 $n$ 的整数数组 $a$ .","title":"Atcoder-ABC275F Erase Subarrays"},{"content":"LeetCode-1799 N 次操作后的最大分数和 # Solution 1 # 状压 DP 即可. 代码如下:\nclass Solution { public: int memo[20000]; int g[14][14]; int f(int s, vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (s == 0) { return 0; } if (memo[s] != -1) { return memo[s]; } int n = nums.size(); int id = (n - __builtin_popcount(s)) / 2 + 1; int res = 0; for (int i = 0; i \u0026lt; n; i++) { if (s \u0026amp; 1 \u0026lt;\u0026lt; i) { for (int j = i + 1; j \u0026lt; n; j++) { if (s \u0026amp; 1 \u0026lt;\u0026lt; j) { res = max(res, f(s - (1 \u0026lt;\u0026lt; i) - (1 \u0026lt;\u0026lt; j), nums) + id * g[i][j]); } } } } memo[s] = res; return res; } int maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); for (int i = 0; i \u0026lt; 1 \u0026lt;\u0026lt; n; i++) { memo[i] = -1; } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { g[i][j] = __gcd(nums[i], nums[j]); } } return f((1 \u0026lt;\u0026lt; n) - 1, nums); } }; ","date":"22 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1799-n-%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%E5%92%8C/","section":"Posts","summary":"LeetCode-1799 N 次操作后的最大分数和 # Solution 1 # 状压 DP 即可.","title":"LeetCode-1799 N 次操作后的最大分数和"},{"content":"Atcoder-ABC272E Add and Mex # 题目大意 # 给定数组 $a_1, \u0026hellip;, a_n$ , 进行如下操作 $m$ 次:\n对 $1\\leq i\\leq n$ , $a_i$ 加上 $i$ 每次操作后, 输出 $mex(a)$ , 即没有在 $a$ 中出现的最小非负整数.\nSolution 1 # 对于长度为 $n$ 的数组 $a$ , $0\\leq mex(a)\\leq n$ . 对于 $a_i$ , 只有当 $0\\leq a_i + i\\times j\\leq n - 1$ 时才可能对结果产生影响. 因此, 我们遍历 $i$ , 只记录可能的 $j$ , 最后进行统计即可. 总复杂度为 $\\sum_{i = 1}^{n} \\frac{n}{i} = O(nlogn)$ .\n代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; int a[n + 1]; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; } map\u0026lt;int, set\u0026lt;int\u0026gt;\u0026gt; book; for (int i = 1; i \u0026lt;= n; i++) { for (int j = max(1, -a[i] / i); j \u0026lt;= min(m, (n - 1 - a[i]) / i); j++) { book[j].insert(a[i] + i * j); } } for (int j = 1; j \u0026lt;= m; j++) { for (int i = 0; i \u0026lt;= n; i++) { if (!book[j].count(i)) { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; break; } } } return 0; } ","date":"21 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/atcoder/atcoder-abc272e-add-and-mex/","section":"Posts","summary":"Atcoder-ABC272E Add and Mex # 题目大意 # 给定数组 $a_1, \u0026hellip;, a_n$ , 进行如下操作 $m$ 次:","title":"Atcoder-ABC272E Add and Mex"},{"content":"LeetCode-1760 袋子里最少数目的球 # Solution 1 # 如果 $k$ 开销可以, 那么 $k + 1$ 的开销也可以. 同时我们可以在 $O(n)$ 时间内验证一个开销是否能够达成. 因此用二分搜索最小开销即可. 代码如下:\nclass Solution: def minimumSize(self, nums: List[int], maxOperations: int) -\u0026gt; int: left = 1 right = max(nums) while left \u0026lt; right: mid = left + (right - left) // 2 def check(nums: List[int], maxOperations: int, k: int) -\u0026gt; bool: for v in nums: maxOperations -= (v - 1) // k return maxOperations \u0026gt;= 0 if check(nums, maxOperations, mid): right = mid else: left = mid + 1 return left ","date":"20 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1760-%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/","section":"Posts","summary":"LeetCode-1760 袋子里最少数目的球 # Solution 1 # 如果 $k$ 开销可以, 那么 $k + 1$ 的开销也可以.","title":"LeetCode-1760 袋子里最少数目的球"},{"content":"病毒感染问题 # 题目 # 一种新型流感开始传播. 健康的人与感染的人有过接触后, 第二天会被感染; 感染的人第二天会痊愈, 并且拥有时效为 $1$ 天的抗体, 有抗体的情况下与感染者接触第二天不会被感染. 假设每个人每天都会与所有认识的人接触. 证明:\n如果有人开始拥有时效一天的抗体, 那么流感可能永远不会结束 如果开始时所有人都没有抗体, 那么流感迟早会结束. 解答 # 考虑以下模型: 有 $3$ 个人, 开始分别处于健康、感染与抗体状态, 且他们互相认识. 容易验证此时流感永远不会结束. 第 1 问得证.\n对于第 2 问, 把每个人看成一个节点, 两个人如果互相认识则连一条边. $x, y$ 之间的距离为最短路径的长度, 记为 $d(x, y)$ . 记初始时间第 $0$ 日的感染者集合为 $P$ , 按到集合 $P$ 的最短距离将人群划分为 $S_0(=P), S_1, S_2, \u0026hellip;$ , 其中 $S_k = {x\\vert \\underset{y\\in P}{min}\\ d(x, y) = k}$ . 下面来证明第 $k$ 日的感染者集合为 $S_k$ .\n第 $0, 1$ 日, 感染者集合分别为 $S_0(=P)$ , $S_1$.\n假设结论对 $n = k - 1, k$ 成立, 考虑 $n = k + 1$ . 第 $k+1$ 天的感染者来自第 $k$ 天与 $S_k$ 接触的健康人群.\n对于 $0\\leq i\\leq k - 2$ , $S_i$ 与 $S_k$ 不可能有边相连, 否则与 $S$ 的定义矛盾. 因此, 第 $k + 1$ 天的感染者不可能来自 $S_i$ , $0\\leq i\\leq k - 2$ ; 对于 $i\\geq k + 2$ 的 $S_i$ 不可能称为第 $k + 1$ 天的感染者, 理由同上; 对于 $S_{k - 1}$ , 由假设知, 他们在第 $k - 1$ 天感染并在第 $k$ 天痊愈并拥有抗体. 因此, 第 $k + 1$ 天的感染者不可能来自 $S_{k - 1}$ ; 对于 $x\\in S_{k + 1}$ , 假设 $d(x, y) = k+1, y\\in P$ , 考虑最短路径上的离 $x$ 最近的那一点 $z$ , 有 $d(z, y) = k$ , 因此 $z\\in S_k$ , 因此 $\\forall x\\in S_{k+1}$ , 在 $k+1$ 天都会成为感染者. 故结论对 $n = k + 1$ 也成立.\n综上, 第 $k$ 日的感染者集合为 $S_k$ . 显然人数是有限的, 因此距离也有限. 记节点集为 $V$ , $m = \\underset{x\\in V, y\\in P}{max}\\ d(x, y)$ , 那么第 $m + 1$ 的感染者集合为 $S_{m+1} = \\emptyset$ , 也就是说流感会在 $m + 1$ 天结束.\n","date":"19 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%982_%E7%97%85%E6%AF%92%E6%84%9F%E6%9F%93%E9%97%AE%E9%A2%98/","section":"Posts","summary":"病毒感染问题 # 题目 # 一种新型流感开始传播.","title":"趣题: 病毒感染问题"},{"content":"LeetCode-2503 矩阵查询可获得的最大分数 # Solution 1 # 对于查询 $query[i]$ , 选出所有值 $\u0026lt; query[i]$ 的单元格, 所得分数就是左上角单元格 (如果 $grid[0][0] \u0026lt; query[i]$ )所在的最大联通块的大小. 我们把 $query$ 数组从小到大排序, 同时用一个优先队列维护单元格, 用并查集维护连通块. 遍历 $query$ , 更新状态即可. 代码如下:\nclass Solution { public: typedef pair\u0026lt;int, int\u0026gt; pii; const int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; vector\u0026lt;int\u0026gt; pa; vector\u0026lt;int\u0026gt; sz; void Union(int x, int y) { x = Find(x); y = Find(y); if (x == y) { return; } else if (x \u0026lt; y) { pa[y] = x; sz[x] += sz[y]; } else { pa[x] = pa[y]; sz[y] += sz[x]; } } int Find(int x) { if (x == pa[x]) { return x; } pa[x] = Find(pa[x]); return pa[x]; } vector\u0026lt;int\u0026gt; maxPoints(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;int\u0026gt;\u0026amp; queries) { int m = grid.size(); int n = grid[0].size(); int k = queries.size(); vector\u0026lt;int\u0026gt; ans(k, 0); pa = vector\u0026lt;int\u0026gt;(m * n + n, 0); iota(pa.begin(), pa.end(), 0); sz = vector\u0026lt;int\u0026gt;(m * n + n, 1); vector\u0026lt;pii\u0026gt; q_id(k); for (int i = 0; i \u0026lt; k; i++) { q_id[i] = make_pair(queries[i], i); } priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, greater\u0026lt;pii\u0026gt;\u0026gt; q; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { q.emplace(grid[i][j], i * n + j); } } sort(q_id.begin(), q_id.end()); for (auto [bound, i]: q_id) { while (!q.empty() \u0026amp;\u0026amp; q.top().first \u0026lt; bound) { auto [val, hash] = q.top(); q.pop(); int x = hash / n; int y = hash % n; for (auto dir: dirs) { int nx = x + dir[0]; int ny = y + dir[1]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; m \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; grid[nx][ny] \u0026lt; bound) { Union(hash, nx * n + ny); } } } ans[i] = (grid[0][0] \u0026lt; bound? sz[0]: 0); } return ans; } }; ","date":"19 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2503-%E7%9F%A9%E9%98%B5%E6%9F%A5%E8%AF%A2%E5%8F%AF%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/","section":"Posts","summary":"LeetCode-2503 矩阵查询可获得的最大分数 # Solution 1 # 对于查询 $query[i]$ , 选出所有值 $\u0026lt; query[i]$ 的单元格, 所得分数就是左上角单元格 (如果 $grid[0][0] \u0026lt; query[i]$ )所在的最大联通块的大小.","title":"LeetCode-2503 矩阵查询可获得的最大分数"},{"content":"","date":null,"permalink":"/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/","section":"Tags","summary":"","title":"并查集"},{"content":"LeetCode-1703 得到连续 K 个 1 的最少相邻交换次数 # Solution 1 # 记 $x_i$ 为数组中第 $i$ 个 $1$ 的下标. 假设最终得到的连续 $k$ 个 $1$ 最左侧的 $1$ 位置为 $m$ , 来自原数组中下标为 $x_t$ 的那个 $1$ . 显然, 下标为 $x_t, x_{t+1}, \u0026hellip;, x_{t+k - 1}$ 的 $1$ 构成了最终的连续 $k$ 个 $1$ , 它们一共移动了 $\\sum_{i = 0}^{k - 1}\\vert x_{t+i} - (m+i)\\vert$ 距离, 也就是进行了同样多次数的相邻交换. 问题转化成求解下列优化问题: $$ \\underset{t,m}{min}\\ z = \\sum_{i = 0}^{k - 1}\\vert x_{t+i} - (m+i)\\vert $$\n记 $y_i = x_i - i, m\u0026rsquo;=m-t$ , 则 $x_{t+i} - (m+i) = y_{t+i} - (m - t) = y_{t+i}-m\u0026rsquo;$ , 优化问题变为: $$ \\underset{t,m\u0026rsquo;}{min}\\ z = \\sum_{i = 0}^{k - 1}\\vert y_{t+i}-m\u0026rsquo;\\vert $$ 在给定 $t$ 的情况下, 易知 $m\u0026rsquo; = y_{t+\\lfloor \\frac{k}{2}\\rfloor}$ 时最优, 此时目标值为 $$z^*(t)= \\underset{m\u0026rsquo;}{min}\\ z\\=\\sum_{i = 0}^{\\lfloor \\frac{k}{2}\\rfloor - 1}(y_{t+\\lfloor \\frac{k}{2}\\rfloor} - y_{t+i}) + \\sum_{i = \\lfloor \\frac{k}{2}\\rfloor}^{k - 1}(y_{t+i} - y_{t+\\lfloor \\frac{k}{2}\\rfloor})\\=(2\\times \\lfloor \\frac{k}{2}\\rfloor - k) \\times y_{t+\\lfloor \\frac{k}{2}\\rfloor} -\\sum_{i = 0}^{\\lfloor \\frac{k}{2}\\rfloor - 1}y_{t+i} + \\sum_{i = \\lfloor \\frac{k}{2}\\rfloor}^{k - 1}y_{t+i} $$\n通过预处理 $y_i$ 的前缀和, 我们可以在 $O(1)$ 时间内计算出 $z^*(t)$ , 从而可以在 $O(n)$ 时间内解决问题. 代码如下:\n#define ll long long class Solution { public: int minMoves(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int cnt = accumulate(nums.begin(), nums.end(), 0); int x[cnt]; int pre[cnt]; for (int i = 0, j = 0; i \u0026lt; nums.size() \u0026amp;\u0026amp; j \u0026lt; cnt; i++) { if (nums[i] == 1) { x[j] = i - j; pre[j] = x[j] + (j == 0 ? 0 : pre[j - 1]); j++; } } ll ans = 1e12; for (int t = 0; t \u0026lt;= cnt - k; t++) { ll m = x[t + k / 2]; ll res = (k / 2) * m - (t + k / 2 - 1 \u0026lt; 0 ? 0 : pre[t + k / 2 - 1]) + (t == 0 ? 0 : pre[t - 1]) + pre[t + k - 1] - (t + k / 2 - 1 \u0026lt; 0 ? 0 : pre[t + (k / 2) - 1]) - (k - k / 2) * m; ans = min(ans, res); } return ans; } }; ","date":"18 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1703-%E5%BE%97%E5%88%B0%E8%BF%9E%E7%BB%AD-k-%E4%B8%AA-1-%E7%9A%84%E6%9C%80%E5%B0%91%E7%9B%B8%E9%82%BB%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/","section":"Posts","summary":"LeetCode-1703 得到连续 K 个 1 的最少相邻交换次数 # Solution 1 # 记 $x_i$ 为数组中第 $i$ 个 $1$ 的下标.","title":"LeetCode-1703 得到连续 K 个 1 的最少相邻交换次数"},{"content":"Atcoder-Keyence2020D Swap and Flip # 题目大意 # 有 $n$ 张纸牌, 第 $i$ 张纸牌正面的数字是 $a_i$ , 反面的数字是 $b_i$ . 每次操作可以交换相邻的两张牌的位置, 同时翻转这两张牌. 初始所有的纸牌都是正面朝上. 求为了让看到的数字从左到右递增, 最少需要的操作次数. 如果无法做到这一点, 返回 -1 .\nSolution 1 # 我们用 $s$ 记录最终状态下纸牌的翻转情况. 如果 s \u0026amp; (1 \u0026lt;\u0026lt; i) == 1 代表纸牌处于翻转状态, 否则代表纸牌没有翻转. 首先注意到, 每次操作都会让翻转纸牌的数量 $+2$ , 不变或者 $-2$ . 由于初始所有纸牌正面朝上, 因此最终处于翻转状态的纸牌数量为偶数. 根据翻转状态, 我们可以确定最终正面朝上的数字是哪些, 以及它们是否经过了翻转, 用 $before$ 数组来记录这些状态. 将 $before$ 排序后的结果记为 $after$ 数组. 注意到这一步的排序不一定符合交换并翻转的规则 (排序过程相当于只进行了交换, 没有记录翻转) , 因此我们验证初始数组能否通过操作变为 $after$ 数组. 假设纸牌 $i$ 最终位置为 $j$ , 那么应当有:\n$\\vert i - j\\vert \\equiv before[i].second$ (翻转状态) $before[i].first = after[j].first$ 所有 $i, j$ 都得到匹配后, 说明当前的 $s$ 是一个合法的状态. 数组中的逆序对就是需要交换的次数.\n代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; typedef pair\u0026lt;int, int\u0026gt; pii; int main() { int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;pii\u0026gt; card(n); for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; card[i].first; } for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; card[i].second; } int ans = 1e9; for (int s = 0; s \u0026lt; (1 \u0026lt;\u0026lt; n); s++) { // s 表示最终卡牌翻转的状态 int res = 0; int k = __builtin_popcount(s); if (k \u0026amp; 1) { continue; } vector\u0026lt;pii\u0026gt; before(n), after(n); for (int i = 0; i \u0026lt; n; i++) { if (s \u0026amp; (1 \u0026lt;\u0026lt; i)) { before[i] = make_pair(card[i].second, 1); after[i] = before[i]; } else { before[i] = make_pair(card[i].first, 0); after[i] = before[i]; } } sort(after.begin(), after.end()); int cnt = 0; // cnt 记录得到匹配的 i 的数量 vector\u0026lt;int\u0026gt; pos(n, -1); // pos[j] 表示排序后的 j 位置纸牌初始在 i 位置 for (int i = 0; i \u0026lt; n; i++) { // 考虑 after[j] 从 card[i] 来 for (int j = 0; j \u0026lt; n; j++) { // 枚举 i, j 的可能匹配 if (pos[j] == -1 \u0026amp;\u0026amp; abs(i - j) % 2 == before[i].second \u0026amp;\u0026amp; before[i].first == after[j].first) { // 这里的翻转状态应当以 before 为准, 因为我们考虑的是 card[i] cnt++; pos[j] = i; break; } } } if (cnt != n) { continue; } for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if (pos[i] \u0026gt; pos[j]) { // 逆序对 res++; } } } ans = min(ans, res); } if (ans == 1e9) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"17 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/atcoder/atcoder-keyence2020d-swap-and-flip/","section":"Posts","summary":"Atcoder-Keyence2020D Swap and Flip # 题目大意 # 有 $n$ 张纸牌, 第 $i$ 张纸牌正面的数字是 $a_i$ , 反面的数字是 $b_i$ .","title":"Atcoder-Keyence2020D Swap and Flip"},{"content":"LeetCode-2488 统计中位数为 K 的子数组 # Solution 1 # 中位数只和大小关系有关. 只关心以 $k$ 为中位数的子数组个数, 因此把大于 $k$ 的元素记为 $1$, 小于 $k$ 的元素记为 $-1$ , 把 $k$ 记为 $0$ . 我们要找的子数组就是和为 $0$ 或 $1$ 且包含 $0$ 的子数组. 通过前缀和来统计. 首先计算 $k$ 左侧位置的前缀和, 用哈希表 $book$ 来存储数量. 接下来计算 $k$ 及其右侧位置的前缀和. 对于 $k$ 及其右侧位置的前缀和 $s$ , 有 $book[s]$ 以及 $book[s - 1]$ 个子数组和为 $0$ 或 $1$ 且包含 $0$ . 需要注意的是, $book$ 首先应当存储一个 $0$ , 可以看作左侧为空情况下的前缀和 (对应 $nums[0\u0026hellip;m]$ 的情况) , 这样才不会遗漏答案. 代码如下:\nclass Solution { public: int countSubarrays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int idx = -1; for (int i = 0; i \u0026lt; nums.size(); i++) { if (nums[i] == k) { nums[i] = 0; idx = i; } else if (nums[i] \u0026lt; k) { nums[i] = -1; } else { nums[i] = 1; } } int ans = 0; map\u0026lt;int, int\u0026gt; book; int sum = 0; book[0] = 1; // 空子数组的前缀和 for (int i = 0; i \u0026lt; idx; i++) { sum += nums[i]; book[sum]++; } for (int i = idx; i \u0026lt; nums.size(); i++) { sum += nums[i]; ans += book[sum] + book[sum - 1]; } return ans; } }; ","date":"15 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2488-%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","section":"Posts","summary":"LeetCode-2488 统计中位数为 K 的子数组 # Solution 1 # 中位数只和大小关系有关.","title":"LeetCode-2488 统计中位数为 K 的子数组"},{"content":"磁带最优存储问题 # 题目 # 磁带需要存储 $n$ 个 程序 $P_1, P_2, \u0026hellip;, P_n$ , 程序 $P_i$ 占据 $s_i$ 的空间, 并且依据经验, 每次使用磁带有 $\\pi_i$ 的概率是使用这个程序. 假设磁带有足够的空间, 存储信息的密度为常数, 读取速度也为常数, 此外, 读取完一个程序后需要将磁带倒带到初始状态. 如果程序以 $i_1, i_2, \u0026hellip;, i_n$ 的顺序存储, 那么平均读取用时为 $$ \\overline{T} = c\\sum_{j = 1}^{n}(\\pi_{i_j}\\sum_{k = 1}^{j}s_{i_k}) $$ 其中 $c$ 为与磁带本身有关的常数. 要使平均读取用时最短, 求程序排列的顺序.\n解答 # 每次读取程序都必须将前面所有的程序都读取一遍, 因此我们希望:\n$s_i$ 越大的程序越靠后 $w_i$ 越小的程序越靠前 综合这两个指标, 我们考虑将程序以 $\\frac{\\pi_i}{s_i}$ 不增的顺序排列. 下面来证明这种做法的正确性.\n对于排列 $i_1, i_2, \u0026hellip;, i_n$ , 假设存在 $(l, r)$ , 有 $\\frac{\\pi_{i_l}}{s_{i_l}} \u0026lt; \\frac{\\pi_{i_{r}}}{s_{i_{r}}}$ . 我们寻找这些数对 $(l, r)$ 里 $r - l$ 最小的那一对, 不妨记为 $(l_0, r_0)$ . 假设 $r_0\\not = l_0 + 1$ , 因为 $(l_0, r_0)$ 是符合条件的数对中距离最小的, 所以对于 $(l_0 + 1, r_0)$ 有 $\\frac{\\pi_{i_{l_0+1}}}{s_{i_{l_0+1}}} \\geq \\frac{\\pi_{i_{r_0}}}{s_{i_{r_0}}}$ , 对于$(l_0, l_0+1)$ 又有 $\\frac{\\pi_{i_{l_0}}}{s_{i_{l_0}}} \\geq \\frac{\\pi_{i_{l_0+1}}}{s_{i_{l_0+1}}}$ , 故 $\\frac{\\pi_{i_{l_0}}}{s_{i_{l_0}}} \\geq \\frac{\\pi_{i_{r_0}}}{s_{i_{r_0}}}$ , 与 $\\frac{\\pi_{i_{l_0}}}{s_{i_{l_0}}} \u0026lt; \\frac{\\pi_{i_{r_0}}}{s_{i_{r_0}}}$ 矛盾. 因此如果存在 $(l, r)$ 使得 $\\frac{\\pi_{i_l}}{s_{i_l}} \u0026lt; \\frac{\\pi_{i_{r}}}{s_{i_{r}}}$ , 那么我们一定能找到 $i_j, i_{j + 1}$ , 满足 $\\frac{\\pi_{i_j}}{s_{i_j}} \u0026lt; \\frac{\\pi_{i_{j+1}}}{s_{i_{j+1}}}$ . 记原平均读取用时为 $\\overline{T}0$ , 交换 $i_j, i{j + 1}$ 后的平均读取用时为 $\\overline{T}1$ , 则变化量 $$\\Delta = \\overline{T}1 - \\overline{T}0 \\= c[\\pi{i{j + 1}}(\\sum{k = 1}^{j - 1}s_{i_k} + s_{i_{j + 1}})) + \\pi_{i_{j}}(\\sum_{k = 1}^{j}s_{i_k} + s_{i_{j + 1}}) - \\pi_{i_{j}}\\sum_{k = 1}^{j}s_{i_k} - \\pi_{i_{j + 1}}\\sum_{k = 1}^{j + 1}s_{i_k}] \\= c(\\pi_{i_j}s_{i_{j + 1}} - \\pi_{j+1}s_{i_j}) $$\n由于 $$ \\frac{\\pi_{i_j}}{s_{i_j}} \u0026lt; \\frac{\\pi_{i_{j+1}}}{s_{i_{j+1}}} $$\n故 $$ \\pi_{i_j}s_{i_{j + 1}} \u0026lt; \\pi_{j+1}s_{i_j} $$\n所以 $$ \\Delta\u0026lt;0 $$\n每次这样的交换都会让 $\\overline{T}$ 更小, 直到不能够交换为止. 因此, 将程序以 $\\frac{\\pi_i}{s_i}$ 不增的顺序排列能使平均读取时间最短.\n","date":"14 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E6%9D%82%E8%B0%88/%E7%A3%81%E5%B8%A6%E6%9C%80%E4%BC%98%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98/","section":"Posts","summary":"磁带最优存储问题 # 题目 # 磁带需要存储 $n$ 个 程序 $P_1, P_2, \u0026hellip;, P_n$ , 程序 $P_i$ 占据 $s_i$ 的空间, 并且依据经验, 每次使用磁带有 $\\pi_i$ 的概率是使用这个程序.","title":"磁带最优存储问题"},{"content":"动态规划 # 动态规划(Dynamic programming, 简称DP) 是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的, 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法. 在解决多阶段决策优化问题时, 动态规划是一种常见的方法.\n本文主要介绍运筹学中的动态规划的一些例子.\n最短路问题 # 给定起点和终点, 每天都能通过一些城市进行中转, 找出一条最短的路径.\n假设:\n阶段 $0$ 为起点 阶段 $1\\leq n\\leq N$ 的城市集合为 $S_n$ 阶段 $N + 1$ 为终点 $a_{i, j}^n$ 为阶段 $n$ 从城市 $i\\in S_n$ 出发到达城市 $j\\in S_{n + 1}$ 的路程; 如果不存在路径, 则记距离为 $+∞$ . 定义 $J_n(i)$ 为第 $n$ 天从 $i$ 城市出发, 到达终点的最短路径. 有:\n$J_N(i) = a_{i, t}^N$ , $i\\in S_{N}$ $J_n(i) = \\underset{j\\in S_{n + 1}}{min}[a_{i, j}^n + J_{n + 1}(j)]$ , $i\\in S_n, 0\\leq n\\leq N$ 最长公共子序列 # 有序列 $X$ 和序列 $Y$ , 计算它们的最长公共子序列.\n记 $LCS(X[1\u0026hellip;m], Y[1\u0026hellip;n])$ 为 $X$ 前 $m$ 位和 $Y$ 前 $n$ 位的最长公共子序列. 有: $$ LCS(X[1\u0026hellip;m], Y[1\u0026hellip;n])=\\begin{cases} 1 + LCS(X[1\u0026hellip;m - 1], Y[1\u0026hellip;n - 1])\\ max(LCS(X[1\u0026hellip;m - 1], Y[1\u0026hellip;n]), LCS(X[1\u0026hellip;m], Y[1\u0026hellip;n - 1])) \\end{cases} $$\n旅行商问题 # 给定完全图 $G=(V, E)$ , 寻找从源点 $S$ 出发经过每个城市一次且最终回到 $S$ 的最短路径.\n设:\n阶段 $0$ 为起点 $S$ 阶段 $1\\leq n\u0026lt;\\vert V\\vert$ 为已访问的节点序列 阶段 $\\vert V\\vert$ 为 $S'$ $c_{i, j}$ 为城市 $i$ 与城市 $j$ 之间的距离 记 $J_n(X)$ 为阶段 $n$ 从节点序列 $X$ 的末尾城市 $i$ 出发到达 $S\u0026rsquo;$ 的最短路径. 有:\n$J_{\\vert V\\vert}(S\u0026rsquo;) = 0$ $J_{n}(X) =\\underset{Y=(X, j), j\\not\\in X}{min}[c_{i, j} + J_{n + 1}(Y)]$ 矩阵链乘法 # 有 $n$ 个矩阵连乘, 计算最少的乘法次数. (假设矩阵相乘使用最朴素的做法, $a\\times b$ 的矩阵与 $b\\times c$ 的矩阵相乘需要 $a\\times b\\times c$ 次乘法. )\n记 $f(A_i\u0026hellip;A_j)$ 为矩阵序列 $A_i\u0026hellip;A_j$ 相乘需要的最少乘法次数, $c(X, Y)$ 为矩阵序列 $X$ 的计算结果与 $Y$ 的计算结果相乘需要的乘法次数. 有:\n$f(A_i) = 0, \\forall 1\\leq i\\leq n$ $f(A_i\u0026hellip;A_j)=\\underset{i\\leq k\u0026lt; j}{min}[f(A_i\u0026hellip;A_k) + f(A_{k + 1}\u0026hellip;A_j) + c(A_i\u0026hellip;A_k, A_{k + 1}\u0026hellip;A_j)]$ 资源分配问题 # 现有 $w$ 的初始资金, 同时有 $m$ 种投资项目, 向项目 $t$ 投入 $x_t$ 资金后会得到 $r_t(x_t)$ 的收入. 求能够得到的最大收入.\n记 $f_t(d_t)$ 为初始资金为 $d_t$ , 投资项目 $t, \u0026hellip;, m$ 的最大收入. 有:\n$f_{m + 1}(d_t) = 0, \\forall d_t\\geq 0$ $f_t(d_t) = \\underset{0\\leq x_t\\leq d_t}{max}[r_t(x_t) + f_{t + 1}(d_t - x_t))], 1\\leq t\\leq m$ 最优停止问题 # 一个人想要在 $N$ 个阶段内出售一件物品, 在阶段 $1, 2, \u0026hellip;, N$ , 他分别会收到 $w_1, w_2, \u0026hellip;, w_N$ 的报价, $w_i\\ i.i.d$ 且服从 $U[0, 1]$ . 在出售物品之后, 他可以把钱存进银行, 利率为 $r \u0026gt; 0$ . 求 $N$ 阶段可以获得的最大利润.\n记 $x_k$ 为阶段 $k$ 的状态, 这里的状态在报价之外还有已接受报价的状态 (记为 $T$) . 其表达式如下:\n$x_k=\\begin{cases}T,\\ if\\ x_{k - 1} = T\\ w_k,\\ o.w.\\end{cases}$ 记 $J_k(x_k)$ 为阶段 $k$ 在状态 $x_k$ 时能够得到的最大收入. 有:\n$J_N(x_N) = \\begin{cases}0,\\ if\\ x_N = T\\ x_N,\\ o.w.\\end{cases}$ $J_k(x_k) = \\begin{cases}0,\\ if\\ x_N = T\\ max[(1 + r)^{N-k}x_k, E[J_{k + 1}(w)]],\\ o.w.\\end{cases}, 1\\leq k\u0026lt;N$ 记 $a_k=E[\\frac{J_{k + 1}(w_{k+ 1})}{(1+r)^{N-k}}]$ , 那么在 $x_k\\geq a_k$ 时应当接受报价, 在 $x_k\u0026lt;a_k$ 时应当拒绝报价.\n考虑 $J_k(x_k)$ 的现值 $V_k(x_k)$ , 有 $V_k(x_k) = \\frac{J_k(x_k)}{(1 + r)^{N-k}}$ , 有递推公式:\n$V_k(x_k) = max[x_k, (1 + r)^{-1}E[V_{k + 1}(w)]]$ 可以证明 $V_k(x)\\geq V_{k + 1}(x), a_k \\geq a_{k + 1}$ , 以及 $a_k =\\frac{1}{1+r}\\int_{0}^{a_{k + 1}}a_{k+1}dU(w)+\\int_{a_{k+1}^{1}}wdU(w)$ .\n任务调度问题 # 有 $N$ 个任务, 每个任务需要先经过 $A$ 处理, 再经过 $B$ 处理, 耗时分别为 $a_i$ 和 $b_i$ . $A, B$ 一次最多处理一个任务. 求完成所有的任务所需的最少时间.\n定义状态: $k$ 阶段剩余的需要 $A$ 处理的任务集合为 $X_k$ , $B$ 处理完当前任务需要的时间为 $\\tau_k$ . 记 $J_k(X_k, \\tau_k)$ 为当前状态完成所有任务所需的最少时间. 有:\n$J_k(\\emptyset, \\tau_k) = \\tau_k$ $J_k(X_k, \\tau_k) = \\underset{i\\in X_k}{min[a_i + J_{k + 1}(X_k-{i}, max[0, \\tau_k - a_i] + b_i)]}$ ","date":"13 December 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%BF%90%E7%AD%B9%E5%AD%A6/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","section":"Posts","summary":"动态规划 # 动态规划(Dynamic programming, 简称DP) 是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的, 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法.","title":"动态规划"},{"content":"","date":null,"permalink":"/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/","section":"Tags","summary":"","title":"运筹学"},{"content":"关键路径分析 # 一个项目可能包含多个活动 (activity), 每个活动需要一定的时间来完成, 同时活动之间可能存在依赖关系, 即某些活动是另一些活动的前提. 如果项目是线性进行的 (同一时间只能进行一项活动), 那么拓扑排序可以给出完成项目的路径, 并且计算总时长. 但如果项目中的活动能够并行运行, 那么如下两个问题很关键:\n完成项目的最短用时是多少? 怎样才能尽可能多地并行? 活动点图 # 活动点图 (Activity-Node Graph) 是对上述项目的抽象. 每个节点是一个活动 (项目的开始和结束也视作活动) , 点权是完成活动所需的时间, 有向边代表活动间的依赖关系.\n活动点图非常直观, 但依据它计算项目的最短用时相对复杂. 为此, 我们需要做一些变换.\n事件点图 # 不同于活动点图, 事件点图 (Event-Node Graph) 中的节点代表活动的完成 (一个活动的完成也代表后继活动的开始) , 点之间的有向边代表了活动的依赖关系, 边权是完成活动所需的时间.\n将活动点图转化为事件点图时, 如果一个活动有多个前提活动, 那么额外设置一个虚拟点 (可以视作 \u0026ldquo;前提活动全部完成, 该活动开始\u0026rdquo;) 作为该活动的前提, 虚拟节点与前继节点之间的边权记为 $0$ . 关键路径分析 # 关键路径分析 (Critical Path Analysis) 基于事件点图, 我们需要找到从项目开始到项目结尾的最长路径, 这条路径被称为关键路径, 这是因为整个项目的最短时间 $=$ 并行路径中最长的那一条.\n最短完成时间 # 记 $EC_i$ 为节点 $i$ 的最短完成时间, 用如下方法计算所有节点的最短完成时间:\n$EC_1 = 0$ $EC_w=max(EC_v + c_{v,w}),\\ for\\ all\\ (v, w)\\in E$ 即一个节点的最短完成时间等于前置条件最短完成时间中的最长的.\n上面图片的下半部分直观地展示了整个流程. 从中可以看到, $A\\rightarrow C\\rightarrow F\\rightarrow H$ 是一条关键路径, 必须马不停蹄地进行; 而 $B\\rightarrow E\\rightarrow K\\rightarrow H$ 的时间要求则宽松很多. 想象一下把整个矩形框顺时针旋转 $90°$ , 所有的方块在重力的影响下向下坠落, 最终我们会得到一个最为 \u0026ldquo;拖延\u0026rdquo; 项目流程, 在不影响整体时间的情况下, 每个活动都尽可能慢地完成.\n最长完成时间 # 重申一下, 这里的最长完成时间是在项目以最短时间完成的情况下, 每个活动的最长完成时间. 记 $LC_i$ 为节点 $i$ 的最长完成时间, 用如下方法计算所有节点的最长完成时间:\n$LC_n = EC_n$ $LC_v = min(LC_w - c_{v, w},\\ for\\ all\\ (v, w)\\in E$ 即一个节点的最长完成时间等于后继节点最晚开始时间中最短的.\n松弛时间 # 松弛时间 (Slack Time) 代表在项目以最短时间完成的情况下, 每个活动最多可以拖延的时间. 记 $Slack(v, w)$ 为 $(v, w)$ 代表的活动的松弛时间, 可以用如下方法计算:\n$Slack(v, w)=LC_w - EC_v - c_{v, w} = LC_w - EC_w = LC_v - EC_v$ 计算复杂度 # 关键路径分析的计算复杂度为 $O(\\vert E+V\\vert)$ .\n","date":"9 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%E5%88%86%E6%9E%90/","section":"Posts","summary":"关键路径分析 # 一个项目可能包含多个活动 (activity), 每个活动需要一定的时间来完成, 同时活动之间可能存在依赖关系, 即某些活动是另一些活动的前提.","title":"关键路径分析"},{"content":"","date":null,"permalink":"/tags/%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"排序"},{"content":"排序 # 前置知识 # 在计算机科学与数学中, 一个排序算法 (Sorting Algorithm) 是一种能将一串资料依照特定排序方式进行排列的一种算法.\n根据数据量大小和存储容量的不同, 排序可以分为内部排序 (Internal Sorting)和外部排序 (External Sorting) . 内部排序中, 数据量通常较小, 内存可以加载所有数据并完成排序; 而在外部排序中, 数据量较大, 内存不足以一次性完全加载数据, 因此需要分块处理.\n本文主要讨论对数组元素的内部排序, 这些元素本身存储在了物理线性结构 (Physically Linear Structure) 上. 排序问题的约定如下:\n假定有 $N$ 个元素需要排序 以 C 语言的习惯为例, 数据下标从 $0$ 开始, 即待排序数组为 $A[0], A[1], \u0026hellip;, A[N - 1]$ 使用 $\u0026lt;$ 和 $\u0026gt;$ 作为比较运算符, 因此我们讨论的排序称为基于比较的排序 (Comparison-based Sorting) 选择排序 # 选择排序 (Straight Selection Sort) 是一种朴素的排序算法, 算法流程如下:\n找到当前列表中最小的元素 把最小元素与列表第一个元素交换 对剩下的列表 (不含第一个元素的列表) 重复上面的操作, 直到列表为空 选择排序把列表分成了两个部分:\n左列表, 由已经从小到大排序的元素构成 (前 $k$ 步后排好序的部分由原列表最小的 $k$ 个元素构成) 右列表, 由仍需排序的元素构成 计算复杂度为 $O(N^2)$ .\n插入排序 # 插入排序 (Insertion Sort) 的算法流程如下:\n遍历 $A[1], \u0026hellip; A[N - 1]$ , 每次将 $A[k]$ 插入到前面的某个位置, 来保证前 $k + 1$ 个元素保持有序. 插入排序同样把列表分成了两个部分:\n左列表, 由已经从小到大排序的元素构成 (前 $k$ 步后排好序的部分由原列表前 $k$ 个元素构成) 右列表, 由仍需排序的元素构成 注意选择排序与插入排序的区别.\n计算复杂度: $O(N^2)$ . 与选择排序比较次数固定不同, 插入排序的比较次数不固定. 最坏情况为原数组完全逆序, 此时计算复杂度为 $O(N^2)$ ; 最好情况为原数组已排好序, 此时计算复杂度为 $O(N)$ .\n折半插入排序 # 折半插入排序 (Binary Insertion Sort) 在插入排序的基础上优化了寻找插入位置的过程. 用二分查找替代原本的线性查找.\n计算复杂度仍然是 $O(N^2)$ .\n冒泡排序 # 冒泡排序 (Bubble Sort) 的算法流程如下:\n有 $N - 1$ 步 每一步从左到右遍历未排序的数组, 如果 $A[j] \u0026gt; A[j + 1]$ , 交换两者. 冒泡排序每次将剩余数组中最大的元素转移到最右侧.\n计算复杂度: $O(N^2)$\n简单排序算法的复杂度下界 # 我们前面引入的几种排序算法, 都是依靠交换相邻元素完成排序的 (插入排序的插入过程在代码实现时也是由一系列相邻元素的交换构成) , 而这些排序算法的复杂度都是 $O(N^2)$ . 这是否意味着依赖相邻元素的交换算法复杂度下界是 $O(N^2)$ 呢? 下面来讨论这个问题.\n逆序对 # 在一个数组中, 下标数对 $(i, j)$ 被称作一个逆序对, 如果:\n$i \u0026lt; j$ $A[i] \u0026gt; A[j]$ 对一个数组进行从小到大排序的过程, 本质上就是在不断消除数组中的逆序对. 交换相邻元素的操作等价于消除一个逆序对, 因此排序总共需要的交换次数等价于初始数组中逆序对的个数, 记为 $I$ .\n复杂度下界 # 考虑一个数组平均有多少个逆序对. 长度为 $N$ 的数组共有 $\\frac{N(N - 1)}{2}$ 个数对, 由对称性可以知道正序对和逆序对的平均数量一样, 因此长度为 $N$ 的数组平均有 $\\frac{N(N - 1)}{4}$ 个逆序对, 这意味着依靠交换相邻逆序对进行排序的算法, 其计算复杂度至少是 $O(N^2)$ .\n想要突破 $O(N^2)$ , 理论推导告诉我们不能局限于交换相邻元素, 有时候交换距离远一些的元素能够大大减少所需交换次数.\n希尔排序 # 希尔排序 (Shell Sort) 是最早突破 $O(N^2)$ 的排序算法之一, 它可以看作是插入排序的改进算法. 希尔排序的算法流程如下:\n根据固定的距离间隔 $h_k$ 将数组划分为几个子序列, 在各个子序列中分别进行比较和排序 (这一步通常由在 $h_k$ 个子序列分别使用插入排序完成, 因为插入排序在数据量较小时表现良好) 不断减少距离间隔并重复上述步骤 当距离间隔减少到 $1$ 时, 对整个数组进行基于相邻元素交换的排序 希尔排序的距离间隔序列 $h_t \u0026gt; h_{t - 1} \u0026gt; \u0026hellip; \u0026gt; h_1$ 称为增量序列 (Increment Sequence). 在阶段 $k$ (增量为 $h_k$) 完成后, 对于每个 $i$ , 有 $A[i] \\leq A[i + h_k]$ , 即所有的元素被分成了 $h_k$ 组分别排好了序, 此时我们称数组为 $h_k$ 排序好的. 希尔排序拥有一个重要的性质, 即一个 $h_k$ 排序好的数组在经过 $h_{k - 1}$ 排序操作后, 仍然是一个 $h_k$ 排序好的数组.\n增量序列与时间复杂度 # 如何选取增量序列? 一个常见的方法是取 $h_t = \\lfloor\\frac{N}{2}\\rfloor, h_k = \\lfloor\\frac{h_{k + 1}}{2}\\rfloor$ , 不过这种取法效果一般.\n如何选择最好的增量序列仍然没有得到理论上的解, 因此希尔排序的平均复杂度是一个悬而未决的开放问题. 使用一些特殊增量序列的希尔排序, 可以计算出最坏情况的复杂度:\n选取 $1, 2, 4, \u0026hellip;, 2^k$ 为增量序列, 最坏复杂度为 $O(N^2)$ 选取 $1, 3, 7, \u0026hellip;, 2^k - 1$ 为增量序列, 最坏复杂度为 $O(N^{\\frac{3}{2}})$ 归并排序 # 归并排序 (Merge Sort) 通过递归地合并两个排好序的数组来完成对原数组的排序, 它的算法流程如下:\n把数组分为左右两个子数组 分别把两个子数组排序 (这一步也可以调用归并排序) , 合并两个排好序的数组 数组长度是 $1$ 则直接返回 \u0026ldquo;并\u0026rdquo; 的计算复杂度是 $O(N)$ , 空间复杂度也是 $O(N)$ . 递归至多有 $logN$ 次, 因此时间复杂度为 $O(NlogN)$ . 由于存储合并结果的数组 $TempArray$ 可以复用, 所以空间复杂度是 $O(N)$ .\n归并排序是 \u0026ldquo;后序遍历\u0026rdquo; .\n快速排序 # 快速排序 (Quick Sort) 是现有效率最高的排序算法之一, 它有如下优点:\n平均时间复杂度为 $O(NlogN)$ . 最坏情况为 $O(N^2)$ , 但几乎遇不到这些情况. 空间复杂度为 $O(1)$ 由递归分治的思想设计, 易于理解 快速排序的流程如下:\n数组元素个数为 $0$ 或 $1$ 时, 直接返回 选择数组里的一个元素, 称作基准点 (pivot) 把去掉基准点的数组分为两部分, 一部分比基准点小, 一部分比基准点大 递归使用快速排序对两部分进行排序, 排好序的部分加上基准点构成排好序的原数组 快速排序的递归性质让算法过程看上去是在构建一棵二叉树. 不同于归并排序构造平衡二叉树, 快速排序本身不一定会构造出平衡二叉树, 对基准点的选择至关重要.\n基准点的选取 # 选择第一个元素作为基准点是一个自然的想法, 但效果很不好. 在原数据近似有序或逆序的情况下, 选第一个元素作为基准点很可能把数组分成了大小差异巨大的两个集合, 最坏情况为 $O(N^2)$ ; 而现实世界的许多输入都是近似有序的.\n随机选择基准点是个稳妥的方法, 但算法效率和随机数生成器的质量有关, 并且每次选择基准点也会有生成随机数带来的额外消耗.\n最为理想的基准点是整个数组的中位数, 因为这样可以均匀地分割剩余的集合, 但得到整个数组的中位数很麻烦. 退一步, 我们随机抽三个元素, 取它们的中位数作为整个数组的中位数, 这是可行的, 但生成随机数带来的消耗同样不能忽视. 最终普遍采用的做法是三数中值分割法 (Median-of-Three Partitioning), 我们取数组最左侧、最中间和最右侧的元素的中位数作为基准点. '\n元素移动 # 选取基准点的下一步是移动元素, 把数组分成两部分. 一个简单的办法是直接开额外的数组空间, 遍历一遍原数组把元素按相对基准点的大小存进去. 这种做法的空间开销太大, 因此通常使用双边循环的方法进行原地交换.\n代码实现 # 首先是处理三数中值的函数 Median3() .\nint Median3(int A[], int Left, int Right) { // 注意对 A[] 的修改对原数组有效 int Tmp; // 用于交换的临时变量 int Center = (Left + Right) / 2; // 中间元素坐标 if (A[Left] \u0026gt; A[Center]) { // 保证 A[Left] \u0026lt; A[Center] Tmp = A[Left]; A[Left] = A[Center]; A[Center] = Tmp; } if (A[Left] \u0026gt; A[Right]) { // 保证 A[Left] \u0026lt; A[Right] Tmp = A[Left]; A[Left] = A[Right]; A[Right] = Tmp; } if (A[Center] \u0026gt; A[Right]) { // 保证 A[Center] \u0026lt; A[Right] Tmp = A[Center]; A[Center] = A[Right]; A[Right] = Tmp; } // A[Center] 为基准点, 交换基准点与 A[Right - 1] Tmp = A[Center]; A[Center] = A[Right - 1]; A[Right - 1] = Tmp; return A[Right - 1]; // 返回基准点的值 } Median3() 函数在返回基准点值的同时, 保证了 $A[Left] \u0026lt; pivot \u0026lt; A[Right]$ , 而 $A[Right - 1]$ 用来存储基准点了, 我们的目的是将元素与 $pivot$ 比较并排序, 因此后续交换从 $i = Left + 1$ 与 $j = Right - 2$ 开始.\n接下来看看整个快速排序的代码.\n#define Cutoff (3) // 数据量较小时使用插入排序效率更高 void QSort(int A[], int Left, int Right) { int i, j, Pivot, Tmp; if (Left + Cutoff \u0026lt;= Right) {// 数据量较大时应用快速排序 Pivot = Median3(A, Left, Right); // 得到基准点值 i = Left; // 初始化 i 为 Left, 实际上为 Left + 1 也不影响结果 j = Right - 1; // 初始化 j 为 Right - 1, 实际上为 Right - 2 也不影响结果 for (;;) { // 循环交换元素 while (A[++i] \u0026lt; Pivot) {}; // 向右找到第一个 A[i] \u0026gt; Pivot while (A[--j] \u0026gt; Pivot) {}; // 向左找到第一个 A[j] \u0026lt; Pivot if (i \u0026lt; j) { // 如果 i \u0026lt; j, 那么交换消除逆序对 Tmp = A[i]; A[i] = A[j]; A[j] = Tmp; } else break; // 如果 i \u0026gt; j, 退出循环 } // 交换 A[i] 与 A[Right - 1], 因为 A[Right - 1] 在前面存储了 Pivot, 这里把基准点放回去 Tmp = A[i]; A[i] = A[Right - 1]; A[Right - 1] = Tmp; QSort(A, Left, i - 1); // 递归处理左侧 QSort(A, i + 1, Right); // 递归处理右侧 } // 数据量较小时应用插入排序 InsertionSort(A + Left, Right - Left + 1); } 可以看出 Qsort() 的递归是先序遍历.\n复杂度分析 # 记 $T(N)$ 为对长度为 $N$ 的数组进行快速排序所需的时间. $T(0) = T(1) = 1$ . 因为 Median3() 时间复杂度为 $O(1)$ , 遍历交换过程为 $O(N)$ , 所以有 $$ T(N) = T(i) + T(N - i - 1) + cN $$\n最坏情况是每次选出的基准点都是最小或最大的元素, 有 $T(N) = T(N - 1) + cN$ , 可以得到 $T(N) = O(N^2)$ .\n最好情况是每次都均匀分割, 有 $T(N) = 2T(\\frac{N}{2}) + cN$ , 即 $\\frac{T(N)}{N} = \\frac{\\frac{T(N)}{2}}{\\frac{N}{2}} + c$ , 可以得到 $T(N) = O(NlogN)$ .\n考虑平均复杂度, 假定 $T(i)$ 均匀分布, 有 $$ T(i) = \\frac{2}{N}\\sum_{j = 0}^{N - 1}T(j) + cN $$\n变形有 $$ NT(i) = 2\\sum_{j = 0}^{N - 1}T(j) + cN^2 $$\n用 $N - 1$ 代替 $N$ , 有 $$ (N - 1)T(i) = 2\\sum_{j = 0}^{N - 2}T(j) + c(N - 1)^2 $$\n两式相减, 有 $$ NT(N) - (N - 1)T(N - 1) = 2T(N - 1) + 2cN - c $$\n渐进情况下我们认为 $2cN - c \\approx 2cN$ 有 $$ NT(N) = (N + 1)T(N - 1) + 2cN $$\n左右同时除以 $N(N + 1)$ , 有 $$ \\frac{T(N)}{N + 1} = \\frac{T(N - 1)}{N} + \\frac{2c}{N + 1} $$\n累加, 有 $$ \\frac{T(N)}{N + 1} = \\frac{T(1)}{2} + 2c\\sum_{i = 3}^{N + 1}\\frac{1}{i} $$\n由于 $\\sum_{i = 1}^{N}\\frac{1}{i} = ln(N + 1) + γ$ , 故 $$ T(N) = O(NlogN) $$\n排序算法的复杂度下界 # 在前面的算法中, 排序算法的时间复杂度最低是 $O(NlogN)$ . 而在理论上, 依靠成对比较 (Pairwise Comparison) 的排序算法在最坏情况下的最优复杂度正是 $O(NlogN)$ .\n不管是什么排序算法, 其比较的逻辑都是一棵决策树 (Decision Tree) . 假定有 $N$ 个数需要排序, 那么总共可能有 $N!$ 种结果, 每次比较可以折半减少结果可能, 最终比较所需的次数等价于决策树的深度. 因为这颗二叉树有 $N!$ 个叶子节点, 因此深度至少为 $\\lceil logN!\\rceil$, 因此至少需要 $O(log(N!)) = O(NlogN)$ 次比较.\n这是冰冷的理论告诉我们的下界. 不过, 如果有额外的信息, 人类的智慧可以突破 $O(NlogN)$ .\n表排序 # 现实中, 我们经常需要依照某个键对大型结构体进行排序, 例如依照学号对学生信息进行排序. 与前面的排序不同的是, 对大型结构体进行数据交换的操作开销非常大, 因此对数据操作是一件不太可行的事. 一个更好的方法是创建一个指向这些结构体的指针数组, 依照键对指针数组进行排序. 例如结构体数组 $A[0], \u0026hellip;, A[N - 1]$ , 创建 $T[0], \u0026hellip;, T[N - 1]$ , 对 $T$ 排序, 使得 $A[T[0]].key \u0026lt; \u0026hellip; \u0026lt; A[T[N - 1]].key$ .\n在表排序完成的情况下, 如果需要改动结构体数据进行物理排序, 即需要把 $A[T[i]]$ 移动到 $A[i]$ 的位置上, 可以在 $O(N)$ 时间内完成. 注意到下标重排后可以分解成若干个不相交的环. 对于每个环, 把第一个元素对应的结构体存储到 $Temp$ 中, 再依次把后续的元素存到前一个元素的位置, 最后把 $Temp$ 填到空缺的位置上, 就完成了对这个环对应的结构体的物理排序. 时间复杂度 $O(N)$ , 空间复杂度 $O(1)$ .\n桶排序 # 桶排序(Bucket Sort) 是一种针对整数 (或可以离散化) 的数据的排序方法, 要求知道数据的范围. 这里我们假定待排序数组 $A$ 的元素都是不重复的整数, 且范围为 $[1, M]$ .桶排序的算法流程如下:\n创建一个数组 $Count$ , 最大下标至少为 $M$ 遍历 $A$ 数组, 对于 $A[i]$ , 让 $Count[A[i]] = 1$ 遍历完 $A$ 之后, 遍历 $Count$ 数组, 如果有 $Count[k] \u0026gt; 0$ , 输出 $k$ . 最终输出结果就是排好序的 $A$ 桶排序的时间复杂度为 $O(M + N)$ , 需要额外 $O(M)$ 的空间. 这个排序的性能相当依赖数据的分布.\n基数排序 # 基数排序 (Radix Sort) 可以看作桶排序的一个推广, 它也被称作扑克排序 (Poker Sort) 或分布排序 (Distribution Sort) .\n基数排序相较于桶排序在空间消耗上减小了很多. 它的算法流程如下:\n创建一个长度为 $1$ 的桶数组 在第 $k$ 轮排序中, 将从左到右将第 $k$ 位为 $i$ 个元素放入桶 $i$ 中 最高位排序完成后, 按顺序输出桶中元素就得到原数组的排序结果 基数排序的时间复杂度为 $O(P(N + B))$ , 其中 $P$ 是数据的最高位数, $N$ 是元素个数, $B$ 则则是桶的数量.\n外部排序 # 前面讨论的主要是内部排序, 在内存中进行比较与交换操作速度非常快. 但是, 当数据量过大以至于内存不能一次加载所有数据时, I/O 操作耗费的时间会远远高于内存中操作耗费的时间.\n简单归并排序 # 把数据拆分成许多份, 分别在内存中排好序, 再进行合并操作. 合并时不可避免地会在 I/O 上耗费大量时间.\n多路归并排序 # ","date":"5 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","section":"Posts","summary":"排序 # 前置知识 # 在计算机科学与数学中, 一个排序算法 (Sorting Algorithm) 是一种能将一串资料依照特定排序方式进行排列的一种算法.","title":"排序"},{"content":"","date":null,"permalink":"/tags/%E5%9B%BE/","section":"Tags","summary":"","title":"图"},{"content":"","date":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构"},{"content":"网络表示法 # 网络的概念 # 网络是一个图 $G = (N, A)$ , $N$ 是节点集, $A$ 是边集. 网络具有如下的特点:\n边有向 图 $G$ 是简单图 网络中可能会有两个特殊点, 分别是入度为 $0$ 的点和出度为 $0$ 的点.\n网络的存储 # 我们需要存储:\n网络的拓扑结构 网络相关的数据, 包括 边权 为了表示拓扑结构, 有这些方法:\n关联矩阵 (Node-arc incidence matrix) 邻接矩阵 (Node-node adjacency matrix) 邻接表 (Adjacency list) 星式表示法 (Star (array) representations) 关联矩阵 # 关联矩阵的行坐标为节点, 列坐标为边, 矩阵元素值为 $0$ 代表边与节点无关联, 为 $1$ 代表节点为边的出发点, 为 $-1$ 代表节点为边的目标点.\n通过定义, 可以得到如下的性质:\n每一列有且仅有一个 $1$ 和一个 $-1$ 每一行 $1$ 的数量等于节点的出度 每一行 $-1$ 的数量等于节点的入度 如果有 $n$ 个节点, $m$ 条边, 总共需要 $nm$ 的空间, 其中存储有效信息的是 $2m$ , 利用率为 $\\frac{2}{n}$ . 显然, 在 $n$ 增长时, 利用率会变得越来越低.\n邻接矩阵 # 邻接矩阵行和列坐标都是节点, 如果存在从行节点到列节点的边, 这一格的值为 $1$ . 如果有 $n$ 个节点, $m$ 条边, 总共需要 $n^2$ 的空间, 其中存储有效信息的是 $m$ , 利用率为 $\\frac{m}{n^2}$ . 如果是稀疏网络, $m = kn$ , 利用率是 $k / n$ ; 如果是稠密网络, $m = n^2 - n$ , 利用率是 $\\frac{n - 1}{n}$ . 因此邻接矩阵适合稠密网络, 对于稀疏网络效果不佳.\n邻接表 # 用链表节点数组来存储图. 以一个节点为出发点的所有邻接点构成该节点为头节点的链表后继.\n如果有 $n$ 个节点, $m$ 条边, 需要 $n$ 个 null, $m$ 个指针, $m$ 个邻接点空间, 以及 $n$ 个头节点, 总计 $2n + 2m$ 的空间. 邻接表法的问题是\n指针需要空间 指针可能在代码编写上带来麻烦 星式表示法 # 定义 $A(i) = {l\\in N\\vert (i, l)\\in Arc}$ 为节点 $i$ 的后继点集, $B(i) = {l\\in N\\vert (l, i)\\in Arc}$ .\n星式表示法和邻接表很相似, 区别在于\n边以数组的形式存储, 而非链表 边是有序的 前向星 # 我们按如下顺序给边编号: 以节点 $1$ 为出发点的边, 以节点 $2$ 为出发点的边, \u0026hellip;\n可以用边编号, 出发点, 到达点, 边权四列构成的矩阵来代表一个图.\n记 $point(i)$ 为从节点 $i$ 出发的边的最小编号. 可以通过如下的方式计算所有的 $point(i)$ :\npoint(1) ← 1\rpoint(n + 1) ← m + 1\rFor j ← n to 2\rIf there are arcs leaving node j\rpoint(j) ← the smallest arc ID leaving j\rElse\rpoint(j) ← point(j + 1) 节点 $i$ 的出度 $= point(i + 1) - point(i)$ , 因为节点 $i$ 发出的边的编号是 $point(i), \u0026hellip;, point(i + 1) - 1$ .\n后向星 # 我们按如下顺序给边编号: 以节点 $1$ 为到达点的边, 以节点 $2$ 为到达点的边, \u0026hellip;\n其它与前向星类似, 这里定义了 $rpoint(i)$ 函数, 也有类似的计算方法:\nrpoint(1) ← 1\rrpoint(n + 1) ← m + 1\rFor j ← n to 2\rIf there are arcs entering node j\rpoint(j) ←the smallest arc ID entering j\rElse\rpoint(j) ← point(j + 1) 两种表示法的关联 # 前向星的着手点在于出度, 后向星在于入度, 分别对应了 $A(i)$ 与 $B(i)$ . 为了建立两者之间的关联, 通常可以\n先建立前向星的表示法 增加一个大小为 $m$ 的接口数组 (interface array), 记为 $trace$ 前向星表示中的边的属性 $trace(i)$ 对应后向星表示中的它的边编号 $i$ . ","date":"3 December 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E8%A1%A8%E7%A4%BA%E6%B3%95/","section":"Posts","summary":"网络表示法 # 网络的概念 # 网络是一个图 $G = (N, A)$ , $N$ 是节点集, $A$ 是边集.","title":"网络表示法"},{"content":"LeetCode-775 全局倒置与局部倒置 # Solution 1 # 全局倒置一定包含局部倒置, 所以要求排列只包含局部倒置. 考虑一个 $n = 4$ 的简单情况: $1, 0, 3, 2$ 为 true , 而 $1, 2, 0, 3$ 为 false . 如果只包含局部倒置, 那么每个元素要么是在原位, 要么与相邻元素进行了交换. 我们检查是否存在 $\\vert nums[i] - i \u0026gt; 1\\vert$ 即可. 代码如下:\nclass Solution { public: bool isIdealPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size(); i++) { if (abs(nums[i] - i) \u0026gt; 1) { return false; } } return true; } }; ","date":"16 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-775-%E5%85%A8%E5%B1%80%E5%80%92%E7%BD%AE%E4%B8%8E%E5%B1%80%E9%83%A8%E5%80%92%E7%BD%AE/","section":"Posts","summary":"LeetCode-775 全局倒置与局部倒置 # Solution 1 # 全局倒置一定包含局部倒置, 所以要求排列只包含局部倒置.","title":"LeetCode-775 全局倒置与局部倒置"},{"content":"LeetCode-1414 和为 K 的最少斐波那契数字数目 # Solution 1 # 贪心, 每次选不超过当前剩余数的最大斐波那契数即可. 详细的证明可以参考官方题解 和为 K 的最少斐波那契数字数目 . 代码如下:\nclass Solution { public: #define ll long long ll F[100] = {0}; ll f(int i) { if (F[i] != 0) { return F[i]; } if (i == 1 || i == 2) { F[i] = 1; return 1; } F[i] = f(i - 1) + f(i - 2); return F[i]; } int findMinFibonacciNumbers(int k) { int ans = 0; while (k != 0) { int l = 0; int r = 100; while (l \u0026lt; r) { int m = l + (r - l) / 2; if (f(m) \u0026lt;= k) { l = m + 1; } else { r = m; } } ans++; k -= f(l - 1); } return ans; } }; ","date":"14 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1414-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-1414 和为 K 的最少斐波那契数字数目 # Solution 1 # 贪心, 每次选不超过当前剩余数的最大斐波那契数即可.","title":"LeetCode-1414 和为 K 的最少斐波那契数字数目"},{"content":"LeetCode-1444 切披萨的方案数 # Solution 1 # 注意切割性质: 水平切一刀留下下半部分, 竖直切一刀留下右半部分, 因此任何时候我们处理的披萨都是左上端点为 $(i, j)$ , 右下端点为 $(m - 1, n - 1)$ 的部分. 考虑 $f(i, j, k)$ 代表左上端点为 $(i, j)$ , 右下端点为 $(m - 1, n - 1)$, 需要切成 $k$ 块的方案数量. 每次枚举可能的切割点. 对于判断是否有苹果, 可以用二维前缀和预处理. 代码如下:\nclass Solution: def ways(self, pizza: List[str], k: int) -\u0026gt; int: MOD = 1e9 + 7 m = len(pizza) n = len(pizza[0]) cnt = [[0]*n for _ in range(m)] cnt[m - 1][n - 1] = (int)(pizza[m - 1][n - 1] == \u0026#39;A\u0026#39;) for i in range(m - 2, -1, -1): cnt[i][n - 1] = cnt[i + 1][n - 1] + (pizza[i][n - 1] == \u0026#39;A\u0026#39;) for j in range(n - 2, -1, -1): cnt[m - 1][j] = cnt[m - 1][j + 1] + (pizza[m - 1][j] == \u0026#39;A\u0026#39;) for i in range(m - 2, -1, -1): for j in range(n - 2, -1, -1): cnt[i][j] = cnt[i][j + 1] + cnt[i + 1][j] + (pizza[i][j] == \u0026#39;A\u0026#39;) - cnt[i + 1][j + 1] @cache def f(i: int, j: int, k: int) -\u0026gt; int: if k == 1: if cnt[i][j] \u0026gt; 0: return 1 return 0 res = 0 for x in range(i + 1, m): if cnt[i][j] - cnt[x][j] \u0026gt; 0: if cnt[x][j] \u0026gt;= k - 1: res = (res + f(x, j, k - 1)) % MOD else: break for y in range(j + 1, n): if cnt[i][j] - cnt[i][y] \u0026gt; 0: if cnt[i][y] \u0026gt;= k - 1: res = (res + f(i, y, k - 1)) % MOD else: break return int(res) return f(0, 0, k) ","date":"14 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1444-%E5%88%87%E6%8A%AB%E8%90%A8%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","section":"Posts","summary":"LeetCode-1444 切披萨的方案数 # Solution 1 # 注意切割性质: 水平切一刀留下下半部分, 竖直切一刀留下右半部分, 因此任何时候我们处理的披萨都是左上端点为 $(i, j)$ , 右下端点为 $(m - 1, n - 1)$ 的部分.","title":"LeetCode-1444 切披萨的方案数"},{"content":"LeetCode-805 数组的均值分割 # Solution 1 # 设数组 $nums$ 分割成了两个均值相等的子数组 $A, B$ , 则 $nums$ 的均值与 $A$ 的均值也相等. 我们可以把 $nums$ 中的每个元素先乘 $n$ 再减去 $sum$ , 那么均值相等意味着和为 $0$ . 现在我们的目标变成了从 $nums$ 中选出一个和为 $0$ 的真子集 $A$ . 如果直接从整个 $nums$ 中选 $A$ , 枚举范围是 $2^{n}$ , 会超时; 考虑把 $nums$ 先拆分成左右两半 $S_1, S_2$ , 如果 $S_1$ 有某个子集和为 $0$ , 那么返回 true ; 对 $S_2$ 同理. 第三种情况是 $S_1$ 的子集和 $S_2$ 的子集的并集和为 $0$ , 我们可以用哈希表存储 $S_1$ 的枚举结果, 在 $S_2$ 枚举时进行比对. 需要注意 $S_1$ 和 $S_2$ 全选是不符合题意的, 这一点在实现时可以用不全选 $S_2$ 代替. 这样会不会导致漏掉 $S_2 \\cup$ $(S_1$ 的某个真子集 $)$ 呢? 事实是不会的. 假设存在这种情况, 那么其补集和也为 $0$ , 在枚举 $S_1$ 的子集时已经考虑过了. 代码如下:\nclass Solution { public: bool splitArraySameAverage(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n == 1) { return false; } int s = accumulate(nums.begin(), nums.end(), 0); for (int \u0026amp;num: nums) { num = num * n - s; } int m = n \u0026gt;\u0026gt; 1; set\u0026lt;int\u0026gt; book; for (int i = 1; i \u0026lt; 1 \u0026lt;\u0026lt; m; i++) { int t = 0; for (int j = 0; j \u0026lt; m; j++) { if (i \u0026amp; 1 \u0026lt;\u0026lt; j) { t += nums[j]; } } if (t == 0) { return true; } book.insert(t); } for (int i = 1; i \u0026lt; 1 \u0026lt;\u0026lt; (n - m); i++) { int t = 0; for (int j = 0; j \u0026lt; n - m; j++) { if (i \u0026amp; 1 \u0026lt;\u0026lt; j) { t += nums[m + j]; } } if (t == 0 || (book.count(-t) \u0026amp;\u0026amp; i != (1 \u0026lt;\u0026lt; (n - m)) - 1)) { return true; } } return false; } }; ","date":"14 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-805-%E6%95%B0%E7%BB%84%E7%9A%84%E5%9D%87%E5%80%BC%E5%88%86%E5%89%B2/","section":"Posts","summary":"LeetCode-805 数组的均值分割 # Solution 1 # 设数组 $nums$ 分割成了两个均值相等的子数组 $A, B$ , 则 $nums$ 的均值与 $A$ 的均值也相等.","title":"LeetCode-805 数组的均值分割"},{"content":" These notes DON\u0026rsquo;T contain the part about circuit as I know nothing about it.\nEE120 Signals and Systems Lecture 1 # Signals # Signals are functions of one or more variables. A continuous-time signal, denoted $x(t)$, depends on a real-value time variable $t$, and a discrete-time signal, $x[n]$, depends on the integer-valued variable $n$ that indexes instants of time.\nTwo special discrete-time signals:\nUnit Impulse: $\\delta[n] = \\begin{cases}1, if\\ n = 0\\ 0, if\\ n \\not = 0\\end{cases}$ Unit Step: $u[n] = \\begin{cases}1, if\\ n \\geq 0\\ 0, if\\ n \u0026lt; 0\\end{cases}$ Note that $\\delta[n] = u[n] - u[n - 1]$ and $u[n] = \\sum_{k = 0}^{\\infty}\\delta[n - k]$ .\nSystems # For the purposes of this course, a system is defined as a process by which input signals are transformed to output signals. Inputs are typically denoted as $x$ and outputs as $y$.\nExample: A moving average filter: $y[n] = \\frac{1}{3}(x[n - 1] + x[n] + x[n + 1])$\nMemory # A system is called memoryless if its output at a given time depends on the input only at that time.\nExample: The moving average filter is not a memoryless system since $y[n]$ depends on $x[n - 1]$ and $x[n + 1]$ , which means that the system would require memory registers to implement.\nCausality # A system is called causal if its output depends on the input at present and past times only, not on future times.\nExample: The moving average filter is not a causal system since $y[n]$ depends on the future input $x[n + 1]$ .\nStability # A system is called stable if all bounded inputs generate bounded outputs. It is unstable if there exists a bounded input for which the output grows unbounded.\nExample: The moving average filter is stable, since the output is simply an average of input values and remains bounded when the input is bounded.\nExample: The \u0026ldquo;accumulator\u0026rdquo; system, defined by $$ y[n] - y[n - 1] = x[n], y[-1] = 0 $$\nwhen $x[n] = 0$ for $n \u0026lt; 0$ has the solution $$ y[n] = x[0] + x[1] + \u0026hellip; + x[n], n \\geq 0 \\tag {*} $$ which can grow unbounded with bounded inputs, such as the unit step input which gives $y[n] = n + 1$ . The continuous-time analogue of the accumulator is the integrator: $$ \\frac{dy(t)}{dt} = x(t), y(0) = 0 $$ which is likewise unstable.\nLinearity # A system is called linear if it satisfies these two conditions:\nScaling: For any input-output pair $x(t) → y(t)$ and constant $a$, we have: $$ ax(t) → ay(t) $$ Superposition: For any two input-output pairs $x_1(t) → y_1(t)$, $x_2(t) → y_2(t)$ , we have: $$ x_1(t) + x_2(t) → y_1(t) + y_2(t) $$ Corollary: If the input to a linear system is $0$, the output must be $0$ .\nUsing the scaling property and choose $a = 0$ . Example: The moving average filter is linear.\nExample: The median filter: $$ y[n] = med{x[n - 1], x[n], x[n + 1]} $$ is nonlinear.\nTime-Invariance # A system is called time-invariant if a time shift in the input results is an identical time shift in the output: $$ x(t - T) \\rightarrow y(t - T) $$\nfor any input-output pair and any amount of shift $T$. (The system\u0026rsquo;s parameters may depend on the time $t$ ). The moving average and median filters above are both time-invariant because the rule for generating the output (take the average or median of previous, current, and next input) does not change with time. On the other hand, the system $y[n]$ = $nx[n]$ is time-varying, as it applies a different rule at each time (multiply the input with time n).\nLinear Time-Invariant (LTI) Systems and Convolution # Systems that are both linear and time-invariant, referred to as LTI systems, are amenable to powerful analysis tools that we will study in this course. In particular they have the remarkable property that knowing the response to a unit impulse input is enough to predict the response to any other input. To see this in discrete-time, let $h[n]$ denote the response of a LTI system to the unit impulse $δ[n]$ . Rewrite the input $x[n]$ as $$ x[n] = \u0026hellip; + x[-1]δ[n + 1] + x[0]δ[n] + x[1]δ[n - 1] + \u0026hellip; $$\nSince $δ[n]\\rightarrow h[n]$ , by time-invariance: $δ[n - k]\\rightarrow h[n - k], \\forall k$ . Then, by linearity: $$ y[n] = \u0026hellip; + x[-1]h[x + 1] + x[0]h[n] + x[1]h[n - 1] + \u0026hellip; $$\nThus, for input $x[n]$ , the output is : $$ y[n] = \\sum_{k=-\\infty}^{\\infty}x[k]h[n - k] $$\nThe operation on the right-hand side of the formula above is called the \u0026ldquo;convolution\u0026rdquo; of signals $x$ and $h$ , denoted $x * h$ : $$ (x * h)[n] := \\sum_{k = -\\infty}^{\\infty}x[k]h[n - k] $$\nExample: For the accumulator system the impulse response is the unit step, $u[n]$ . By using the convolution, we can acquire the solution (*).\n","date":"14 November 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F/ee120-signals-and-systems-lecture-1/","section":"Posts","summary":"These notes DON\u0026rsquo;T contain the part about circuit as I know nothing about it.","title":"EE120 Signals and Systems Lecture 1"},{"content":" 本文是[算法竞赛入门] 容斥原理与组合计数 (蒋炎岩)的学习笔记.\n大家都会的计数问题 # 枚举基本定理 # $$ \\vert A\\vert =\\sum_{a\\in A}1 $$\n解释了加法和乘法的本质, 枚举基本定理可以推导出加法/乘法原理 $\\sum$ 是 \u0026ldquo;求和程序\u0026rdquo; 提示我们寻找 $A\\mapsto B$ 的一一映射, 如果有这个映射, 那么有 $\\vert A\\vert = \\vert B\\vert$ 计数的本质 # 计数的本质是集合的生成(枚举). $$ \\vert A\\vert =\\sum_{a\\in A}1 $$\n扩展到两个集合:\n加法原理: $\\vert A\\cup B\\vert = \\vert A\\vert +\\vert B\\vert$ , 当 $A\\cap B=\\emptyset$ 时成立 乘法原理: $\\vert A\\times B\\vert = \\vert A\\vert \\cdot\\vert B\\vert$ 二进制串计数 # Case 0 # $n-bit$ 二进制串一共有多少个?\n$2^n$ (乘法原理) 实际上, 我们的大脑帮忙处理了一些过程:\n集合划分, 考虑第一位可以分成 $0$ 和 $1$ , 之后的 $n - 1$ 位可以两两对应, 这两个子集是大小是一样的, 因此有 $f(n) = 2f(n - 1)$ , 边界情况 $f(0) = 1$ . Case 1 # $n-bit$ 二进制串中 $0$ 比 $1$ 多的一共有多少个?\n从集合的角度思考, 同样考虑第一位是 $0$ 还是 $1$ , 先把集合划分成两个子集 $A_0, A_1$. 可以发现, $A_0$ 中每个 $0$ 比 $1$ 多的二进制串, 都对应着 $A_1$ 中的一个 $1$ 比 $0$ 多的二进制串 (按位取反即可) . 记$0$ 比 $1$ 多的二进制串数量为 $f(n)$ , $0$ 和 $1$ 数量相同的二进制串为 $g(n)$ , 可以得到这样的恒等式: $$ 2f(n) + g(n) = 2^n $$\n如果直接枚举 $0$ 的数量, 由加法原理, 我们可以得到: $$ f(n) = \\sum_{k = \\lfloor\\frac{n}{2}+1\\rfloor}^{n}C_{n}^{k} $$\n这样我们在解决问题之外, 还可以得到一个关于组合数的恒等式.\nCase 2 # 如果把 $0$ 看作 $($ , $1$ 看作 $)$ ,配对的括号序列有多少个?\n首先 $n$ 为奇数时不存在配对的括号序列, 我们下面讨论基于 $n$ 为偶数的假设. 同样地, 先写出集合. 这里我们考虑长度为 $n$ 的配对序列集合, 记集合大小为 $f(n)$ . 接下来, 寻找一种划分集合的方式. 每个配对序列的最左侧一定是一个 $($ , 它会与某个 $)$ 配对, 我们考虑 $)$ 的位置. 显然, $)$ 可以在左起任意偶数位置上. 考虑这个配对部分的长度, 设为 $k$ , 则 $k$ 内部长度为 $k - 2$ 的部分是一个配对序列, 有 $f(k - 2)$ 种, 而右侧剩余的长度为 $n - k$ 的序列同样是一个配对序列, 有 $f(n - k)$ 种. 基于加法与乘法原理, 我们有 $$ f(n) = \\sum_{k = 2}^{n}f(k - 2)\\cdot f(n - k) $$\n考虑另外一种映射处理: 有一个二维坐标系中的计数器, 遇到 $0$ 则 $+1$ , 遇到 $1$ 则 $-1$ , 则这个计数器应当是从 $(0, 0)$ 出发, 最后落在 $(n, 0)$ , 且从未到达过第四象限. $f(n)$ 就是满足该条件的折线段数量. 因为不能到达第四象限, 也就是折线段与 $y = -1$ 没有交点. 现在考虑不满足条件的折线段, 这些折线段与 $y = -1$ 有交点, 将交点右侧折线段沿 $y = -1$ 翻折, 则终点变为 $(n, -2)$ , $(0, 0)$ 到 $(n, 0)$ 的每一条不合法的折线段都与 $(0, 0)$ 到 $(n, -2)$ 的某条折线段对应. 故合法折线段数量 $f(n) = C_{n}^{\\frac{n}{2}} - C_{n}^{\\frac{n}{2} - 1}$ .\n$f(n)$ 有一个名称, 叫做卡特兰数 (Catalan number) .\n排列计数 # Case 0 # 求 $1, 2, \u0026hellip;, n$ 的所有排列的数量.\n$n!$ 从集合的角度, 考虑所有的排列, 按照第一个元素划分子集为 $A_1, A_2, \u0026hellip;, A_n$ , 除了第一个元素, 各个子集后面的排列一一对应, 故有 $f(n) = n\\cdot f(n - 1)$ , 边界情况 $f(0) = 1$ .\n考虑一个另外一种划分方式, 先把 $n$ 个数划分成 $k$ 和 $n - k$ 两组数. 两组数可以分别排列, 再组合成一个新的排列. 对于 $k$ 个数的一个排列, 和 $n - k$ 的一个排列, 考虑这两个排列怎么组合, 由于顺序两个子排列顺序已经固定, 我们可以抽象地把看成 $k$ 个红球和 $n - k$ 的蓝球的组合, 记这个组合数为 $C_{n}^{k}$ , 则有 $n! = k!\\cdot (n - k)!\\cdot C_{n}^{k}$ , 这样我们推导出了组合数: $$ C_{n}^{k} = \\frac{n!}{k!\\cdot (n - k)!} $$ 需要注意的是这里集合的划分对于每个 $k$ 都成立, 但不能应用加法公式, 因为这些划分交集非空.\nCase 2 # 错位排列: $1, 2, \u0026hellip;, n$ 的所有排列中, 每个数字都不在原位的排列的数量.\n从集合的角度, 考虑所有的排列, 按照第一个元素划分子集为 $A_1, A_2, \u0026hellip;, A_n$ . 第一个元素有 $n - 1$ 种可能, $A_i$ 中排列的后 $n - 1$ 个数构成的排列集合可以建立一一对应 (都是 $n - 2$ 个有对应位置的数与 $1$ 个没有对应位置的数构成的错排) . 因此我们可以得到 $f(n) = (n - 1)\\cdot g(n - 1)$ . 与上一个问题不同的是, $g(n - 1)$ 并不是一个更小情况的 $f(n)$ , 没有简单的递归关系, 但我们直觉上可以感觉到 $g(n)$ 是一个近似的错排问题. 同样对 $g(n - 1)$ 的集合分类, 我们取没有对应位置的元素 (即 $1$ ) 是否在缺乏对应元素的位置 (不妨设为 $2$ ) 为划分标准. 假如 $1$ 填补了这个空缺, 那么剩余 $n - 2$ 个元素构成了一个错排, 恰好是 $f(n - 2)$ ; 假如 $1$ 没有填补这个空缺, 那么把这个位置替换成 $1$ 对问题不构成影响, 此时恰好是 $n - 1$ 个元素构成的错排. 因此 $g(n - 1) = f(n - 1) + f(n - 2)$ , 最终我们有 $$ f(n) = (n - 1)\\cdot (f(n - 1) + f(n - 2)) $$\n边界情况是 $f(0) = 1$ .\n容斥原理 # 集合视角的计数 # 加法原理: $$ \\vert A\\cup B\\vert = \\vert A\\vert + \\vert B\\vert $$\n成立条件: $A\\cap B = \\emptyset$ 加法原理允许我们把集合拆成不相交的子集来计数.\n如果 $A, B$ 存在关联, 能不能求解?\n求 $1, 2, \u0026hellip;, 100$ 中有多少数能被 $2$ 或 $3$ 整除? $A$ 是能被 $2$ 整除的数构成的集合, $B$ 是能被 $3$ 整除的数构成的集合, $A\\cap B$ 是能被 $6$ 整除的数构成的集合, 那么 $|A\\cup B| = |A| + |B| - |A\\cap B|$ . 求交容易, 求并难 # $$ |A\\cup B| = |A| + |B| - |A\\cap B| $$\n许多问题都有 \u0026ldquo;交比并简单\u0026rdquo; 的性质.\n凸多边形的交 v.s. 并 任意两个凸多边形的交还是一个凸多边形 忘掉容斥原理, 考虑如下的方程组: $$ \\begin{pmatrix} x_0\\ x_1\\ x_2\\ x_3\\ x_4\\ x_5\\ x_6\\ x_7 \\end{pmatrix} \\begin{pmatrix} \\vert\\emptyset\\vert\\ \\vert A\\vert\\ \\vert B\\vert\\ \\vert C\\vert\\ \\vert A\\cap B\\vert\\ \\vert A\\cap C\\vert\\ \\vert B\\cap C\\vert\\ \\vert A\\cap B\\cap C\\vert\\ \\end{pmatrix} =\\vert A\\cup B\\cup C\\vert\\ $$\n从单个元素的集合角度思考, 例如对于 $e\\in A, e\\not \\in B, e\\not \\in C$ , 可以得到 $$ \\begin{pmatrix} x_0\\ x_1\\ x_2\\ x_3\\ x_4\\ x_5\\ x_6\\ x_7 \\end{pmatrix} \\begin{pmatrix} 0\\ 1\\ 0\\ 0\\ 0\\ 0\\ 0\\ 0\\ \\end{pmatrix} =1\\ $$\n类似地, 选取不同的 $e$ , 我们可以 \u0026ldquo;解出\u0026rdquo; 容斥原理. 知道这一点对的好处在于, 容斥原理的具体形式完全可以交给计算机来求解.\n容斥原理 (Principle of Inclusion and Exclusion) # 用若干个集合 \u0026ldquo;覆盖\u0026rdquo; 一个不规则的集合, 即可化并为交. $$ \\vert \\bigcup_{i = 1}^{n}A_i\\vert = \\sum_{\\emptyset \\not ={I\\subseteq[n]}}(-1)^{\\vert I\\vert + 1}\\vert \\bigcap_{i\\in I}A_i\\vert $$\n容 (Inclusion)\n$(-1)^{\\vert I\\vert + 1} = 1\\Rightarrow \\vert I\\vert \\in 1, 3, 5, 7, \u0026hellip;$ 斥 (Exclusion)\n$(-1)^{\\vert I\\vert + 1} = -1\\Rightarrow \\vert I\\vert \\in 2, 4, 6, 8, \u0026hellip;$ 什么问题求交容易, 求并难? # 求错位排列: $1, 2, \u0026hellip;, n$ 的所有排列中, 每个数字都不在原位的排列的数量.\n例子: $n = 4$\n$A, B, C, D$ 表示 $1, 2, 3, 4$ 恰好在第 $1, 2, 3, 4$ 个位置的排列; $n! - \\vert A\\cup B\\cup C\\cup D\\vert$ 就是答案. $\\vert A\\vert = (n - 1)!$ $\\vert A\\cap B\\vert = (n - 2)!$ $\\vert A\\cap C\\cap D\\vert = (n - 3)!$ \u0026hellip; 通过容斥原理, 我们能够直接得到错排数公式: $$ D_n = n!C_{n}^{0} - (n - 1)!C_{n}^{1} + (n - 2)!C_{n}^{2} - (n - 3)!C_{n}^{3} + \u0026hellip; $$\n容斥原理为什么是原理? # \u0026ldquo;集合\u0026rdquo; 和 \u0026ldquo;并\u0026rdquo; 是非常具有一般性的结构.\n例子: $\\phi(n)$ 是 $1, 2, \u0026hellip;, n$ 中与 $n$ 互质的数的数量\n如何求 $\\phi(n)$ ? $\\phi$ 和 $\\mu$ 的关系? $\\mu(n) = (-1)^k$ (如果 $n$ 是 $k$ 个素数的乘积) $\\mu(n) = 0$ (如果 $p^2$ 整除 $n$) 例子: $n = 5\\times 7\\times 13$ 把 \u0026ldquo;互质\u0026rdquo; 这一关系取反, \u0026ldquo;不互质\u0026rdquo; $\\Rightarrow$ \u0026ldquo;公因数\u0026rdquo; $A = {5, 10, 15, \u0026hellip;, n}$ $B = {7, 14, 21, \u0026hellip;, n}$ $C = {13, 26, 39, \u0026hellip;, n}$ $\\vert A\\cup B\\cup C\\vert = \\frac{n}{5} + \\frac{n}{7} + \\frac{n}{13} - \\frac{n}{5\\cdot 7} - \\frac{n}{5\\cdot 13} - \\frac{n}{7\\cdot 13} + \\frac{n}{5\\cdot 7\\cdot 13}$ 在利用容斥原理写出的求和式的形式里, 所有分母都是 $n$ 的约数, 同时每个质因子在分母里只出现一次; 那些拥有重复质因子的约数则没有出现在求和式中, 也就是系数为 $0$ . 利用容斥原理写出的求和式, 恰好就是莫比乌斯反演的形式: $$ \\phi(n) = \\sum_{d\\mid n}\\mu(d)\\frac{n}{d} $$\n更一般地, 有 $$ g(A) = \\sum_{S\\subseteq A}f(S)\\Rightarrow f(A) = \\sum_{S\\subseteq A}\\mu(A - S)g(S) $$\n","date":"14 November 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E6%9D%82%E8%B0%88/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/","section":"Posts","summary":"本文是[算法竞赛入门] 容斥原理与组合计数 (蒋炎岩)的学习笔记.","title":"容斥原理与组合计数"},{"content":"LeetCode-1377 T 秒后青蛙的位置 # Solution 1 # 由于本题青蛙在一棵无向树上跳动, 且不能往已跳过的点跳, 所以只可能从顶点不断向下跳. 记 $target$ 和根节点之间的距离为 $len$ , 则\n如果 $len \u0026gt; t$ , 那么 $t$ 时间跳不到 $target$ , 概率为 $0$ ; 如果 $len = t$ , 那么 $t$ 时间跳到的概率为路径上每一步概率之积; 如果 $len \u0026lt; t$ , 能否留在 $target$ 取决于其是不是叶子节点. 如果是, 那么概率同 $len = t$ 时, 否则为 $0$ . 我们可以用一次深度优先搜索得到每个点的父节点. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; pa; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; e; void dfs(int p, int c) { // dfs, 得到每个点的父节点 for (int i = 0; i \u0026lt; e[c].size(); i++) { if (e[c][i] == p) { continue; } pa[e[c][i]] = c; dfs(c, e[c][i]); } } double frogPosition(int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; edges, int t, int target) { pa = vector\u0026lt;int\u0026gt;(n + 1, 0); e = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 1); e[1].push_back(0); // 为了统一, 我们设根节点的父节点为节点 0 for (auto edge: edges) { e[edge[0]].push_back(edge[1]); e[edge[1]].push_back(edge[0]); } dfs(0, 1); int p = target; int len = 0; double x = 1.0; while (pa[p] != 0) { len++; p = pa[p]; x *= (e[p].size() - 1); } return (len == t || (len \u0026lt; t \u0026amp;\u0026amp; e[target].size() == 1))? 1.0 / x: 0; } }; ","date":"13 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1377-t-%E7%A7%92%E5%90%8E%E9%9D%92%E8%9B%99%E7%9A%84%E4%BD%8D%E7%BD%AE/","section":"Posts","summary":"LeetCode-1377 T 秒后青蛙的位置 # Solution 1 # 由于本题青蛙在一棵无向树上跳动, 且不能往已跳过的点跳, 所以只可能从顶点不断向下跳.","title":"LeetCode-1377 T 秒后青蛙的位置"},{"content":"LeetCode-174 地下城游戏 # Solution 1 # 根据向右向下的移动限制, 不难想到动态规划. 本题值得思考的地方在于动态规划的计算顺序. 如果从左上角向右下角进行递推, 很难同时确定状态和方案数. 从右下角向左上角进行递推, 则很容易进行. 记 $dp[i][j]$ 代表到达 $(i, j)$ 位置时至少需要多少体力. 考虑从 $dp[i][j]$ 到 $dp[i][j + 1]$ 的路径, 根据约束, 我们可以得到 $$ \\begin{cases} dp[i][j] \\geq 1\\ dp[i][j] + dungeon[i][j] \\geq dp[i][j + 1] \\end{cases} $$\n对于从 $dp[i][j]$ 到 $dp[i + 1][j]$ 的路径同理. 故有 $$ dp[i][j] = min(max(1, dp[i + 1][j] - dungeon[i][j]), max(1, dp[i][j + 1] - dungeon[i][j])) $$\n也就是 $$ dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]) $$\n代码如下:\nclass Solution { public: int calculateMinimumHP(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; dungeon) { int m = dungeon.size(); int n = dungeon[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); dp[m - 1][n - 1] = max(1, 1 - dungeon[m - 1][n - 1]); for (int i = m - 2; i \u0026gt;= 0; i--) { dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]); } for (int j = n - 2; j \u0026gt;= 0; j--) { dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]); } for (int i = m - 2; i \u0026gt;= 0; i--) { for (int j = n - 2; j \u0026gt;= 0; j--) { dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]); } } return dp[0][0]; } }; ","date":"13 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-174-%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F/","section":"Posts","summary":"LeetCode-174 地下城游戏 # Solution 1 # 根据向右向下的移动限制, 不难想到动态规划.","title":"LeetCode-174 地下城游戏"},{"content":"LeetCode-864 获取所有钥匙的最短路径 # Solution 1 # 本题中, 任一时刻的状态有三个分量: 横坐标 $x$ , 纵坐标 $y$ 与当前已有钥匙集合 $s$ . 在这三个状态为顶点构成的图上进行广度优先搜索即可. 代码如下:\nclass Solution { public: typedef pair\u0026lt;int, int\u0026gt; pii; typedef tuple\u0026lt;int, int, int\u0026gt; tiii; const int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; vector\u0026lt;vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026gt; visited; int shortestPathAllKeys(vector\u0026lt;string\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); int k = 0; tiii start; map\u0026lt;char, pii\u0026gt; keys; // 存储钥匙的坐标 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;@\u0026#39;) { start = make_tuple(i, j, 0); grid[i][j] = \u0026#39;.\u0026#39;; // 起点和空地没区别, 修改以统一 } else if (grid[i][j] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; grid[i][j] \u0026lt;= \u0026#39;z\u0026#39;) { k++; keys[grid[i][j]] = make_pair(i, j); } } } visited = vector\u0026lt;vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026gt; (m, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;(n, vector\u0026lt;bool\u0026gt;(1 \u0026lt;\u0026lt; k, false))); int ans = 0; queue\u0026lt;tiii\u0026gt; q; q.push(start); while (!q.empty()) { ans++; int sz = q.size(); while (sz--) { auto [x, y, s] = q.front(); q.pop(); for (auto dir: dirs) { int nx = x + dir[0]; int ny = y + dir[1]; int ns = s; if (nx \u0026lt; 0 || nx \u0026gt;= m || ny \u0026lt; 0 || ny \u0026gt;= n || grid[nx][ny] == \u0026#39;#\u0026#39; || visited[nx][ny][s]) { // 相邻点越界或是障碍的情况, 直接跳过 continue; } else if (grid[nx][ny] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; grid[nx][ny] \u0026lt;= \u0026#39;Z\u0026#39;) { // 锁, 需要对应的钥匙才能打开 if (!(s \u0026amp; 1 \u0026lt;\u0026lt; (int)(grid[nx][ny] - \u0026#39;A\u0026#39;))) { continue; } } else if (grid[nx][ny] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; grid[nx][ny] \u0026lt;= \u0026#39;z\u0026#39;) { // 钥匙, 更新 s ns = s | 1 \u0026lt;\u0026lt; (int)(grid[nx][ny] - \u0026#39;a\u0026#39;); if (ns == (1 \u0026lt;\u0026lt; k) - 1) { return ans; } } q.emplace(nx, ny, ns); visited[nx][ny][ns] = true; } } } return -1; } }; ","date":"13 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-864-%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/","section":"Posts","summary":"LeetCode-864 获取所有钥匙的最短路径 # Solution 1 # 本题中, 任一时刻的状态有三个分量: 横坐标 $x$ , 纵坐标 $y$ 与当前已有钥匙集合 $s$ .","title":"LeetCode-864 获取所有钥匙的最短路径"},{"content":"LeetCode-790 多米诺和托米诺平铺 # Solution 1 # 考虑平铺的状态转移, 由于一个末尾铺满的状态可能由末尾未铺满的状态转化而来, 我们用 $dp[i][s]$ 来记录长度为 $i$ , 前 $i - 1$ 列都已铺满, 末尾状态为 $s$ 的方案数量, 由 $n = 3$ 的样例不难发现转化关系. 代码如下:\nclass Solution { public: #define ll long long const int MOD = 1e9 + 7; int numTilings(int n) { vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;ll\u0026gt;(4, 0)); dp[0][3] = 1; dp[1][0] = 1; dp[1][3] = 1; for (int i = 2; i \u0026lt;= n; i++) { dp[i][0] = dp[i - 1][3]; dp[i][1] = (dp[i - 1][0] + dp[i - 1][2]) % MOD; dp[i][2] = (dp[i - 1][0] + dp[i - 1][1]) % MOD; dp[i][3] = (dp[i - 2][3] + dp[i - 1][1] + dp[i - 1][2] + dp[i - 1][3]) % MOD; } return dp[n][3]; } }; ","date":"13 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/","section":"Posts","summary":"LeetCode-790 多米诺和托米诺平铺 # Solution 1 # 考虑平铺的状态转移, 由于一个末尾铺满的状态可能由末尾未铺满的状态转化而来, 我们用 $dp[i][s]$ 来记录长度为 $i$ , 前 $i - 1$ 列都已铺满, 末尾状态为 $s$ 的方案数量, 由 $n = 3$ 的样例不难发现转化关系.","title":"LeetCode-790 多米诺和托米诺平铺"},{"content":"Atcoder-ABC162F Select Half # 题目大意 # 给定长度为 $n$ 的数组 $A$ , 从中选择 $\\lfloor \\frac{n}{2}\\rfloor$ 个不相邻的元素, 求元素和的最大值.\nSolution 1 # 数组下标从 $1$ 开始. 设 $dp[i]$ 为前 $i$ 个数中选择 $\\lfloor \\frac{i}{2}\\rfloor$ 个元素可以得到的最大和. 对于 $dp[i]$ , 如果选择了 $A_i$ , 那么最大和为 $dp[i - 2] + A_i$ .当 $i = 2k$ 时, 如果不选 $A_i$ , 那么需要从前 $2k - 1$ 个数中取出 $k$ 个数 , 因为所选数不能相邻, 因此只有一种选法, 即选择 $A_1, A_3, \u0026hellip;, A_{2k - 1}$ , 此时和为 $\\sum_{i = 1}^{k}A_{2k - 1}$ . 当 $i = 2k + 1$ 时, 如果不选 $A_i$ , 需要从前 $2k$ 个数中选出 $k$ 个不相邻的数, 恰好等于 $dp[2k] = dp[n - 1]$ .\n代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } vector\u0026lt;ll\u0026gt; dp(n + 1, 0); dp[1] = 0; ll sum = a[1]; for (int i = 2; i \u0026lt;= n; i++) { dp[i] = (i \u0026amp; 1)? max(dp[i - 1], dp[i - 2] + a[i]): max(sum, dp[i - 2] + a[i]); sum += (i \u0026amp; 1)? a[i]: 0; } cout\u0026lt;\u0026lt;dp[n]\u0026lt;\u0026lt;endl; return 0; } ","date":"9 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/atcoder/atcoder-abc162f-select-half/","section":"Posts","summary":"Atcoder-ABC162F Select Half # 题目大意 # 给定长度为 $n$ 的数组 $A$ , 从中选择 $\\lfloor \\frac{n}{2}\\rfloor$ 个不相邻的元素, 求元素和的最大值.","title":"Atcoder-ABC162F Select Half"},{"content":"LeetCode-2454 下一个更大元素 IV # Solution 1 # 在寻找 \u0026ldquo;下一个更大元素\u0026rdquo; 时, 通常利用单调栈处理. 现在需要寻找 \u0026ldquo;下面第二个更大元素\u0026rdquo; , 原先的处理思路需要变化. 我们考虑对一个元素找两次 \u0026ldquo;下一个更大元素\u0026rdquo; . 申请两个栈 $s_1$ 和 $s_2$ , 第一个依照寻找 \u0026ldquo;下一个更大元素\u0026rdquo; 正常处理, 对于找到了下一个最大元素的元素, 我们把它们按照原来的顺序存到 $s_2$ 中. 这样遍历数组时, $s_1$ 弹出的将会存到 $s_2$ 中, 而 $s_2$ 弹出的就是在右侧找到了两个最大元素的元素. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; secondGreaterElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; ans(n, -1); stack\u0026lt;int\u0026gt; s1, s2; for (int i = 0; i \u0026lt; n; i++) { stack\u0026lt;int\u0026gt; temp; while (!s1.empty() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s1.top()]) { temp.push(s1.top()); s1.pop(); } s1.push(i); while (!s2.empty() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[s2.top()]) { ans[s2.top()] = nums[i]; s2.pop(); } while (!temp.empty()) { s2.push(temp.top()); temp.pop(); } } return ans; } }; ","date":"9 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2454-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-iv/","section":"Posts","summary":"LeetCode-2454 下一个更大元素 IV # Solution 1 # 在寻找 \u0026ldquo;下一个更大元素\u0026rdquo; 时, 通常利用单调栈处理.","title":"LeetCode-2454 下一个更大元素 IV"},{"content":"LeetCode-754 到达终点数字 # Solution 1 # 考虑原问题的一个等价问题: $target$ 为正, 在数轴上从 $0$ 开始先向右走 $k$ 步, 再选择某些已走的步反转, 问能够到达 $target$ 的最小步数是多少. 首先我们走过的路程至少要越过 $target$ . 其次注意到反转已走路程时对总路程的影响是减去一个偶数, 这要求越过 $target$ 的路程必须是一个偶数. 当这一条件满足时, 总能找到已走路程的组合, 使得反转后总路程为 $target$ . 代码如下:\nclass Solution { public: int reachNumber(int target) { target = abs(target); int s = 0, n = 0; while (s \u0026lt; target || (s - target) \u0026amp; 1) { s += ++n; } return n; } }; ","date":"4 November 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-754-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9%E6%95%B0%E5%AD%97/","section":"Posts","summary":"LeetCode-754 到达终点数字 # Solution 1 # 考虑原问题的一个等价问题: $target$ 为正, 在数轴上从 $0$ 开始先向右走 $k$ 步, 再选择某些已走的步反转, 问能够到达 $target$ 的最小步数是多少.","title":"LeetCode-754 到达终点数字"},{"content":"LeetCode-907 子数组的最小值之和 # Solution 1 # 常见的考虑方法是对每个元素作为最小值的情况计数. 为了避免重复计数, 对于值相同的元素, 我们认为下标更小的那个元素更小. 代码如下:\n#define ll long long const int MOD = 1e9 + 7; class Solution { public: int sumSubarrayMins(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); stack\u0026lt;int\u0026gt; s; vector\u0026lt;int\u0026gt; left(n); for (int i = 0; i \u0026lt; n; i++) { while (!s.empty() \u0026amp;\u0026amp; nums[s.top()] \u0026gt; nums[i]) { s.pop(); } left[i] = s.empty()? -1: s.top(); s.push(i); } s = stack\u0026lt;int\u0026gt;(); vector\u0026lt;int\u0026gt; right(n); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!s.empty() \u0026amp;\u0026amp; nums[s.top()] \u0026gt;= nums[i]) { s.pop(); } right[i] = s.empty()? n: s.top(); s.push(i); } ll ans = 0; for (int i = 0; i \u0026lt; n; i++) { ans = (ans + (ll)nums[i] * (i - left[i]) * (right[i] - i)) % MOD; } return ans; } }; ","date":"31 October 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-907-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/","section":"Posts","summary":"LeetCode-907 子数组的最小值之和 # Solution 1 # 常见的考虑方法是对每个元素作为最小值的情况计数.","title":"LeetCode-907 子数组的最小值之和"},{"content":"","date":null,"permalink":"/tags/%E5%8D%95%E8%B0%83%E6%A0%88/","section":"Tags","summary":"","title":"单调栈"},{"content":"LeetCode-481 神奇字符串 # Solution 1 # 这个数列的构造方式有点特殊, 其本质上是一种 \u0026ldquo;自我指涉\u0026rdquo; . 只需要几句话就可以生成这个数列:\n数列由连续的 $1$ 和 $2$ 交错构成 数列第一项为 $1$ 数列的第 $i$ 项等于数列第 $i$ 个连续段的长度 其中相对难理解的就是第三点. 直接考虑整个数列的特殊性质是如何被满足的有点困难, 我们从第一项开始构造整个数列. 记这个数列为 ${a_n}$ . 因为 $a_1 = 1$ , 所以第一段, 也就是连续的 $1$ 的个数为 $1$ , 这意味着 $a_2 = 2$ , 这又告诉我们第二段 (也就是连续的 $2$ ) 长度为 $2$, 所以 $a_3 = 2$ \u0026hellip; 依此类推. 构造时, 数列的第 $i$ 项先生成, 之后我们不断根据已有的信息慢慢扩展整个数列, 这让人很自然地联想到双指针.\n代码如下:\nclass Solution { public: int magicalString(int n) { string s = \u0026#34;01\u0026#34;; int ans = 0; int p = 1; int i = 1; char v = \u0026#39;1\u0026#39;; while (p \u0026lt;= n) { if (s[i] == \u0026#39;2\u0026#39;) { s.push_back(v); } v = \u0026#39;1\u0026#39; + \u0026#39;2\u0026#39; - v; s.push_back(v); i++; p++; } for (int i = 1; i \u0026lt;= n; i++) { ans += s[i] == \u0026#39;1\u0026#39;; } return ans; } }; ","date":"31 October 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-481-%E7%A5%9E%E5%A5%87%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Posts","summary":"LeetCode-481 神奇字符串 # Solution 1 # 这个数列的构造方式有点特殊, 其本质上是一种 \u0026ldquo;自我指涉\u0026rdquo; .","title":"LeetCode-481 神奇字符串"},{"content":"","date":null,"permalink":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Tags","summary":"","title":"字符串"},{"content":"LeetCode-1388 3n 块披萨 # Solution 1 # 取完某块披萨, 相邻的披萨一定不能再取了, 因此取的元素至少满足不能相邻这一点. 实际上, 从 $3n$ 个元素中取出 $n$ 个不相邻的元素一定能够对应某种披萨的取法. 详细的证明可以参考力扣官方题解. 知晓这一点后利用动态规划即可. 代码如下:\nclass Solution { public: int maxSizeSlices(vector\u0026lt;int\u0026gt;\u0026amp; slices) { int n = slices.size() / 3; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(3 * n, vector\u0026lt;int\u0026gt;(n + 1, 0)); int ans = 0; for (int i = 0; i \u0026lt; 3 * n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i \u0026gt;= 2) { dp[i][j] = max(slices[i] + dp[i - 2][j - 1], dp[i - 1][j]); } else if (i == 1) { dp[i][j] = max(slices[i], dp[i - 1][j]); } else { dp[i][j] = slices[i]; } } } ans = dp[3 * n - 2][n]; dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(3 * n, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 1; i \u0026lt; 3 * n; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (i \u0026gt;= 2) { dp[i][j] = max(slices[i] + dp[i - 2][j - 1], dp[i - 1][j]); } else if (i == 1) { dp[i][j] = max(slices[i], dp[i - 1][j]); } else { dp[i][j] = slices[i]; } } } ans = max(ans, dp[3 * n - 1][n]); return ans; } }; ","date":"3 October 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1388-3n-%E5%9D%97%E6%8A%AB%E8%90%A8/","section":"Posts","summary":"LeetCode-1388 3n 块披萨 # Solution 1 # 取完某块披萨, 相邻的披萨一定不能再取了, 因此取的元素至少满足不能相邻这一点.","title":"LeetCode-1388 3n 块披萨"},{"content":"LeetCode-2401 最长优雅子数组 # Solution 1 # 一个优雅子数组要求元素两两之间的与都为 $0$ , 这意味着二进制上整个数组每一位至多有 $1$ 个 $1$ . 注意到对于合法区间 $[l, r]$ , 可以推出 $[l + 1, r]$ 也是合法的, 因此 $r$ 不减. 因此我们遍历 $l$ , 同时维护一个区间与和 $and_ sum$ , 不断更新 $r$ 即可. 因为要求元素之间两两与为 $0$ , 所以去掉 $nums[l]$ 更新 $and_ sum$ 只需要令 $and_ sum = and_ sum - nums[l]$ . 代码如下:\nclass Solution { public: int longestNiceSubarray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = 1; int n = nums.size(); int and_sum = 0; int r = 0; for (; r \u0026lt; n;) { if ((and_sum \u0026amp; nums[r]) == 0) { and_sum = and_sum | nums[r]; r++; } else { break; } } // cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;: \u0026#34;\u0026lt;\u0026lt;and_sum\u0026lt;\u0026lt;endl; ans = max(ans, r - 0); for (int i = 1; i \u0026lt; n; i++) { and_sum = and_sum ^ nums[i - 1]; for (; r \u0026lt; n;) { if ((and_sum \u0026amp; nums[r]) == 0) { and_sum = and_sum | nums[r]; r++; } else { break; } } ans = max(ans, r - i); } return ans; } }; ","date":"21 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2401-%E6%9C%80%E9%95%BF%E4%BC%98%E9%9B%85%E5%AD%90%E6%95%B0%E7%BB%84/","section":"Posts","summary":"LeetCode-2401 最长优雅子数组 # Solution 1 # 一个优雅子数组要求元素两两之间的与都为 $0$ , 这意味着二进制上整个数组每一位至多有 $1$ 个 $1$ .","title":"LeetCode-2401 最长优雅子数组"},{"content":"LeetCode-1000 合并石头的最低成本 # Solution 1 # 考虑合并为 $1$ 堆的最后一步, 一定是把 $k$ 堆石头合并为了一堆, 并且消耗了所有的石头数量之和的成本. 从区间上考虑问题, 记 $f(i, j, p)$ 为区间 $[i: j]$ 中的所有石头合并为 $p$ 堆石头的最低成本. 我们要求的最终答案就是 $f(0, n - 1, 1)$ . 先考虑一些边界情况, 如果区间内石头堆数量 $j - i + 1 \u0026lt; p$ , 很显然不存在合法的方案 (返回 $-1$ 表示不合法) ; 如果区间内石头堆数量 $j - i + 1 = p$ , 那么不需要合成费用. 对于其他的情况, 如果 $p = 1$ , 这 $1$ 堆需要 $k$ 堆来合成, 故 $f(i, j, 1) = f(i, j, k) + \\sum_{i\\leq t\\leq j}stones[t]$ . 如果 $p \u0026gt; 1$ , 那么考虑最左侧的一堆由左区间提供, 最右侧的 $p - 1$ 堆由右区间提供, 枚举分割点即可. 代码如下:\nclass Solution { public: int _k; int n; vector\u0026lt;int\u0026gt; pre; vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt; dp; int f(int i, int j, int p) { if ((j - i + 1 - p) % (_k - 1)) { return -1; } if (j - i + 1 \u0026lt; p) { return -1; } if (j - i + 1 == p) { return 0; } if (dp[i][j][p] != -1) { return dp[i][j][p]; } if (p == 1) { dp[i][j][p] = f(i, j, _k) + ((i == 0)? pre[j]: pre[j] - pre[i - 1]); return dp[i][j][p]; } int res = 1e9; for (int t = i; t \u0026lt; j; t++) { int f_l = f(i, t, 1); int f_r = f(t + 1, j, p - 1); if (f_l != -1 \u0026amp;\u0026amp; f_r != -1) { res = min(res, f_l + f_r); } } dp[i][j][p] = (res == 1e9)? -1: res; return dp[i][j][p]; } int mergeStones(vector\u0026lt;int\u0026gt;\u0026amp; stones, int k) { int n = stones.size(); if ((n - 1) % (k - 1)) { return -1; } dp = vector\u0026lt;vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026gt;(31, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(31, vector\u0026lt;int\u0026gt;(31, -1))); _k = k; pre = vector\u0026lt;int\u0026gt;(n, 0); for (int i = 0; i \u0026lt; n; i++) { pre[i] = i == 0? stones[i]: pre[i - 1] + stones[i]; } return f(0, n - 1, 1); } }; ","date":"20 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1000-%E5%90%88%E5%B9%B6%E7%9F%B3%E5%A4%B4%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/","section":"Posts","summary":"LeetCode-1000 合并石头的最低成本 # Solution 1 # 考虑合并为 $1$ 堆的最后一步, 一定是把 $k$ 堆石头合并为了一堆, 并且消耗了所有的石头数量之和的成本.","title":"LeetCode-1000 合并石头的最低成本"},{"content":"LeetCode-87 扰乱字符串 # Solution 1 # \u0026ldquo;扰乱字符串\u0026rdquo; 的操作逻辑是, 分割区间, 再选择交换还是不交换. 注意到对一个大区间进行操作后, 两个子区间的元素不会再有交集, 也就是说, 问题变成了更小的子问题. 定义 $f(i_1, j_1, i_2, j_2)$ 为 $s_1[i_1: j_1]$ 是否为 $s_2[i_2: j_2]$ 的扰乱字符串. 我们来考虑是否进行区间交换, 枚举可能的分割点转化为更小的子问题. 注意到两个字符串互为扰乱字符串的一些基本性质: 长度相同, 字符集合相同, 可以进行一些剪枝. 另外, 由于区间长度的限制, 我们 $f$ 函数的四个维度实际上只需要三个即可. 代码如下:\nclass Solution { public: int n; string _s1, _s2; int dp[31][31][31]; bool f(int i1, int j1, int i2, int j2) { // 代表 s1[i1: j1] 和 s2[i2: j2] 是否匹配 // 边界情况: 长度只有 1 if (i1 == j1) { return _s1[i1] == _s2[i2]; } // 查看备忘录 if (dp[i1][j1][i2] != -1) { return dp[i1][j1][i2]; } // 区间总长度为 j1 - i1 + 1 // 考虑不交换 set\u0026lt;char\u0026gt; l_1, l_2; for (int len = 1; len \u0026lt;= j1 - i1; len++) { l_1.insert(_s1[i1 + len - 1]); l_2.insert(_s2[i2 + len - 1]); if (l_1 == l_2) { if (f(i1, i1 + len - 1, i2, i2 + len - 1) \u0026amp;\u0026amp; f(i1 + len, j1, i2 + len, j2)) { dp[i1][j1][i2] = 1; return true; } } } // 考虑交换 l_1.clear(); set\u0026lt;char\u0026gt; r_2; for (int len = 1; len \u0026lt;= j1 - i1; len++) { l_1.insert(_s1[i1 + len - 1]); r_2.insert(_s2[j2 - len + 1]); if (l_1 == r_2) { if (f(i1, i1 + len - 1, j2 - len + 1, j2) \u0026amp;\u0026amp; f(i1 + len, j1, i2, j2 - len)) { dp[i1][j1][i2] = 1; return true; } } } dp[i1][j1][i2] = 0; return false; } bool isScramble(string s1, string s2) { for (int i = 0; i \u0026lt; 31; i++) { for (int j = 0; j \u0026lt; 31; j++) { for (int k = 0; k \u0026lt; 31; k++) { dp[i][j][k] = -1; } } } n = s1.size(); _s1 = s1; _s2 = s2; return f(0, n - 1, 0, n - 1); } }; ","date":"19 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-87-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Posts","summary":"LeetCode-87 扰乱字符串 # Solution 1 # \u0026ldquo;扰乱字符串\u0026rdquo; 的操作逻辑是, 分割区间, 再选择交换还是不交换.","title":"LeetCode-87 扰乱字符串"},{"content":"LeetCode-810 黑板异或游戏 # Solution 1 # 考虑必胜态, 如果 $nums[i]$ 的异或和为 $0$ , 那么根据规则直接获胜; 否则应该存在一种操作 (移除某个 $nums[i]$ ) 使得下一个状态是必败态. 如果是必败态, 那么不管移走哪个数, 剩下的数的异或和都是 $0$ , 记必败态原本 $nums$ 的异或和为 $XSum$ , 由于去掉一个数的异或和与加上这个数的异或和相等, 故有 $\\forall 0\\leq i \u0026lt; n, XSum\\bigoplus nums[i] = 0$ , 对 $i$ 求异或和, 则有 $\\bigoplus_{1\\leq t \\leq n + 1} XSum = 0$ , 所以必败态 $nums$ 的数量为奇数, 由此倒推, 必胜态 $nums$ 的数量为偶数. 接下来我们证明, 对于一个初始异或和非 $0$ 且元素数量为偶数的数组 $nums$ , 当前玩家总能找到一种操作方式, 使得留给对手的数组是一个初始异或和非 $0$ 且元素数量为奇数的数组. 假设不存在这种选择, 类似前文的证明, 可以推出原数组的元素数量为奇数, 与我们的前提矛盾. 综上, 初始 $nums$ 的异或和为 $0$ 或者数量为偶数时, 先手必胜. 更详细的证明可以参考 【宫水三叶の相信科学系列】运用「博弈论」分析「先手必胜态」序列具有何种性质 . 代码如下:\nclass Solution { public: bool xorGame(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int xor_sum = 0; for (auto num: nums) { xor_sum = xor_sum ^ num; } return xor_sum == 0 || !(nums.size() \u0026amp; 1); } }; ","date":"19 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-810-%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/","section":"Posts","summary":"LeetCode-810 黑板异或游戏 # Solution 1 # 考虑必胜态, 如果 $nums[i]$ 的异或和为 $0$ , 那么根据规则直接获胜; 否则应该存在一种操作 (移除某个 $nums[i]$ ) 使得下一个状态是必败态.","title":"LeetCode-810 黑板异或游戏"},{"content":"LeetCode-801 使序列递增的最小交换次数 # Solution 1 # 可以先考虑二分 + 贪心, 不过容易验证贪心是错的. 因为每一位有交换与不交换两种操作, 不妨考虑动态规划. 因为是否交换、交换完的序列是否合法与上一次是否交换有关, 因此我们用 $dp[i][j]$ 记录前 $i + 1$ 个字符, 最后一个字符是否交换, 形成递增序列的最少交换次数. $dp[i][j]$ 可以在一定条件下从 $dp[i - 1][0]$ 和 $dp[i - 1][1]$ 转化而来. 具体转移方程见代码. 代码如下:\nclass Solution { public: int minSwap(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(2, 1e9)); dp[0][0] = 0; dp[0][1] = 1; for (int i = 1; i \u0026lt; n; i++) { if (nums1[i] \u0026gt; nums1[i - 1] \u0026amp;\u0026amp; nums2[i] \u0026gt; nums2[i - 1]) { dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1] + 1; } if (nums1[i] \u0026gt; nums2[i - 1] \u0026amp;\u0026amp; nums2[i] \u0026gt; nums1[i - 1]) { dp[i][0] = min(dp[i][0], dp[i - 1][1]); dp[i][1] = min(dp[i][1], dp[i - 1][0] + 1); } } return min(dp[n - 1][0], dp[n - 1][1]); } }; ","date":"16 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-801-%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0/","section":"Posts","summary":"LeetCode-801 使序列递增的最小交换次数 # Solution 1 # 可以先考虑二分 + 贪心, 不过容易验证贪心是错的.","title":"LeetCode-801 使序列递增的最小交换次数"},{"content":"LeetCode-798 得分最高的最小轮调 # Solution 1 # 与其考虑每个 $k$ 能获得多少分, 不如考虑每个 $nums[i]$ 能在哪些 $k$ 下得分. 基于这一点, 我们可以算出 $nums[i]$ 对应的 $k$ 的区间. 考虑这段区间里的 $k$ 得分 $+1$ . 最终答案即为得分最高的那个 $k$ . 区间操作, 单次查询, 我们可以使用差分数组来处理这个过程. 代码如下:\nclass Solution { public: int bestRotation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; diff(2 * n + 1, 0); for (int i = 0; i \u0026lt; n; i++) { int x = nums[i]; if (i \u0026gt;= x) { diff[0]++; diff[i - x + 1]--; diff[i + 1]++; diff[n]--; } else { diff[i + 1]++; diff[n + i - x + 1]--; } } int maxn = diff[0]; int ans = 0; for (int i = 1; i \u0026lt; n; i++) { diff[i] += diff[i - 1]; if (diff[i] \u0026gt; maxn) { ans = i; maxn = diff[i]; } } return ans; } }; ","date":"16 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-798-%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E6%9C%80%E5%B0%8F%E8%BD%AE%E8%B0%83/","section":"Posts","summary":"LeetCode-798 得分最高的最小轮调 # Solution 1 # 与其考虑每个 $k$ 能获得多少分, 不如考虑每个 $nums[i]$ 能在哪些 $k$ 下得分.","title":"LeetCode-798 得分最高的最小轮调"},{"content":"LeetCode-2407 最长递增子序列 II # Solution 1 # 记 $dp[x]$ 为当前以 $x$ 值结尾的子序列的最长长度. 遍历数组, 当前元素为 $x$ 时, $dp[x] = max(dp[x - k], \u0026hellip;, dp[x - 1]) + 1$ . 因此我们要能找到一个数据结构, 能够快速地实现以下两种操作:\n单点修改 查询区间最大值 代码如下:\nclass Solution { int mx; vector\u0026lt;int\u0026gt; maxo; // 查询区间 [ql, qr] 中的最大值 int query(int id, int l, int r, int ql, int qr) { if (ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return maxo[id]; else { int nxt = id \u0026lt;\u0026lt; 1, mid = (l + r) \u0026gt;\u0026gt; 1; return max(ql \u0026lt;= mid ? query(nxt, l, mid, ql, qr) : 0, qr \u0026gt; mid ? query(nxt | 1, mid + 1, r, ql, qr) : 0); } } // 用 val 更新位置 pos 的最大值 void modify(int id, int l, int r, int pos, int val) { if (l == r) maxo[id] = max(maxo[id], val); else { int nxt = id \u0026lt;\u0026lt; 1, mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) { modify(nxt, l, mid, pos, val); } else { modify(nxt | 1, mid + 1, r, pos, val); } maxo[id] = max(maxo[nxt], maxo[nxt | 1]); } } public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { for (int x : nums) mx = max(mx, x); maxo.resize(mx * 4 + 10); // 线段树开四倍大小 int n = nums.size(); int ans = 0; for (int x: nums) { int res; if (x == 1) { res = 1; } else { res = query(1, 1, mx, max(1, x - k), x - 1) + 1; } modify(1, 1, mx, x, res); } return query(1, 1, mx, 1, mx); } }; ","date":"16 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2407-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-ii/","section":"Posts","summary":"LeetCode-2407 最长递增子序列 II # Solution 1 # 记 $dp[x]$ 为当前以 $x$ 值结尾的子序列的最长长度.","title":"LeetCode-2407 最长递增子序列 II"},{"content":"","date":null,"permalink":"/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/","section":"Tags","summary":"","title":"线段树"},{"content":"LeetCode-1723 完成所有工作的最短时间 # Solution 1 # 枚举的过程中, 第 $i$ 个工人面对的工作只与前 $i - 1$ 个工人的工作分配情况相关. 如果我们用 $dp[i][j]$ 表示前 $0, \u0026hellip;, i$ 这些工人承担了集合 $j$ 表示的工作, 则有状态转移方程: $$ dp[i][j] = \\underset{k\\in j}{min{max(dp[i - 1][k], sum[j - k])}} $$ 其中 $sum$ 为集合表示的工作的工作量之和, 可以预处理得到. 代码如下:\nclass Solution { public: int minimumTimeRequired(vector\u0026lt;int\u0026gt;\u0026amp; jobs, int k) { int n = jobs.size(); int s = (1 \u0026lt;\u0026lt; n) - 1; vector\u0026lt;int\u0026gt; sum(s + 1, 0); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(s + 1, 0)); for (int i = 1; i \u0026lt;= s; i++) { int j = (i - 1) \u0026amp; i; sum[i] = sum[j] + sum[i ^ j]; dp[0][i] = sum[i]; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= s; j++) { dp[i][j] = 1e9; for (int k = j; k \u0026gt;= 0; k = (k - 1) \u0026amp; j) { dp[i][j] = min(dp[i][k], sum[j ^ k]); } } } return dp[n - 1][s]; } }; Solution # 求最大值的最小值, 考虑二分. $check$ 函数利用回溯, 枚举可能的放置情况一步步判断. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; _jobs; int _k; bool backTrack(vector\u0026lt;int\u0026gt; workers, int m, int idx) { if (idx == _jobs.size()) { return true; } for (auto\u0026amp; worker: workers) { if (worker + _jobs[idx] \u0026lt;= m) { worker += _jobs[idx]; if (backTrack(workers, m, idx + 1)) { return true; } worker -= _jobs[idx]; } if (worker == 0 || worker + _jobs[idx] == m) { break; } } return false; } bool check(int m) { vector\u0026lt;int\u0026gt; workers(_k, 0); return backTrack(workers, m, 0); } int minimumTimeRequired(vector\u0026lt;int\u0026gt;\u0026amp; jobs, int k) { sort(jobs.begin(), jobs.end(), greater\u0026lt;int\u0026gt;()); _jobs = jobs; _k = k; int left = jobs[0]; int right = accumulate(jobs.begin(), jobs.end(), 0); while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (check(mid)) { right = mid; } else { left = mid + 1; } } return left; } }; ","date":"16 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1723-%E5%AE%8C%E6%88%90%E6%89%80%E6%9C%89%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/","section":"Posts","summary":"LeetCode-1723 完成所有工作的最短时间 # Solution 1 # 枚举的过程中, 第 $i$ 个工人面对的工作只与前 $i - 1$ 个工人的工作分配情况相关.","title":"LeetCode-1723 完成所有工作的最短时间"},{"content":"","date":null,"permalink":"/tags/%E5%9B%9E%E6%BA%AF/","section":"Tags","summary":"","title":"回溯"},{"content":"LeetCode-975 奇偶跳 # Solution 1 # 本题的关键在于怎么找到每个元素的后继. 以 $a[i] \u0026lt;= a[j], a[j]$ 为可能的最小值, $j$ 为可能的最小值中最小的下标为例. 快速地找到每个 $i$ 对应的 $j$ 是一大难点. 这种结构很容易让人想到应用单调栈解决的一个经典问题: 找到每个元素后第一个不小于自己的元素下标. 事实上, 我们把下标和元素值抽象成两个属性 $A$ 和 $B$ . 那么已经解决的问题就是寻找 $B$ 不小于当前元素, $A$ 不小于当前元素且 $A$ 尽可能小的元素; 我们要解决的问题就是寻找 $A$ 不小于当前元素, $B$ 不小于当前元素且 $B$ 尽可能小的元素 (如果存在多个 $B$ 相同的元素, 那么 $A$ 也要尽可能小). 可以看出这两个问题是基本对称的( $A$ 作为下标时不可能重复, 如果可重那么两个问题完全对称). 我们之前从小到大遍历 $A$ 属性(下标), 同时维护 $B$ 属性单调的栈; 那么现在从小到大遍历 $B$ 属性, 同时维护 $A$ 属性单调的栈即可. 代码如下:\nclass Solution { public: typedef pair\u0026lt;int, int\u0026gt; pii; int oddEvenJumps(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int n = arr.size(); vector\u0026lt;int\u0026gt; high(n), low(n); vector\u0026lt;pii\u0026gt; vec; for (int i = 0; i \u0026lt; n; i++) { vec.emplace_back(i, arr[i]); } sort(vec.begin(), vec.end(), [](pii \u0026amp;a, pii \u0026amp;b) { return a.second == b.second? a.first \u0026lt; b.first: a.second \u0026lt; b.second; }); stack\u0026lt;int\u0026gt; s; for (int i = 0; i \u0026lt; n; i++) { while (!s.empty() \u0026amp;\u0026amp; s.top() \u0026lt; vec[i].first) { high[s.top()] = vec[i].first; s.pop(); } s.push(vec[i].first); } while (!s.empty()) { high[s.top()] = n; s.pop(); } sort(vec.begin(), vec.end(), [](pii \u0026amp;a, pii \u0026amp;b) { return a.second == b.second? a.first \u0026lt; b.first: a.second \u0026gt; b.second; }); for (int i = 0; i \u0026lt; n; i++) { while (!s.empty() \u0026amp;\u0026amp; s.top() \u0026lt; vec[i].first) { low[s.top()] = vec[i].first; s.pop(); } s.push(vec[i].first); } while (!s.empty()) { low[s.top()] = n; s.pop(); } vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;bool\u0026gt;(2, false)); dp[n - 1][0] = true; dp[n - 1][1] = true; for (int i = n - 2; i \u0026gt;= 0; i--) { dp[i][0] = dp[high[i]][1]; dp[i][1] = dp[low[i]][0]; } int ans = 0; for (int i = 0; i \u0026lt; n; i++) { ans += dp[i][0]; } return ans; } }; ","date":"13 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-975-%E5%A5%87%E5%81%B6%E8%B7%B3/","section":"Posts","summary":"LeetCode-975 奇偶跳 # Solution 1 # 本题的关键在于怎么找到每个元素的后继.","title":"LeetCode-975 奇偶跳"},{"content":"LeetCode-879 盈利计划 # Solution 1 # 枚举所有可能的情况. 记 $dp[i][j][k]$ 为有 $i$ 个员工, 可选任务从 $j$ 开始, 还需盈利 $k$ 的方案数. 状态转移方程如下: $$ dp[i][j][k] = \\begin{cases} dp[i][j + 1][k], \\ if\\ group[j] \u0026gt; i\\ dp[i - group[j]][j + 1][k - profit[j]],\\ otherwise \\end{cases} $$ 我们可以用记忆化搜索来替代递推过程. 代码如下:\n#define ll long long class Solution { public: const int MOD = 1e9 + 7; int m; int dp[110][110][110]; vector\u0026lt;int\u0026gt; _group, _profit; int f(int n, int i, int p) { if (i == m \u0026amp;\u0026amp; p \u0026lt;= 0) { return 1; } if (i == m \u0026amp;\u0026amp; p \u0026gt; 0) { return 0; } if (dp[n][i][p] != -1) { return dp[n][i][p]; } dp[n][i][p] = 0; if (n - _group[i] \u0026gt;= 0) { int np = (p \u0026gt;= _profit[i])? p - _profit[i]: 0; dp[n][i][p] = f(n - _group[i], i + 1, np); } dp[n][i][p] = (dp[n][i][p] + f(n, i + 1, p)) % MOD; return dp[n][i][p]; } int profitableSchemes(int n, int minProfit, vector\u0026lt;int\u0026gt;\u0026amp; group, vector\u0026lt;int\u0026gt;\u0026amp; profit) { for (int i = 0; i \u0026lt; 110; i++) { for (int j = 0; j \u0026lt; 110; j++) { for (int k = 0; k \u0026lt; 110; k++) { dp[i][j][k] = -1; } } } m = group.size(); _group = group; _profit = profit; return f(n, 0, minProfit); } }; ","date":"13 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-879-%E7%9B%88%E5%88%A9%E8%AE%A1%E5%88%92/","section":"Posts","summary":"LeetCode-879 盈利计划 # Solution 1 # 枚举所有可能的情况.","title":"LeetCode-879 盈利计划"},{"content":"LeetCode-854 相似度为 K 的字符串 # Solution 1 # 一次交换至少应该匹配一个字符, 如果能匹配两个字符就一定是最优的. 基于这种贪心思想我们用广度优先搜索来寻找最小的 $k$ . 代码如下:\nclass Solution { public: string swap(int i, int j, string s) { char temp = s[i]; s[i] = s[j]; s[j] = temp; return s; } int kSimilarity(string s1, string s2) { int n = s1.size(); queue\u0026lt;string\u0026gt; q; q.push(s1); if (s1 == s2) { return 0; } int ans = 0; while (!q.empty()) { ans++; int k = q.size(); while (k--) { string s = q.front(); q.pop(); int idx = -1; char target; for (int i = ans - 1; i \u0026lt; n; i++) { if (s[i] != s2[i]) { idx = i; target = s2[i]; break; } } for (int i = idx + 1; i \u0026lt; n; i++) { if (s[i] == target) { string res = swap(idx, i, s); if (res == s2) { return ans; } q.push(res); if (s[idx] == s2[i]) { break; } } } } } return 0; } }; ","date":"13 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-854-%E7%9B%B8%E4%BC%BC%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Posts","summary":"LeetCode-854 相似度为 K 的字符串 # Solution 1 # 一次交换至少应该匹配一个字符, 如果能匹配两个字符就一定是最优的.","title":"LeetCode-854 相似度为 K 的字符串"},{"content":"LeetCode-765 情侣牵手 # Solution 1 # 贪心, 遇到不匹配的就交换. 代码如下:\nclass Solution { public: int minSwapsCouples(vector\u0026lt;int\u0026gt;\u0026amp; row) { int n = row.size(); map\u0026lt;int, int\u0026gt; idx; for (int i = 0; i \u0026lt; n; i++) { idx[row[i]] = i; } int ans = 0; for (int i = 0; i \u0026lt; n; i += 2) { if (row[i] / 2 != row[i + 1] / 2) { int id = (row[i] % 2 == 0)? idx[row[i] + 1]: idx[row[i] - 1]; idx[row[i + 1]] = id; row[id] = row[i + 1]; ans++; } } return ans; } }; Solution 2 # 同一对情侣的编号除以 $2$ 之后相同, 不妨把这个数看作情侣对的编号. 考虑 $\\frac{n}{2}$ 个情侣节点, 如果存在 $2k, 2k + 1$ 的位置上是不同对的情侣, 就连一条边. 最终图中节点一定分成了若干个环. 一个长度为 $len$ 的环需要 $len - 1$ 次交换才能分开. 最终需要的次数 $= \\sum_{i = 1}^{t})(len_i - 1) = \\frac{n}{2} - t$ . 具体实现时, 我们利用并查集来处理环的结构. 最终 $i = pa[i]$ 的节点就是一个环. 代码如下:\nclass Solution { public: int pa[70]; void init() { for (int i = 0; i \u0026lt; 70; i++) { pa[i] = i; } } int find(int x) { if (pa[x] == x) { return x; } pa[x] = find(pa[x]); return pa[x]; } void merge(int x, int y) { pa[find(y)] = find(x); } int minSwapsCouples(vector\u0026lt;int\u0026gt;\u0026amp; row) { init(); int n = row.size(); for (int i = 0; i \u0026lt; n; i += 2) { merge(row[i] / 2, row[i + 1] / 2); } int cnt = 0; for (int i = 0; i \u0026lt; n / 2; i++) { if (i == find(i)) { cnt++; } } return n / 2 - cnt; } }; ","date":"12 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-765-%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/","section":"Posts","summary":"LeetCode-765 情侣牵手 # Solution 1 # 贪心, 遇到不匹配的就交换.","title":"LeetCode-765 情侣牵手"},{"content":"CodeForces-1168A Increasing by Modulo # 题目大意 # 给定正整数 $n, m$ 和长度为 $n$ 的数组 $a$ . 每次操作中, 你可以选择数组的一些元素, 将元素 $x$ 变为 $(x + 1)%m$ . 求让数组变为单调不减数组的最少操作次数.\nSolution 1 # 如果 $k$ 次操作可行, 那么 $k + 1$ 次操作一定也可行. 基于这一点我们可以二分搜索 $k$ . 从数据范围可以看出, $check$ 函数应当在线性时间内检验 $k$ 是否满足要求, 因此我们考虑贪心, 尽可能让结尾的数字最小. 注意到 $k$ 是对整个数组操作 $k$ 次, 对于每个元素, 我们分别可以操作 $k$ 次. 如果 $a[i] \u0026gt; a[i - 1]$ , 假设 $a[i]$ 能在 $k$ 次操作内到达 $a[i - 1]$ , 那么就变为 $a[i - 1]$ , 否则保留 $a[i]$ ; 如果 $a[i] = a[i - 1]$ , 保留 $a[i - 1]$ ; 如果 $a[i] \u0026lt; a[i - 1]$ , 尽可能增加到 $a[i - 1]$ , 如果不能, 则返回 false . 基于贪心我们找到了一个 $O(n)$ 时间的检验函数, 整体复杂度 $O(nlogm)$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, m; bool check(vector\u0026lt;int\u0026gt; a, int k) { a[0] = ((0 + m - a[0]) % m \u0026lt;= k)? 0: a[0]; for (int i = 1; i \u0026lt; n; i++) { if (a[i] \u0026gt; a[i - 1]) { a[i] = ((a[i - 1] + m - a[i]) % m \u0026lt;= k)? a[i - 1]: a[i]; } else if (a[i] == a[i - 1]) { continue; } else if (a[i] \u0026lt; a[i - 1]) { if (a[i - 1] - a[i] \u0026lt;= k) { a[i] = a[i - 1]; } else { return false; } } } return true; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } int left = 0, right = m; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (check(a, mid)) { right = mid; } else { left = mid + 1; } } cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;endl; return 0; } ","date":"12 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1168a-increasing-by-modulo/","section":"Posts","summary":"CodeForces-1168A Increasing by Modulo # 题目大意 # 给定正整数 $n, m$ 和长度为 $n$ 的数组 $a$ .","title":"CodeForces-1168A Increasing by Modulo"},{"content":"CodeForces-371D Vessels # 题目大意 # 有 $n$ 个从上到下摆放的容器, 每个容器的容量为 $a_i$ . 一个容器中溢出的水会流到下一个容器中, 最后一个容器的水则会流到地上. 有 $m$ 次倒水和查询的操作, 输出结果.\nSolution 1 # 我们需要快速地找到每个容器后面一个可行的容器是什么, 注意到连续的盛满水的容器可以看作一组, 我们可以使用并查集来记录. 记 $pa[i] + 1$ 为 $i$ 之后第一个非空的容器. 每次加水, 如果 $i$ 满了, 就将 $i - 1$ 的父节点设为 $i$ 的父节点( $i$ 上面的容器一定会流到 $i - 1$ , $i - 1$ 也会先流到 $i$), 同时继续考虑 $i = pa[i] + 1$ . 这种操作下满了的容器不会再被考虑到, 总体复杂度为 $O(m + n)$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int pa[200010]; void init(int n){ for(int i = 1; i \u0026lt;= n + 1; i++){ pa[i] = i; //存放每个结点的结点（或双亲结点） } } int find(int i) { if (pa[i] == i) { return i; } else { pa[i] = find(pa[i]); return pa[i]; } } void merge(int i, int j) { pa[find(j)] = find(i); } int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n + 2, 0), b(n + 2, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } int m; cin\u0026gt;\u0026gt;m; init(n); while (m--) { int type; cin\u0026gt;\u0026gt;type; if (type == 1) { int p, x; cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;x; b[p] += x; while (p \u0026lt;= n \u0026amp;\u0026amp; b[p] \u0026gt; a[p]) { merge(p, p - 1); int np = find(p) + 1; b[np] += b[p] - a[p]; b[p] = a[p]; p = np; } } else { int k; cin\u0026gt;\u0026gt;k; cout\u0026lt;\u0026lt;b[k]\u0026lt;\u0026lt;endl; } } return 0; } ","date":"12 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-371d-vessels/","section":"Posts","summary":"CodeForces-371D Vessels # 题目大意 # 有 $n$ 个从上到下摆放的容器, 每个容器的容量为 $a_i$ .","title":"CodeForces-371D Vessels"},{"content":"LeetCode-517 超级洗衣机 # Solution 1 # 记平均衣服数为 $avg$ . 考虑洗衣机的 \u0026ldquo;流量\u0026rdquo; . 对于每台洗衣机, 因为一次操作中至多减少一件衣服, 而可能加上多件衣服, 所以我们考虑衣服过多的洗衣机的流量, 至少是 $machines[i] - avg$ . 与此同时, 对于左侧的洗衣机, 如果多出来了一定要流向右侧, 因此我们还要统计左右洗衣机组的衣服差. $ans$ 由两者间的最大值决定. 贪心算法正确性的证明见 【刷穿 LeetCode】517. 超级洗衣机 : 详解为何能取到理论最小操作次数 . 代码如下:\nclass Solution { public: int findMinMoves(vector\u0026lt;int\u0026gt;\u0026amp; machines) { int n = machines.size(); int sum = 0; for (int v: machines) { sum += v; } if (sum % n != 0) { return -1; } int ans = 0; int res = 0; for (int i = 0; i \u0026lt; n; i++) { machines[i] -= sum / n; res += machines[i]; ans = max(ans, max(machines[i], abs(res))); } return ans; } }; ","date":"12 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-517-%E8%B6%85%E7%BA%A7%E6%B4%97%E8%A1%A3%E6%9C%BA/","section":"Posts","summary":"LeetCode-517 超级洗衣机 # Solution 1 # 记平均衣服数为 $avg$ .","title":"LeetCode-517 超级洗衣机"},{"content":"LeetCode-2397 被列覆盖的最多行数 # Solution 1 # 数据范围很小, 我们枚举选择列的情况, 用一个数的二进制来表示选择了哪些列, 不断更新 $ans$ . 代码如下:\nclass Solution { public: int maximumRows(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; mat, int cols) { int m = mat.size(); int n = mat[0].size(); // 从 n 行里取出cols int ans = 0; for (int i = (1 \u0026lt;\u0026lt; (n + 1)) - 1; i \u0026gt;= 1; i--) { // 至多选择 n 列, 至少选择 1 列 if (__builtin_popcount(i) != cols) { continue; // 枚举的列数不为 cols 直接跳过 } set\u0026lt;int\u0026gt; book; // 记录选择了哪些列 for (int j = 0; j \u0026lt; n; j++) { if (i \u0026amp; (1 \u0026lt;\u0026lt; j)) { book.insert(j); } } int cnt = 0; for (int x = 0; x \u0026lt; m; x++) { // 遍历行, 统计被覆盖的行数 bool isValid = true; for (int y = 0; y \u0026lt; n \u0026amp;\u0026amp; isValid; y++) { if (mat[x][y] == 1) { if (!book.count(y)) { isValid = false; } } } if (isValid) { cnt++; } } ans = max(ans, cnt); } return ans; } }; ","date":"12 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2397-%E8%A2%AB%E5%88%97%E8%A6%86%E7%9B%96%E7%9A%84%E6%9C%80%E5%A4%9A%E8%A1%8C%E6%95%B0/","section":"Posts","summary":"LeetCode-2397 被列覆盖的最多行数 # Solution 1 # 数据范围很小, 我们枚举选择列的情况, 用一个数的二进制来表示选择了哪些列, 不断更新 $ans$ .","title":"LeetCode-2397 被列覆盖的最多行数"},{"content":"LeetCode-857 雇佣 K 名工人的最低成本 # Solution 1 # 定义价性比为 $\\frac{wage[i]}{quality[i]}$. 根据题意可以知道, $k$ 个工人的总工资由最高的价性比乘以全组质量之和. 因此我们从低到高枚举价性比, 同时用一个优先队列维护当前前 $k$ 小的 $quality$ . 代码如下:\nclass Solution { public: typedef pair\u0026lt;double, int\u0026gt; pdi; double mincostToHireWorkers(vector\u0026lt;int\u0026gt;\u0026amp; quality, vector\u0026lt;int\u0026gt;\u0026amp; wage, int k) { int n = quality.size(); vector\u0026lt;pdi\u0026gt; avg_wage; for (int i = 0; i \u0026lt; n; i++) { double a_w = (double)wage[i] / (double)quality[i]; avg_wage.emplace_back(a_w, i); } sort(avg_wage.begin(), avg_wage.end()); double ans = 1e9; priority_queue\u0026lt;int\u0026gt; pq; int k_sum = 0; for (int i = 0; i \u0026lt; k; i++) { pq.push(quality[avg_wage[i].second]); k_sum += quality[avg_wage[i].second]; } ans = k_sum * avg_wage[k - 1].first; for (int i = k; i \u0026lt; n; i++) { if (pq.top() \u0026gt; quality[avg_wage[i].second]) { k_sum = k_sum - pq.top() + quality[avg_wage[i].second]; pq.pop(); pq.push(quality[avg_wage[i].second]); ans = min(ans, avg_wage[i].first * k_sum); } } return ans; } }; ","date":"11 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-857-%E9%9B%87%E4%BD%A3-k-%E5%90%8D%E5%B7%A5%E4%BA%BA%E7%9A%84%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC/","section":"Posts","summary":"LeetCode-857 雇佣 K 名工人的最低成本 # Solution 1 # 定义价性比为 $\\frac{wage[i]}{quality[i]}$.","title":"LeetCode-857 雇佣 K 名工人的最低成本"},{"content":"LeetCode-664 奇怪的打印机 # Solution 1 # 记 $dp[i][j]$ 为打印 $s[i: j]$ 的最少次数. 首先打印首字母一定是最优的. 如果 $s[i] == s[j]$ , 那么打印 $s[i]$ 时可以顺便打印 $s[j]$ , 原问题与 $dp[i][j - 1]$ 一样. 否则, 我们需要把枚举分界点, 把这一段分成两段打印. 状态转移方程如下: $$ dp[i][j] = \\begin{cases} dp[i][j - 1],\\ s[i] = s[j]\\ \\underset{i\\leq k\u0026lt;j}{min}{dp[i][k] + dp[i + 1][j]},\\ s[i] \\not= s[j]\\ \\end{cases} $$ 代码如下:\nclass Solution { public: map\u0026lt;string, int\u0026gt; book; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; int n; string t = \u0026#34;\u0026#34;; int f(int l, int r) { if (l == r) { return 1; } if (l \u0026gt; r) { return 0; } if (dp[l][r] != 1e9) { return dp[l][r]; } int res = 1e9; for (int i = l; i \u0026lt;= r - 1; i++) { res = min(res, f(l, i) + f(i + 1, r)); } if (t[l] == t[r]) { res = min(res, f(l, r - 1) + 1); } dp[l][r] = res; cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34;, \u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;\u0026#34;: \u0026#34;\u0026lt;\u0026lt;t.substr(l, r - l + 1)\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return res; } int strangePrinter(string s) { for (char ch: s) { if (t.size() == 0 || t[t.size() - 1] != ch) { t.push_back(ch); } } cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; n = t.size(); dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; (n, vector\u0026lt;int\u0026gt;(n, 1e9)); return f(0, n - 1); } }; ","date":"8 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-664-%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/","section":"Posts","summary":"LeetCode-664 奇怪的打印机 # Solution 1 # 记 $dp[i][j]$ 为打印 $s[i: j]$ 的最少次数.","title":"LeetCode-664 奇怪的打印机"},{"content":"LeetCode-1793 好子数组的最大分数 # Solution 1 # 单调栈处理出以 $nums[i]$ 为最小值的左右边界, 枚举可能的情况即可. 代码如下:\nclass Solution { public: int maximumScore(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); stack\u0026lt;int\u0026gt; st; vector\u0026lt;int\u0026gt; left(n); for (int i = 0; i \u0026lt; n; i++) { while (!st.empty() \u0026amp;\u0026amp; nums[st.top()] \u0026gt;= nums[i]) { st.pop(); } left[i] = st.empty()? -1: st.top(); st.push(i); } st = stack\u0026lt;int\u0026gt;(); vector\u0026lt;int\u0026gt; right(n); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!st.empty() \u0026amp;\u0026amp; nums[st.top()] \u0026gt;= nums[i]) { st.pop(); } right[i] = st.empty()? n: st.top(); st.push(i); } int ans = 0; for (int i = 0; i \u0026lt; n; i++) { if (left[i] \u0026lt; k \u0026amp;\u0026amp; right[i] \u0026gt; k) { ans = max(ans, nums[i] * (right[i] - left[i] - 1)); } } return ans; } }; ","date":"8 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1793-%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/","section":"Posts","summary":"LeetCode-1793 好子数组的最大分数 # Solution 1 # 单调栈处理出以 $nums[i]$ 为最小值的左右边界, 枚举可能的情况即可.","title":"LeetCode-1793 好子数组的最大分数"},{"content":"LeetCode-667 优美的排列 II # Solution 1 # 对于 $1, 2, \u0026hellip;, n$ , 要求构造出 $k$ 个差值, 我们不妨直接取 $1, 2, \u0026hellip;, k$ 这 $k$ 个差值. 先构造出最大的, 把 $n$ 插入到 $n - k$ 和 $n - k + 1$ 中间, 则数组转化为 $1, \u0026hellip;, n - k, n, n - k + 1, \u0026hellip;, n - 1$ , 已经拥有了 $k$ 和 $k - 1$ 这两个差值. 对于 $n - k + 1, \u0026hellip;, n - 1$ 这个数组, 有 $k - 1$ 个连续元素, 需要构造出 $1, 2, \u0026hellip;, k - 2$ 这 $k - 2$ 个差值, 很明显是一个规模更小的子问题. 注意到我们的构造方式不会影响变动数组首元素的位置, 所以后续构造对前面没有影响. 递归地构造即可. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; ans; // 连续元素构造, start, start + 1, ..., end, 构造出 num 个差值 void constructAns(int start, int end, int num) { if (num \u0026lt; 0) { // 递归终点 return; } for (int i = start; i \u0026lt;= end - num; i++) { ans.push_back(i); } if (num != 0) { // num == 0 时, start end 相同, 不需要再加入 end ans.push_back(end); } // 规模更小的子问题 constructAns(end - num + 1, end - 1, num - 2); return; } vector\u0026lt;int\u0026gt; constructArray(int n, int k) { constructAns(1, n, k); return ans; } }; Solution 2 # 找规律, 前面部分差值为 $1$ , 后面部分大小交替, 差值从 $k$ 递减到 $1$ , 即 $[1, 2, ⋯, n−k, n, n−k+1, n−1, n−k+2, ⋯]$\nclass Solution { public: vector\u0026lt;int\u0026gt; constructArray(int n, int k) { vector\u0026lt;int\u0026gt; answer; for (int i = 1; i \u0026lt; n - k; ++i) { answer.push_back(i); } for (int i = n - k, j = n; i \u0026lt;= j; ++i, --j) { answer.push_back(i); if (i != j) { answer.push_back(j); } } return answer; } }; ","date":"8 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-667-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/","section":"Posts","summary":"LeetCode-667 优美的排列 II # Solution 1 # 对于 $1, 2, \u0026hellip;, n$ , 要求构造出 $k$ 个差值, 我们不妨直接取 $1, 2, \u0026hellip;, k$ 这 $k$ 个差值.","title":"LeetCode-667 优美的排列 II"},{"content":"LeetCode-410 分割数组的最大值 # Solution 1 # 记 $dp[i][j]$ 为 $0,\u0026hellip;,i$ 位元素分割成 $j$ 个非空连续子数组, 各子数组的元素和最大值的最小值. 对于 $dp[i][j]$ , 假设最后一段子数组为 $nums[k + 1], \u0026hellip;., nums[i]$ , 那么则有 $$ dp[i][j] = \\underset{j - 2\\leq k \u0026lt; i}{min}{max{dp[k][j - 1], \\sum_{k \u0026lt; t\\leq i}nums[t]}} $$ 代码如下:\nclass Solution { public: int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(m + 1, 1e9 + 10)); vector\u0026lt;int\u0026gt; pre(n, 0); for (int i = 0; i \u0026lt; n; i++) { pre[i] = (i == 0)? nums[i]: nums[i] + pre[i - 1]; } dp[0][1] = nums[0]; for (int i = 1; i \u0026lt; n; i++) { dp[i][1] = pre[i]; for (int j = 2; j \u0026lt;= m; j++) { for (int k = i - 1; k \u0026gt;= j - 2; k--) { dp[i][j] = min(dp[i][j], max(dp[k][j - 1], pre[i] - pre[k])); } } } return dp[n - 1][m]; } }; Solution 2 # 对于一个上界 $k$ , 我们可以在线性时间内验证是否存在合法的划分, 二分搜索这个上界即可. 代码如下:\nclass Solution { public: bool check(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m, int k) { int cnt = 1; int res = 0; for (auto num: nums) { if (res + num \u0026gt; k) { res = num; if (res \u0026gt; k) { return false; } cnt++; } else { res += num; } } return (cnt \u0026lt;= m); } int splitArray(vector\u0026lt;int\u0026gt;\u0026amp; nums, int m) { int n = nums.size(); int left = 0; int right = 1; for (auto num: nums) { right += num; } while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (check(nums, m, mid)) { right = mid; } else { left = mid + 1; } } return left; } }; ","date":"6 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-410-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","section":"Posts","summary":"LeetCode-410 分割数组的最大值 # Solution 1 # 记 $dp[i][j]$ 为 $0,\u0026hellip;,i$ 位元素分割成 $j$ 个非空连续子数组, 各子数组的元素和最大值的最小值.","title":"LeetCode-410 分割数组的最大值"},{"content":"LeetCode-330 按要求补齐数组 # Solution 1 # 如果能覆盖 $[1, x - 1]$ 中的数, 而不能覆盖 $x$ , 那么加上 $x$ 之后一定能够覆盖 $[1, 2x - 1]$ 中的数, 并且这是最优的. 我们要做的就是不断寻找第一个覆盖不到的 $x$ . 如果 $nums[0, \u0026hellip;, i - 1]$ 可以覆盖 $[1, x - 1]$ , 考虑 $nums[i]$ , 如果 $nums[i] \u0026lt;= x$ , 那么 $nums[0, \u0026hellip;, i]$ 可以覆盖 $1, x + nums[i] - 1]$ ; 如果 $nums[i] \u0026gt; x$ , 那么需要补充 $x$ , 覆盖 $[1, 2x - 1]$ . 代码如下:\nclass Solution { public: int minPatches(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n) { int ans = 0; long long x = 1; int idx = 0; while (x \u0026lt;= n) { if (idx \u0026lt; nums.size() \u0026amp;\u0026amp; nums[idx] \u0026lt;= x) { x += nums[idx]; idx++; } else { x *= 2; ans++; } } return ans; } }; ","date":"6 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84/","section":"Posts","summary":"LeetCode-330 按要求补齐数组 # Solution 1 # 如果能覆盖 $[1, x - 1]$ 中的数, 而不能覆盖 $x$ , 那么加上 $x$ 之后一定能够覆盖 $[1, 2x - 1]$ 中的数, 并且这是最优的.","title":"LeetCode-330 按要求补齐数组"},{"content":"LeetCode-828 统计子串中的唯一字符 # Solution 1 # 采用贡献法, 考虑每一个字符在多少个子字符串只出现了一次. 统计每种字符出现的下标, 应用乘法原理即可. 代码如下:\nclass Solution { public: int uniqueLetterString(string s) { int n = s.size(); int ans = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cnt(26, vector\u0026lt;int\u0026gt;(1, -1)); for (int i = 0; i \u0026lt; n; i++) { cnt[s[i] - \u0026#39;A\u0026#39;].push_back(i); } for (int i = 0; i \u0026lt; 26; i++) { cnt[i].push_back(n); for (int j = 1; j \u0026lt; cnt[i].size() - 1; j++) { ans += (cnt[i][j] - cnt[i][j - 1]) * (cnt[i][j + 1] - cnt[i][j]); } } return ans; } }; ","date":"6 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-828-%E7%BB%9F%E8%AE%A1%E5%AD%90%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","section":"Posts","summary":"LeetCode-828 统计子串中的唯一字符 # Solution 1 # 采用贡献法, 考虑每一个字符在多少个子字符串只出现了一次.","title":"LeetCode-828 统计子串中的唯一字符"},{"content":"LeetCode-312 戳气球 # Solution 1 # 把编号 $0, 1, \u0026hellip;, n - 1$ 的气球编号修改成 $1, 2, \u0026hellip;, n$ , 同时补上 $0$ 和 $n + 1$ 两个边界的虚拟气球 (值视为 $1$) . 对于每个开区间 $(i, j)$ , 记戳完区间内所有气球的最高得分为 $f(i, j)$, 考虑其最后一个被戳掉的气球, 假设为 $k$ , 则有 $$ f(i, j) = \\underset{i \u0026lt; k \u0026lt; j}{max}{f(i, k) + f(k, j) + val[i]\\times val[k]\\times val[j]} $$ $f(0, n + 1)$ 就是我们要求的答案. 代码如下:\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp; vector\u0026lt;int\u0026gt; a; int f(int i, int j) { if (dp[i][j] != -1) { return dp[i][j]; } int res = 0; for (int k = i + 1; k \u0026lt; j; k++) { res = max(res, f(i, k) + f(k, j) + a[i] * a[k] * a[j]); } dp[i][j] = res; return res; } int maxCoins(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); a = vector\u0026lt;int\u0026gt;(n + 2, 1); for (int i = 1; i \u0026lt;= n; i++) { a[i] = nums[i - 1]; } dp = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n + 2, vector\u0026lt;int\u0026gt;(n + 2, -1)); return f(0, n + 1); } }; ","date":"5 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-312-%E6%88%B3%E6%B0%94%E7%90%83/","section":"Posts","summary":"LeetCode-312 戳气球 # Solution 1 # 把编号 $0, 1, \u0026hellip;, n - 1$ 的气球编号修改成 $1, 2, \u0026hellip;, n$ , 同时补上 $0$ 和 $n + 1$ 两个边界的虚拟气球 (值视为 $1$) .","title":"LeetCode-312 戳气球"},{"content":"LeetCode-403 青蛙过河 # Solution 1 # 青蛙的状态有两个, 在第 $i$ 个石头上, 最后一步跳了 $j$ 步. 我们用 $dp[i][j]$ 来记录是否能够到达这一状态. 假设 $dp[i][j]$ 可以从第 $k$ 块石头转移而来, 那么必须是 $dp[k][stones[i] - stones[j] - 1], dp[k][stones[i] - stones[j]], dp[k][stones[i] - stones[j] + 1]$ 之一. 线性递推即可. 个别可以优化的点见代码. 代码如下:\nclass Solution { public: bool canCross(vector\u0026lt;int\u0026gt;\u0026amp; stones) { int n = stones.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, false)); dp[0][0] = true; for (int i = 1; i \u0026lt; n; i++) { if (stones[i] - stones[i - 1] \u0026gt; i) { return false; } } for (int i = 1; i \u0026lt; n; i++) { for (int j = i - 1; j \u0026gt;= 0; j--) { int k = stones[i] - stones[j]; if (k \u0026gt; j + 1) { break; } dp[i][k] = dp[j][k - 1] || dp[j][k] || dp[j][k + 1]; if (i == n - 1 \u0026amp;\u0026amp; dp[i][k]) { return true; } } } return false; } }; ","date":"5 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/","section":"Posts","summary":"LeetCode-403 青蛙过河 # Solution 1 # 青蛙的状态有两个, 在第 $i$ 个石头上, 最后一步跳了 $j$ 步.","title":"LeetCode-403 青蛙过河"},{"content":"LeetCode-502 IPO # Solution 1 # 当前拥有资本 $w$ , 下一步选择肯定是启动资本不超过 $w$ 的项目中利润最大的那一个. 每次先二分搜索找到所有可行项目存入优先队列中, 再取队首元素更新即可. 代码如下:\ntypedef pair\u0026lt;int, int\u0026gt; pii; class Solution { public: struct cmp1 { bool operator()(const pii \u0026amp;a, const pii \u0026amp;b) { return (a.second == b.second)? a.first \u0026lt; b.first: a.second \u0026lt; b.second; } }; int findMaximizedCapital(int k, int w, vector\u0026lt;int\u0026gt;\u0026amp; profits, vector\u0026lt;int\u0026gt;\u0026amp; capital) { vector\u0026lt;pii\u0026gt; projects; int n = profits.size(); for (int i = 0; i \u0026lt; n; i++) { projects.emplace_back(capital[i], profits[i]); } sort(projects.begin(), projects.end()); priority_queue\u0026lt;pii, vector\u0026lt;pii\u0026gt;, cmp1\u0026gt; pq; int idx = -1; while (k--) { int left = 0; int right = n; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (projects[mid].first \u0026lt;= w) { left = mid + 1; } else { right = mid; } } for (int i = idx + 1; i \u0026lt;= left - 1; i++) { pq.push(projects[i]); } idx = left - 1; if (pq.empty()) { break; } w += pq.top().second; pq.pop(); } return w; } }; ","date":"5 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-502-ipo/","section":"Posts","summary":"LeetCode-502 IPO # Solution 1 # 当前拥有资本 $w$ , 下一步选择肯定是启动资本不超过 $w$ 的项目中利润最大的那一个.","title":"LeetCode-502 IPO"},{"content":"LeetCode-301 删除无效的括号 # Solution 1 # 要求返回所有的可能结果, 同时要求删除步数最小, 所以使用深度优先搜索. 具体实现时, 模拟每一步可能的删除情况, 同时用一个 $set$ 去重. 代码如下:\nclass Solution { public: bool isValid(string s) { stack\u0026lt;char\u0026gt; st; for (auto ch: s) { if (ch == \u0026#39;(\u0026#39;) { st.push(ch); } else if (ch == \u0026#39;)\u0026#39;) { if (st.empty()) { return false; } st.pop(); } } return st.empty(); } vector\u0026lt;string\u0026gt; removeInvalidParentheses(string s) { set\u0026lt;string\u0026gt; book; queue\u0026lt;string\u0026gt; q; vector\u0026lt;string\u0026gt; ans; book.insert(s); q.push(s); if (isValid(s)) { ans.push_back(s); return ans; } while (!q.empty()) { int sz = q.size(); while (sz--) { string t = q.front(); cout\u0026lt;\u0026lt;t\u0026lt;\u0026lt;endl; q.pop(); book.erase(t); for (int i = 0; i \u0026lt; t.size(); i++) { if (t[i] != \u0026#39;(\u0026#39; \u0026amp;\u0026amp; t[i] != \u0026#39;)\u0026#39;) { continue; } string ns = \u0026#34;\u0026#34;; for (int j = 0; j \u0026lt; t.size(); j++) { if (j != i) { ns += t[j]; } } if (!book.count(ns)) { book.insert(ns); q.push(ns); if (isValid(ns)) { ans.push_back(ns); } } } } if (ans.size() != 0) { return ans; } } return ans; } }; ","date":"5 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-301-%E5%88%A0%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","section":"Posts","summary":"LeetCode-301 删除无效的括号 # Solution 1 # 要求返回所有的可能结果, 同时要求删除步数最小, 所以使用深度优先搜索.","title":"LeetCode-301 删除无效的括号"},{"content":"","date":null,"permalink":"/tags/%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"搜索"},{"content":"LeetCode-458 可怜的小猪 # Solution 1 # 一只小猪在 $m$ 轮实验下的状态共有 $m + 1$ 种: 第 $1$ 轮死, 第 $2$ 轮死, \u0026hellip;, 第 $m$ 轮死, 以及一直活着. 如果有 $k$ 只小猪, 那么在 $m$ 轮实验下的状态则共有 $(m + 1)^k$ 种. 我们对水桶进行编码, 如果不超过 $(m + 1)^k$ , 那么一定存在合法编码. 实际上用 $m + 1$ 进制即可, 每只小猪负责一位, 依次枚举即可. 代码如下:\nclass Solution { public: int poorPigs(int buckets, int minutesToDie, int minutesToTest) { int states = minutesToTest / minutesToDie + 1; int pigs = ceil(log(buckets) / log(states) - 1e-5); return pigs; } }; ","date":"3 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-458-%E5%8F%AF%E6%80%9C%E7%9A%84%E5%B0%8F%E7%8C%AA/","section":"Posts","summary":"LeetCode-458 可怜的小猪 # Solution 1 # 一只小猪在 $m$ 轮实验下的状态共有 $m + 1$ 种: 第 $1$ 轮死, 第 $2$ 轮死, \u0026hellip;, 第 $m$ 轮死, 以及一直活着.","title":"LeetCode-458 可怜的小猪"},{"content":"LeetCode-1717 删除子字符串的最大得分 # Solution 1 # 对字符串不断进行配对删除的操作可以通过栈模拟来快速实现. 本题中, 我们考虑 $ab$ 和 $ba$ 两种模式串, 优先匹配哪一种. 第一次匹配分高的, 第二次匹配分低的, 就能得到最高分. 代码如下:\nclass Solution { public: int maximumGain(string s, int x, int y) { string high, low; int high_score, low_score; if (x \u0026gt;= y) { high_score = x; low_score = y; high = \u0026#34;ab\u0026#34;; low = \u0026#34;ba\u0026#34;; } else { high_score = y; low_score = x; high = \u0026#34;ba\u0026#34;; low = \u0026#34;ab\u0026#34;; } string res = \u0026#34;\u0026#34;; int n = s.size(); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { if (res.size() != 0 \u0026amp;\u0026amp; res[res.size() - 1] == high[0] \u0026amp;\u0026amp; s[i] == high[1]) { ans += high_score; res.pop_back(); } else { res.push_back(s[i]); } } s = res; res = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; s.size(); i++) { if (res.size() != 0 \u0026amp;\u0026amp; res[res.size() - 1] == low[0] \u0026amp;\u0026amp; s[i] == low[1]) { ans += low_score; res.pop_back(); } else { res.push_back(s[i]); } } return ans; } }; ","date":"3 September 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1717-%E5%88%A0%E9%99%A4%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","section":"Posts","summary":"LeetCode-1717 删除子字符串的最大得分 # Solution 1 # 对字符串不断进行配对删除的操作可以通过栈模拟来快速实现.","title":"LeetCode-1717 删除子字符串的最大得分"},{"content":"LeetCode-1631 最小体力消耗路径 # Solution 1 # 如果最终答案是 $ans$ , 那么 $ans$ 所在路径中所有相邻格子的高度差的绝对值都不应该超过 $ans$ . 因此, 我们可以枚举 $ans$ 的可能大小, 通过广度优先搜索寻找一条到 $(m - 1, n - 1)$ 的路径. 如果路径存在, 那么尝试寻找更小的 $ans$ ; 如果路径不存在, 尝试寻找更大的 $ans$ . 这个过程可以使用二分搜索进一步优化. 代码如下:\ntypedef pair\u0026lt;int, int\u0026gt; pii; class Solution { public: const int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; int minimumEffortPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; heights) { int m = heights.size(); int n = heights[0].size(); int left = 0; int right = 1e6; int ans = 0; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); queue\u0026lt;pii\u0026gt; q; q.emplace(0, 0); visited[0][0] = true; while (!q.empty()) { auto [x, y] = q.front(); q.pop(); for (auto dir: dirs) { int nx = x + dir[0]; int ny = y + dir[1]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; m \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; abs(heights[nx][ny] - heights[x][y]) \u0026lt;= mid \u0026amp;\u0026amp; !visited[nx][ny]) { q.emplace(nx, ny); visited[nx][ny] = true; } } } if (visited[m - 1][n - 1]) { ans = mid; right = mid - 1; } else { left = mid + 1; } } return ans; } }; Solution 2 # 类似 Solution 1 的思考方式, 一条路径由满足共同性质的一些块构成, 不断放宽限制 (即增大寻找的 $ans$ ), 联通部分会越来越多, 直到形成一条合法路径为止. 这实际上就是一个并查集的模型. 不过这里的块不是点, 而是边 (显然单独一个点是没有什么性质的) . 代码如下:\nclass UnionFind { public: vector\u0026lt;int\u0026gt; parent; vector\u0026lt;int\u0026gt; size; int n; // 当前连通分量数目 int setCount; public: UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) { iota(parent.begin(), parent.end(), 0); } int findset(int x) { return parent[x] == x ? x : parent[x] = findset(parent[x]); } bool unite(int x, int y) { x = findset(x); y = findset(y); if (x == y) { return false; } if (size[x] \u0026lt; size[y]) { swap(x, y); } parent[y] = x; size[x] += size[y]; --setCount; return true; } bool connected(int x, int y) { x = findset(x); y = findset(y); return x == y; } }; class Solution { public: int minimumEffortPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; heights) { int m = heights.size(); int n = heights[0].size(); vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt; edges; for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { int id = i * n + j; if (i \u0026gt; 0) { edges.emplace_back(id - n, id, abs(heights[i][j] - heights[i - 1][j])); } if (j \u0026gt; 0) { edges.emplace_back(id - 1, id, abs(heights[i][j] - heights[i][j - 1])); } } } sort(edges.begin(), edges.end(), [](const auto\u0026amp; e1, const auto\u0026amp; e2) { auto\u0026amp;\u0026amp; [x1, y1, v1] = e1; auto\u0026amp;\u0026amp; [x2, y2, v2] = e2; return v1 \u0026lt; v2; }); UnionFind uf(m * n); int ans = 0; for (const auto [x, y, v]: edges) { uf.unite(x, y); if (uf.connected(0, m * n - 1)) { ans = v; break; } } return ans; } }; Solution 1 和 Solution 2 最有趣的地方在于, 不是寻找路径的过程中更新 \u0026ldquo;距离\u0026rdquo; (本题的距离很特殊, 实际上是由各个边自身的性质约束的) , 而是限定了约束再看能否找到一个合法路径.\nSolution 3 # 优先队列优化的 Dijkstra 算法. 代码如下:\nclass Solution { private: static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; public: int minimumEffortPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; heights) { int m = heights.size(); int n = heights[0].size(); auto tupleCmp = [](const auto\u0026amp; e1, const auto\u0026amp; e2) { auto\u0026amp;\u0026amp; [x1, y1, d1] = e1; auto\u0026amp;\u0026amp; [x2, y2, d2] = e2; return d1 \u0026gt; d2; }; priority_queue\u0026lt;tuple\u0026lt;int, int, int\u0026gt;, vector\u0026lt;tuple\u0026lt;int, int, int\u0026gt;\u0026gt;, decltype(tupleCmp)\u0026gt; q(tupleCmp); q.emplace(0, 0, 0); vector\u0026lt;int\u0026gt; dist(m * n, INT_MAX); dist[0] = 0; vector\u0026lt;int\u0026gt; seen(m * n); while (!q.empty()) { auto [x, y, d] = q.top(); q.pop(); int id = x * n + y; if (seen[id]) { continue; } if (x == m - 1 \u0026amp;\u0026amp; y == n - 1) { break; } seen[id] = 1; for (int i = 0; i \u0026lt; 4; ++i) { int nx = x + dirs[i][0]; int ny = y + dirs[i][1]; if (nx \u0026gt;= 0 \u0026amp;\u0026amp; nx \u0026lt; m \u0026amp;\u0026amp; ny \u0026gt;= 0 \u0026amp;\u0026amp; ny \u0026lt; n \u0026amp;\u0026amp; max(d, abs(heights[x][y] - heights[nx][ny])) \u0026lt; dist[nx * n + ny]) { dist[nx * n + ny] = max(d, abs(heights[x][y] - heights[nx][ny])); q.emplace(nx, ny, dist[nx * n + ny]); } } } return dist[m * n - 1]; } }; ","date":"31 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84/","section":"Posts","summary":"LeetCode-1631 最小体力消耗路径 # Solution 1 # 如果最终答案是 $ans$ , 那么 $ans$ 所在路径中所有相邻格子的高度差的绝对值都不应该超过 $ans$ .","title":"LeetCode-1631 最小体力消耗路径"},{"content":"","date":null,"permalink":"/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/","section":"Tags","summary":"","title":"最短路"},{"content":"LeetCode-44 通配符匹配 # Solution 1 # 本题类似 LeetCode-10 正则表达式匹配 , 不过更简单一点. 用 $dp[i][j]$ 记录 $s$ 的前 $i$ 个字符和 $p$ 的前 $j$ 字符的匹配情况. 如果 $p[j - 1] \\not = $ , 那么 $dp[i][j] = dp[i - 1][j - 1] \u0026amp; match(s[i - 1], p[j - 1])$ , 否则, $$ 可以继续匹配, 即从 $dp[i - 1][j]$ 转化而来; 也可以不参与匹配, 从 $dp[i][j - 1]$ 转化而来. 代码如下:\nclass Solution { public: bool isMatch(string s, string p) { int n = s.size(); int m = p.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;bool\u0026gt;(m + 1, false)); dp[0][0] = true; auto match = [\u0026amp;](int i, int j) { if (i == 0) { return false; } if (p[j - 1] == \u0026#39;?\u0026#39;) { return true; } return s[i - 1] == p[j - 1]; }; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (p[j - 1] == \u0026#39;*\u0026#39;) { dp[i][j] = (i == 0)? dp[i][j - 1]: dp[i - 1][j] + dp[i][j - 1]; } else { dp[i][j] = (i == 0)? match(i, j): dp[i - 1][j - 1] \u0026amp; match(i, j); } } } return dp[n][m]; } }; ","date":"30 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-44-%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/","section":"Posts","summary":"LeetCode-44 通配符匹配 # Solution 1 # 本题类似 LeetCode-10 正则表达式匹配 , 不过更简单一点.","title":"LeetCode-44 通配符匹配"},{"content":"LeetCode-42 接雨水 # Solution 1 # 一块地方承载的雨水量由自身高度和左侧最大高度、右侧最大高度共同决定. 用一次遍历计算出每一块两侧的最大高度, 再用一次遍历计算出 $ans$ . 代码如下:\nclass Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int ans = 0; int n = height.size(); vector\u0026lt;int\u0026gt; left(n, 0), right(n, 0); stack\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt; n; i++) { left[i] = max(left[i - 1], height[i - 1]); right[n - 1 - i] = max(right[n - i], height[n - i]); } for (int i = 0; i \u0026lt; n; i++) { if (left[i] \u0026gt;= height[i] \u0026amp;\u0026amp; right[i] \u0026gt;= height[i]) { ans += min(left[i], right[i]) - height[i]; } } return ans; } }; ","date":"30 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/","section":"Posts","summary":"LeetCode-42 接雨水 # Solution 1 # 一块地方承载的雨水量由自身高度和左侧最大高度、右侧最大高度共同决定.","title":"LeetCode-42 接雨水"},{"content":"LeetCode-2197 替换数组中的非互质数 # Solution 1 # 一个直接的想法是, 从左向右遍历, 再从右向左遍历, 不断合并, 直到数组不再改变为止. 代码如下:\n#define ll long long class Solution { public: vector\u0026lt;int\u0026gt; replaceNonCoprimes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int cnt = 1; while (1) { vector\u0026lt;int\u0026gt; res; int n = nums.size(); if (cnt % 2 == 1) { ll lcm = nums[0]; for (int i = 1; i \u0026lt; n; i++) { if (__gcd(lcm, (ll)nums[i]) == 1) { res.push_back(lcm); lcm = nums[i]; } else { lcm = lcm * nums[i] / __gcd(lcm, (ll)nums[i]); } } res.push_back(lcm); nums = res; } else { ll lcm = nums[n - 1]; for (int i = n - 2; i \u0026gt;= 0; i--) { if (__gcd(lcm, (ll)nums[i]) == 1) { res.push_back(lcm); lcm = nums[i]; } else { lcm = lcm * nums[i] / __gcd(lcm, (ll)nums[i]); } } res.push_back(lcm); nums.clear(); for (int i = res.size() - 1; i \u0026gt;= 0; i--) { nums.push_back(res[i]); } } if (nums.size() == n) { return nums; } cnt++; } } }; Solution 2 # 对于这种与两侧元素交互的数组修改问题, 可以考虑使用栈来处理. 从左至右遍历元素, 每次取出栈顶进行合并直到不能合并为止. 最终栈中的元素就是答案. 代码如下:\n#define ll long long class Solution { public: vector\u0026lt;int\u0026gt; replaceNonCoprimes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { stack\u0026lt;int\u0026gt; st; for (int \u0026amp;num: nums) { while (!st.empty() \u0026amp;\u0026amp; __gcd(st.top(), num) != 1) { num = (ll)num * st.top() / __gcd(st.top(), num); st.pop(); } st.push(num); } vector\u0026lt;int\u0026gt; ans(st.size()); for (int i = ans.size() - 1; i \u0026gt;= 0; i--) { ans[i] = st.top(); st.pop(); } return ans; } }; ","date":"30 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2197-%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9D%9E%E4%BA%92%E8%B4%A8%E6%95%B0/","section":"Posts","summary":"LeetCode-2197 替换数组中的非互质数 # Solution 1 # 一个直接的想法是, 从左向右遍历, 再从右向左遍历, 不断合并, 直到数组不再改变为止.","title":"LeetCode-2197 替换数组中的非互质数"},{"content":"LeetCode-654 最大二叉树 # Solution 1 # 对于数组中的每个元素, 都有一个树节点, 左子树存放左侧最大的树节点, 右子树存放右侧最大的树节点. 使用单调栈来处理. 栈空或当前元素比栈顶小时入栈, 否则出栈至满足前者为止, 一边出栈一边把出栈元素所在节点更新为当前元素的左孩子. 处理完之后如果栈不为空, 那么说明左侧有更大的节点, 当前节点更新为该节点的右孩子. 代码如下:\nclass Solution { public: TreeNode* constructMaximumBinaryTree(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;int\u0026gt; stk; vector\u0026lt;TreeNode*\u0026gt; tree(n); for (int i = 0; i \u0026lt; n; ++i) { tree[i] = new TreeNode(nums[i]); while (!stk.empty() \u0026amp;\u0026amp; nums[i] \u0026gt; nums[stk.back()]) { tree[i]-\u0026gt;left = tree[stk.back()]; stk.pop_back(); } if (!stk.empty()) { tree[stk.back()]-\u0026gt;right = tree[i]; } stk.push_back(i); } return tree[stk[0]]; } }; ","date":"30 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","section":"Posts","summary":"LeetCode-654 最大二叉树 # Solution 1 # 对于数组中的每个元素, 都有一个树节点, 左子树存放左侧最大的树节点, 右子树存放右侧最大的树节点.","title":"LeetCode-654 最大二叉树"},{"content":"","date":null,"permalink":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/","section":"Tags","summary":"","title":"二叉树"},{"content":"LeetCode AutoX 安途智行专场竞赛 # Problem 1 网页瀑布流 # 题目链接 # AutoX-1. 网页瀑布流\nSolution 1 # 贪心, 用优先队列维护列的高度. 代码如下:\nclass Solution { public: int getLengthOfWaterfallFlow(int num, vector\u0026lt;int\u0026gt;\u0026amp; block) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; int n = block.size(); int ans = 0; for (int i = 0; i \u0026lt; min(num, n); i++) { pq.push(block[i]); } for (int i = min(num, n); i \u0026lt; n; i++) { int top = pq.top(); pq.pop(); pq.push(top + block[i]); } while (!pq.empty()) { ans = max(ans, pq.top()); pq.pop(); } return ans; } }; Problem 2 蚂蚁王国的蜂蜜 # 题目链接 # AutoX-2. 蚂蚁王国的蜂蜜\nSolution 1 # 用哈希表维护数据即可.\nclass Solution { public: vector\u0026lt;double\u0026gt; honeyQuotes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; handle) { vector\u0026lt;double\u0026gt; ans; int n = 0; map\u0026lt;int, int\u0026gt; book; for (auto h: handle) { int type = h[0]; if (type == 1) { book[h[1]]++; n++; } else if (type == 2) { book[h[1]]--; n--; if (book[h[1]] == 0) { book.erase(h[1]); } } else if (type == 3) { if (n == 0) { ans.push_back(-1.0); } else { double sum = 0; for (auto it = book.begin(); it != book.end(); it++) { sum += (it-\u0026gt;first) * (it-\u0026gt;second); } ans.push_back(sum / n); } } else if (type == 4) { if (n == 0) { ans.push_back(-1.0); } else { double sum = 0; for (auto it = book.begin(); it != book.end(); it++) { sum += (it-\u0026gt;first) * (it-\u0026gt;second); } sum = sum / n; double sum2 = 0; for (auto it = book.begin(); it != book.end(); it++) { sum2 += (it-\u0026gt;first - sum) * (it-\u0026gt;first - sum) * (it-\u0026gt;second); } ans.push_back(sum2 / n); } } } return ans; } }; Problem 3 # 题目链接 # 出行的最少购票费用\nSolution 1 # 用 $dp[i]$ 记录覆盖 $days[0], \u0026hellip;, days[i]$ 行程的最小费用. 考虑第 $i$ 个行程, 对于每一种 $ticket$ , 最优的选择是把 $ticket$ 的右侧与 $days[i]$ 重合以尽可能覆盖前面的行程, 并检查 ticket 往前第一个覆盖不到的 $days[j]$ , 则有 $$ dp[i] = \\underset{ticket\\in tickets}{min}dp[j] + ticket[1], j = max{k\\vert dp[i] + 1 - ticket[0] \u0026gt; dp[k]} $$ 代码如下:\n#define ll long long class Solution { public: long long minCostToTravelOnDays(vector\u0026lt;int\u0026gt;\u0026amp; days, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; tickets) { int n = days.size(); vector\u0026lt;ll\u0026gt; dp(n, 1e14); for (int i = 0; i \u0026lt; n; i++) { for (auto ticket: tickets) { int ped = ticket[0]; ll cost = ticket[1]; int j = lower_bound(days.begin(), days.end(), days[i] + 1 - ped) - days.begin(); dp[i] = min(dp[i], (j == 0)? cost: dp[j - 1] + cost); } } return dp[n - 1]; } }; Problem 4 # 题目链接 # 蚂蚁爬行\nSolution 1 # 并查集维护.\n","date":"29 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-autox-%E5%AE%89%E9%80%94%E6%99%BA%E8%A1%8C%E4%B8%93%E5%9C%BA%E7%AB%9E%E8%B5%9B/","section":"Posts","summary":"LeetCode AutoX 安途智行专场竞赛 # Problem 1 网页瀑布流 # 题目链接 # AutoX-1.","title":"LeetCode AutoX 安途智行专场竞赛"},{"content":"LeetCode-793 阶乘函数后 K 个零 # Solution 1 # 对于 $x!$ , 其中 $2$ 的因子一定不少于 $5$ 的因子, 因此 $k = x!$ 中因子 $5$ 的数量, 记为 $zeta(x)$ . 对于 $zeta(x)$ , 分别考虑 $1, 2, \u0026hellip;, x$ 中有 $1, 2, \u0026hellip;$ 个因子 $5$ 的数的个数, 则 $zeta(x) = \\lfloor\\frac{x}{5}\\rfloor + \\lfloor\\frac{x}{5^2}\\rfloor + \u0026hellip;$ . 因为 $zeta(x)$ 具有单调性, 我们二分搜索是否存在这样的 $x$ , 使得 $zeta(x) = k$ . 如果存在, 那么根据 $zeta(x)$ 的特征, 答案一定是 $5$ ; 否则答案是 $0$ . 代码如下:\n#define ll long long class Solution { public: int zeta(long long x) { int res = 0; while (x / 5 != 0) { res += x / 5; x /= 5; } return res; } int preimageSizeFZF(int k) { long long left = 0; long long right = 1e10; while (left \u0026lt;= right) { long long mid = left + (right - left) / 2; if (zeta(mid) \u0026lt; k) { left = mid + 1; } else if (zeta(mid) \u0026gt; k) { right = mid - 1; } else { return 5; } } return 0; } }; ","date":"28 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-793-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/","section":"Posts","summary":"LeetCode-793 阶乘函数后 K 个零 # Solution 1 # 对于 $x!","title":"LeetCode-793 阶乘函数后 K 个零"},{"content":"CodeForces-1611F ATM and Students # 题目大意 # 给定长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ 和一个数字 $s$ . 寻找 $a$ 最长的连续子数组 $b$ , 满足 $b$ 的任意前缀和均 $\u0026lt; -s$ . 如果 $b$ 存在, 输出其左右端点的下标; 否则输出 $-1$ .\nSolution 1 # 容易想到 $O(n^2)$ 的暴力做法, 枚举左端点, 对于每个左端点依次向右寻找右端点. 暴力解法中大量的实现耗费在了前缀和的反复计算上. 考虑优化这一点, 我们用 $sum$ 维护子数组的前缀和, 用 $r$ 记录子数组的右端点. 对于 $a[i]$ 开头的子数组, 如果 $a[i - 1]$ 开头的子数组不存在, 需要重新计算 $sum$ 和 $r$ . 否则, 如果 $a[i] \u0026gt;= 0$ , 那么一个正影响的元素从前缀和中被去除了, 向左缩小 $r$ ; 如果 $a[i] \u0026lt; 0$ , 那么一个负影响的元素从前缀和中被去除了, 向右扩大 $r$ . 期间维护最长的子数组长度以及对应下标即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;ll\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } int max_len = 0; int ans_l = 0; int ans_r = 0; int r = -1; ll sum = 0; for (int i = 1; i \u0026lt;= n; i++) { if (r \u0026lt; i - 1) { // 上一个没法作为开头, 重新计算 sum = 0; for (r = i; r \u0026lt;= n; r++) { sum += a[r]; if (sum \u0026lt; -s) { sum -= a[r]; r--; break; } } sum_idx = i; r = (r \u0026gt; n)? n: r; } else { // 如果上一个可以作为开头 if (a[i - 1] \u0026gt;= 0) { // 正值, 退格 sum -= a[i - 1]; for (; r \u0026gt;= i - 1; ) { if (sum \u0026lt; -s) { sum -= a[r]; r--; } else { break; } } continue; } else if (a[i - 1] \u0026lt; 0) { // 负值, 向右扩展 sum -= a[i - 1]; r++; for (; r \u0026lt;= n; r++) { sum += a[r]; if (sum \u0026lt; -s) { sum -= a[r]; r--; break; } } sum_idx = i; r = (r \u0026gt; n)? n: r; } } if (r - i + 1 \u0026gt; max_len) { max_len = r - i + 1; ans_l = i; ans_r = r; } } if (ans_r == 0) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;ans_l\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ans_r\u0026lt;\u0026lt;endl; } } return 0; } ","date":"26 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1611f-atm-and-students/","section":"Posts","summary":"CodeForces-1611F ATM and Students # 题目大意 # 给定长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ 和一个数字 $s$ .","title":"CodeForces-1611F ATM and Students"},{"content":"CodeForces-1249E By Elevator or Stairs? # 题目大意 # 有 $n$ 层楼, 从 $i$ 层楼到第 $i + 1$ 层楼可以走楼梯, 花费 $a_i$ 时间, 也可以坐电梯, 花费 $b_i$ 时间, 但是作一段路程的电梯需要固定时间费用 $c$ . 返回到 $1, 2, \u0026hellip;, n$ 各自需要的最短时间.\nSolution 1 # 第 $i$ 层楼到第 $i + 1$ 层楼, 如果选择走楼梯, 花费一定是 $a_i$ ; 如果选择坐电梯, 花费则与到达 $i$ 层楼的方式有关. 因此我们用 $dp[i][j]$ 代表到达 $i$ 层楼, 完成最后一段路程的方式为 $j$ 所需要的最少时间, 则状态转移方程如下: $$ \\begin{cases} dp[i][0] = min(dp[i - 1][0], dp[i - 1][1]) + a[i - 1]\\ dp[i][1] = min(dp[i - 1][0] + b[i - 1] + c, dp[i - 1][1] + b[i - 1]) \\end{cases} $$ 对于第 $i$ 层楼, $min(dp[i][0], dp[i][1])$ 就是所需的最少时间. 实际编写代码时可以用滚动数组优化. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int n, c; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c; vector\u0026lt;int\u0026gt; a(n, 0), b(n, 0); for (int i = 1; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } for (int i = 1; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;b[i]; } int l_a = 0, l_b = 0, n_a = 0, n_b = 0; for (int i = 0; i \u0026lt; n; i++) { n_a = (i == 0)? 0: min(l_a + a[i], l_b + a[i]); n_b = (i == 0)? c: min(l_a + b[i] + c, l_b + b[i]); cout\u0026lt;\u0026lt;min(n_a, n_b)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; l_a = n_a; l_b = n_b; } return 0; } ","date":"26 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1249e-by-elevator-or-stairs/","section":"Posts","summary":"CodeForces-1249E By Elevator or Stairs?","title":"CodeForces-1249E By Elevator or Stairs?"},{"content":"CodeForces-1325D Ehab the Xorcist # 题目大意 # 给定正整数 $u, v$ , 试构造长度最短的数组, 使得数组的元素的异或和为 $u$ , 加和为 $v$ ; 如果不存在合法构造, 输出 $-1$ .\nSolution 1 # 不难发现异或的两个性质:\n$x \\bigoplus y \\leq x + y$ $x \\bigoplus y\\equiv x + y\\ (mod\\ 2)$ 因此, 如果合法的构造存在, 一定有 $u\\leq v$ 与 $u\\equiv v\\ (mod\\ 2)$ . 事实上, 这也是个充分条件. 因为涉及到位运算, 我们从二进制的角度来考虑 $u, v$ , 可以通过把 $v$ 的一些高位拆分成低位来保证异或后的值与 $u$ 的对应位相同. 具体操作时, 用以下的贪心策略:\n如果 $v$ 第 $i$ 位 \u0026gt; $u$ 的第 $i$ 位, 那么把这一位取走 $1$ 向后拆; 如果 $v$ 第 $i$ 位 \u0026lt; $u$ 的第 $i$ 位, 那么向高位寻找第一个更大的位, 从这一位开始逐位向低位拆, 每次取走 $2$ 个. 因为 $u \\leq v$ , 所以第二个操作中符合要求的高位一定是存在的. 把 $v$ 的每一位进行拆分后, 假设位的最大值为 $k$ (可以证明, 经过上述操作, $k\\leq 3$) , 我们把 $u$ 拆分成 $k$ 个数即可. 此策略保证了这 $k$ 个数, 和为 $v$ , 每一位的异或和都与 $u$ 的对应位相同, 并且尽可能减少了位的最大值 (也就是最终构造的数组最短) , 因此是一个合法的策略.\n代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { ll u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; if (u \u0026gt; v || (u - v) \u0026amp; 1) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; return 0; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; cnt(2, vector\u0026lt;int\u0026gt;(63, 0)); for (int i = 0; i \u0026lt; 63; i++) { if (u \u0026amp; (ll)1 \u0026lt;\u0026lt; i) { cnt[0][i]++; } if (v \u0026amp; (ll)1 \u0026lt;\u0026lt; i) { cnt[1][i]++; } } for (int i = 59; i \u0026gt;= 1; i--) { if ((cnt[1][i] - cnt[0][i]) % 2 != 0) { if (cnt[1][i] \u0026lt; cnt[0][i]) { for (int j = i + 1; j \u0026lt; 63; j++) { if (cnt[1][j] \u0026gt; cnt[0][j]) { for (int k = j; k \u0026gt;= i + 1; k--) { cnt[1][k] -= 2; cnt[1][k - 1] += 4; } break; } } } cnt[1][i] -= 1; cnt[1][i - 1] += 2; } } vector\u0026lt;ll\u0026gt; ans; for (int i = 0; i \u0026lt;= 5; i++) { ll res = 0; for (int j = 0; j \u0026lt; 63; j++) { if (cnt[1][j] != 0) { res += (ll)1 \u0026lt;\u0026lt; j; cnt[1][j]--; } } if (res != 0) { ans.push_back(res); } } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for (auto a: ans) { cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 对于构造存在的情况, 我们考虑另外一种构造方式. 记 $d = v - u$ , 因为目标是把 $v$ 拆分成几部分, 异或和恰为 $u$ . 考虑直接把 $v$ 拆成 $u$ 加上一些和为 $d$ 的数, 只需要后面这一部分异或和为 $0$ 即可. 因为 $d$ 为偶数, 所以拆成 $v = u + \\frac{d}{2} + \\frac{d}{2}$ 就初步得到了一个构造. 还需要考虑的一点是, 如果 $u \u0026amp; \\frac{d}{2} = 0$ , 则 $u + \\frac{d}{2}$ 不会发生进位, 有 $(u + \\frac{d}{2}) \\bigoplus \\frac{d}{2} = u\\bigoplus \\frac{d}{2}\\bigoplus \\frac{d}{2}$ , 数组长度可以缩减成 $2$ . 注意一些情况的特判. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { ll u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; ll d = v - u; if (d \u0026lt; 0 || d \u0026amp; 1) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; return 0; } if (d == 0) { if (u == 0) { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;u\u0026lt;\u0026lt;endl; } } else { if (((d / 2) \u0026amp; u) == 0) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; ((d / 2) ^ u) \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d / 2 \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; 3 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; u \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d / 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; d / 2 \u0026lt;\u0026lt; endl; } } return 0; } ","date":"25 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1325d-ehab-the-xorcist/","section":"Posts","summary":"CodeForces-1325D Ehab the Xorcist # 题目大意 # 给定正整数 $u, v$ , 试构造长度最短的数组, 使得数组的元素的异或和为 $u$ , 加和为 $v$ ; 如果不存在合法构造, 输出 $-1$ .","title":"CodeForces-1325D Ehab the Xorcist"},{"content":"CodeForces-1368D AND, OR and square sum # 题目大意 # 给定长度为 $n$ 的数组 $a$ . 每次操作可以选择 $a_i, a_j$ , 令 $a_i = a_i \u0026amp; a_j, a_j = a_i | a_j$ . 返回任意次操作后能够得到的 $\\sum_{0\\leq i\u0026lt; n} a_i^2$ 的最大值.\nSolution 1 # 注意到 $a_i + a_j = a_i \u0026amp; a_j + a_i | a_j$ , 而后者的更不平均. 这意味着每次操作都会让两者的平方和不减. 事实上, 一次操作把 $a_i, a_j$ 二进制上的 $1$ 集中在了某个元素身上. 用类似冒泡排序的过程可以模拟一个得到目标数列的操作, 不过复杂度是 $O(n^2)$ , 不足以通过本题. 更合理的策略是直接遍历 $a$ , 存储每一位上共有多少个 $1$ , 再重新分配即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } vector\u0026lt;int\u0026gt; cnt(20, 0); for (auto t: a) { for (int i = 0; i \u0026lt; 20; i++) { if (t \u0026amp; 1 \u0026lt;\u0026lt; i) { cnt[i]++; } } } ll ans = 0; while (n--) { ll t = 0; for (int i = 0; i \u0026lt; 20; i++) { if (cnt[i] \u0026gt;= n + 1) { t += (1 \u0026lt;\u0026lt; i); } } ans += t * t; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1368d-and-or-and-square-sum/","section":"Posts","summary":"CodeForces-1368D AND, OR and square sum # 题目大意 # 给定长度为 $n$ 的数组 $a$ .","title":"CodeForces-1368D AND, OR and square sum"},{"content":"CodeForces-1217C The Number Of Good Substrings # 题目大意 # 给定 $01$ 字符串 $s$ , 求 $s$ 有多少个子串 $t$ 满足 $t$ 转化成十进制后的值与长度相等.\nSolution 1 # 先不考虑前导 $0$ . 由于子串 $t$ 的值是指数级增长的, 而 $t$ 的长度却是线性增长的. 这意味着在 $t$ 前面一般都需要一些前导 $0$ 来补足差距. 注意到前导 $0$ 的数量减少也不会影响 $t$ 的值, 所以我们贪心地寻找连续的一段 $0$ 的长度以最大化先导 $0$ 的个数, 记为 $cnt$ (这里的 $cnt$ 可以为 $0$ , 子串 $1$ 前面不需要前导 $0$ .) 从连续的这段 $0$ 开始, 逐步延长后继子串的长度 $len$ 的同时维护后继子串值 $res$ . 如果 $cnt + len \u0026gt;= res$ , 那么一定提供了一个合法的子串. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { string s; cin\u0026gt;\u0026gt;s; int n = s.size(); int ans = 0; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;0\u0026#39;) { cnt++; } else { int res = 0; for (int j = 0; (1 \u0026lt;\u0026lt; j) \u0026lt;= cnt + j + 1 \u0026amp;\u0026amp; i + j \u0026lt; n; j++) { res = res * 2 + (s[i + j] - \u0026#39;0\u0026#39;); if (res \u0026lt;= cnt + j + 1) { ans++; } } cnt = 0; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1217c-the-number-of-good-substrings/","section":"Posts","summary":"CodeForces-1217C The Number Of Good Substrings # 题目大意 # 给定 $01$ 字符串 $s$ , 求 $s$ 有多少个子串 $t$ 满足 $t$ 转化成十进制后的值与长度相等.","title":"CodeForces-1217C The Number Of Good Substrings"},{"content":"CodeForces-1582E Pchelyonok and Segments # 题目大意 # 给定长度为 $n$ 的数组 $a$ , 要求从 $a$ 中选取尽可能多的、互不相交的子数组, 记这些子数组数量一共有 $k$ 个, 它们需要满足:\n从左到右, 子数组长度分别为 $k, k - 1, \u0026hellip;, 1$ ; 从左到右, 子数组的元素和递增. 求 $k$ 的最大值.\nSolution 1 # 从左向右选, 第一个子数组的长度 $k$ 是不确定的, 不太方便. 不妨把 $a$ 反转, 这样要求变成了从左向右取, 长度递增, 元素和递减. 一个朴素的想法是, 每次取数组时, 在满足其它要求的情况下尽可能取元素和较大的, 这会使得下一步取数组变得简单一些. 基于这种想法, 我们考虑使用动态规划进行处理取数过程中的和. 记 $dp[i][j]$ 为前 $i + 1$ 个元素, 取了 $j$ 个子数组时最后一个数组和的最大值. 对于 $dp[i][j]$ , 它可以直接选择不取, 从 $dp[i - 1][j]$ 转化而来; 也可以选择取一个长度为 $j$ 的子数组, 从 $dp[i - j][j - 1]$ 转化而来. 状态转移方程如下: $$ dp[i][j] = \\begin{cases} max(dp[i - 1][j], dp[i - j][j - 1]),\\ if\\ \\ \\sum_{k = i - j + 1}^{i}a_i \u0026lt; dp[i - j][j - 1]\\ dp[i - 1][j] ,\\ otherwise \\end{cases} $$ 最终, 寻找最大的 $j$ 使得 $dp[n - 1][j]$ 不为 $0$ , 这个 $j$ 就是我们求的 $k$ 的最大值. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; int m = sqrt(2 * n); vector\u0026lt;ll\u0026gt; a(n, 0), pre(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[n - 1 - i]; } for (int i = 0; i \u0026lt; n; i++) { pre[i] = (i == 0)? a[i]: a[i] + pre[i - 1]; } vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n, vector\u0026lt;ll\u0026gt;(m + 1, 0)); for (int i = 0; i \u0026lt; n; i++) { dp[i][0] = 1e14; } dp[0][1] = a[0]; for (int i = 1; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt;= min(i, m); j++) { dp[i][j] = max(dp[i][j], dp[i - 1][j]); ll sum = pre[i] - pre[i - j]; if (sum \u0026lt; dp[i - j][j - 1]) { dp[i][j] = max(dp[i][j], sum); } } } for (int j = m; j \u0026gt;= 0; j--) { if (dp[n - 1][j] != 0) { cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;endl; break; } } } return 0; } ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1582e-pchelyonok-and-segments/","section":"Posts","summary":"CodeForces-1582E Pchelyonok and Segments # 题目大意 # 给定长度为 $n$ 的数组 $a$ , 要求从 $a$ 中选取尽可能多的、互不相交的子数组, 记这些子数组数量一共有 $k$ 个, 它们需要满足:","title":"CodeForces-1582E Pchelyonok and Segments"},{"content":"CodeForces-467C George and Job # 题目大意 # 给定 $n, m, k$ 和一个长度为 $n$ 的数组 $p$ . 从 $p$ 中选择 $m$ 个互不相交的连续子数组, 使得这些子数组的和最大, 求这个最大值.\nSolution 1 # 从 $n$ 个数中, 选出 $k$ 个长度为 $m$ 的连续子数组, 考虑用动态规划模拟这个选择的过程. 记 $dp[i][j]$ 为前 $i + 1$ 个元素中, 选出了 $j$ 个长度为 $m$ 的连续子数组所得到的最大和. 思考 $dp[i][j]$ 由什么状态转移过来 (也就是这一步能做什么) ? 对于 $p[i]$ , 我们要么以它为终点, 选出一个长度为 $m$ 的子数组; 要么这一步什么也不做. 因此状态转移方程如下: $$ dp[i][j] = max(dp[i - m][j - 1] + \\sum_{t = i - m + 1}^{i}p[t], dp[i - 1][j]) $$ 最终 $dp[n - 1][k]$ 就是要求的答案. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int n, m, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;ll\u0026gt; p(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;p[i]; } ll sum = 0; for (int i = 0; i \u0026lt; m - 1; i++) { sum += p[i]; } vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n, vector\u0026lt;ll\u0026gt;(k + 1, 0)); for (int i = m - 1; i \u0026lt; n; i++) { sum += (i - m \u0026lt; 0)? p[i]: p[i] - p[i - m]; for (int j = 0; j \u0026lt;= min((i + 1) / m, k); j++) { dp[i][j] = max(dp[i][j], (i - 1 \u0026lt; 0)? 0: dp[i - 1][j]); if (j != 0) { dp[i][j] = max(dp[i][j], (i - m \u0026lt; 0)? sum: dp[i - m][j - 1] + sum); } } } cout\u0026lt;\u0026lt;dp[n - 1][k]\u0026lt;\u0026lt;endl; return 0; } ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-467c-george-and-job/","section":"Posts","summary":"CodeForces-467C George and Job # 题目大意 # 给定 $n, m, k$ 和一个长度为 $n$ 的数组 $p$ .","title":"CodeForces-467C George and Job"},{"content":"CodeForces-1469C Building a Fence # 题目大意 # 给定有 $n$ 个长为 $1$ , 高度为 $k$ 的篱笆, 你需要给一块长为 $n$ 的土地布设篱笆. 这块土地是凹凸不平的, 第 $i$ 个部分的土地的高度为 $h_i$ . 篱笆的分布需要遵守以下要求:\n第一块和最后一块篱笆需要正好放在地面上; 对于两块相邻的篱笆, 接触面积的长度至少为 $1$ ; 中间的篱笆可以放在地面上, 也可以悬空, 但至多高出地面 $k - 1$ 的高度. 判断能否按要求铺设篱笆. Solution 1 # 根据规则, 如果从前向后铺设篱笆, 每一块篱笆的可行范围都是连续的. 分别用 $ub[i], lb[i]$ 记录篱笆顶点的最高范围和最低范围, 则有如下状态转移方程: $$ \\begin{cases} ub[i] = min(ub[i - 1] - 1 + k, h[i] + k - 1 + k)\\ lb[i] = max(h[i] + k, lb[i - 1] - k + 1) \\end{cases} $$ 如果某一处 $ub \u0026lt; lb$ , 那么就不存在合法的铺设方式; 对于最后一块地, 需要满足 $lb[n - 1] = h[n - 1] + k$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; h(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;h[i]; } vector\u0026lt;int\u0026gt; ub(n, 0), lb(n, 0); ub[0] = h[0] + k; lb[0] = h[0] + k; bool isValid = true; for (int i = 1; i \u0026lt; n \u0026amp;\u0026amp; isValid; i++) { ub[i] = min(ub[i - 1] - 1 + k, h[i] + k - 1 + k); lb[i] = max(h[i] + k, lb[i - 1] - k + 1); if (ub[i] \u0026lt; lb[i]) { isValid = false; } } if (lb[n - 1] == h[n - 1] + k \u0026amp;\u0026amp; isValid) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1469c-building-a-fence/","section":"Posts","summary":"CodeForces-1469C Building a Fence # 题目大意 # 给定有 $n$ 个长为 $1$ , 高度为 $k$ 的篱笆, 你需要给一块长为 $n$ 的土地布设篱笆.","title":"CodeForces-1469C Building a Fence"},{"content":"LeetCode-1658 将 x 减到 0 的最小操作数 # Solution 1 # 根据题意, 二分寻找和为 $x$ 的前缀和与后缀和. 代码如下:\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int n = nums.size(); vector\u0026lt;int\u0026gt; pre(n, 0), suf(n, 0); int ans = 0x3f3f3f3f; for (int i = 0; i \u0026lt; n; i++) { pre[i] = (i == 0)? nums[i]: nums[i] + pre[i - 1]; suf[n - 1 - i] = (i == 0)? nums[n - 1 - i]: nums[n - 1 - i] + suf[n - i]; if (pre[i] == x || suf[n - 1 - i] == x) { ans = min(ans, i + 1); } } for (int i = 1; i \u0026lt; n; i++) { int left = i + 1; int right = n - 1; int target = x - pre[i]; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (suf[mid] == target) { ans = min(ans, n - mid + i + 1); break; } else if (suf[mid] \u0026lt; target) { right = mid - 1; } else { left = mid + 1; } } } return ans == 0x3f3f3f3f? -1: ans; } }; Solution 2 # 记数组和为 $sum$ , 从数组两侧取走和为 $x$ 的数, 那么留下来的一定是一段和为 $sum - x$ 的连续子数组. 用滑动窗口找出符合条件的最长连续子数组即可. 代码如下:\nclass Solution { public: int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; nums, int x) { int n = nums.size(); int sum = 0; for (auto num: nums) { sum += num; } sum -= x; cout\u0026lt;\u0026lt;\u0026#34;sum = \u0026#34;\u0026lt;\u0026lt;sum\u0026lt;\u0026lt;endl; if (sum \u0026lt; 0) { return -1; } else if (sum == 0){ return n; } int ans = 0x3f3f3f3f; int left = 0, right = 0; int win_sum = 0; while (right \u0026lt; n) { win_sum += nums[right]; right++; while (win_sum \u0026gt; sum) { win_sum -= nums[left]; left++; } if(win_sum == sum) { ans = min(ans, n - right + left); } } return ans == 0x3f3f3f3f? -1: ans; } }; ","date":"24 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1658-%E5%B0%86-x-%E5%87%8F%E5%88%B0-0-%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0/","section":"Posts","summary":"LeetCode-1658 将 x 减到 0 的最小操作数 # Solution 1 # 根据题意, 二分寻找和为 $x$ 的前缀和与后缀和.","title":"LeetCode-1658 将 x 减到 0 的最小操作数"},{"content":"","date":null,"permalink":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/","section":"Tags","summary":"","title":"双指针"},{"content":"","date":null,"permalink":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","section":"Tags","summary":"","title":"滑动窗口"},{"content":"LeetCode-2350 不可能得到的最短骰子序列 # Solution 1 # 假设不可能得到的最短骰子序列长度为 $len$ , 那么对于长度为 $ len - 1$ 的骰子序列, 都能从 $rolls$ 中得到. 对于 $k$ 面的骰子, 每一位都有 $k$ 种选择. 考虑第 $1$ 位, $rolls$ 中应当包含 $1, 2, \u0026hellip;, k$ ; 考虑第 $2$ 位, 在第 $1$ 位任意选择后, 第 $2$ 位也能够任意选择 $1, 2, \u0026hellip;, k$ , 说明在第一组 $1, 2, \u0026hellip;, k$ 后还需要有一组 $1, 2, \u0026hellip;, k$ . 依此类推, 我们用一个 $set$ 记录一组完全的骰子数, 统计到一组后开始统计下一组. 假设有 $cnt$ 组, 那么答案就是 $cnt + 1$ . 代码如下:\nclass Solution { public: int shortestSequence(vector\u0026lt;int\u0026gt;\u0026amp; rolls, int k) { set\u0026lt;int\u0026gt; s; int ans = 1; for (int roll: rolls) { if (!s.count(roll)) { s.insert(roll); } if (s.size() == k) { ans++; s.clear(); } } return ans; } }; ","date":"23 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2350-%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E7%9F%AD%E9%AA%B0%E5%AD%90%E5%BA%8F%E5%88%97/","section":"Posts","summary":"LeetCode-2350 不可能得到的最短骰子序列 # Solution 1 # 假设不可能得到的最短骰子序列长度为 $len$ , 那么对于长度为 $ len - 1$ 的骰子序列, 都能从 $rolls$ 中得到.","title":"LeetCode-2350 不可能得到的最短骰子序列"},{"content":"","date":null,"permalink":"/tags/%E6%80%9D%E7%BB%B4/","section":"Tags","summary":"","title":"思维"},{"content":"LeetCode-2271 毯子覆盖的最多白色砖块数 # Solution 1 # 地毯覆盖最多白色砖块时, 它的左端点一定处于某个白色砖块区间的左端点. 想到这一点, 我们用双指针遍历所有可能. 一个指针用于记录左侧端点, 另一个指针记录右侧最后一个有重合的区间左端点. 代码如下:\n#define ll long long class Solution { public: int maximumWhiteTiles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; tiles, int carpetLen) { sort(tiles.begin(), tiles.end()); ll now = 0, ans = 0; for (int i = 0, j = 0; i \u0026lt; tiles.size(); i++) { while (j \u0026lt; tiles.size() \u0026amp;\u0026amp; tiles[j][1] + 1 - tiles[i][0] \u0026lt;= carpetLen) now += tiles[j][1] - tiles[j][0] + 1, j++; // 计算完全被覆盖的区间 // 毯子无法完全覆盖第 j 组瓷砖 if (j \u0026lt; tiles.size()) ans = max(ans, now + max(0, tiles[i][0] + carpetLen - tiles[j][0])); // 毯子可以完全覆盖第 j 组瓷砖 else ans = max(ans, now); now -= tiles[i][1] - tiles[i][0] + 1; } return ans; } }; ","date":"23 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2271-%E6%AF%AF%E5%AD%90%E8%A6%86%E7%9B%96%E7%9A%84%E6%9C%80%E5%A4%9A%E7%99%BD%E8%89%B2%E7%A0%96%E5%9D%97%E6%95%B0/","section":"Posts","summary":"LeetCode-2271 毯子覆盖的最多白色砖块数 # Solution 1 # 地毯覆盖最多白色砖块时, 它的左端点一定处于某个白色砖块区间的左端点.","title":"LeetCode-2271 毯子覆盖的最多白色砖块数"},{"content":"LeetCode-2386 找出数组的第 K 大和 # Solution 1 # 先考虑一个简化版的问题: 给定 $n$ 个非负数 $a_0, a_1, \u0026hellip;, a_n$ , 如何找出第 $k$ 小的子序列和? 不妨设 $a$ 是从小到大排好序的. 最小的子序列和显然是 $0$ . 记 $(s, i)$ 为总和为 $s$ , 且最后一个元素下标为 $i$ 的子序列. 我们用一个最小堆来维护这些子序列. 一开始堆中只有 $(a_0, 0)$ , 取出堆顶元素时, 可以进行以下操作:\n把 $a_{i + 1}$ 接到这个子序列后面, 把 $(s + a_{i + 1}, i + 1)$ 放到堆中; 把 $a_i$ 替换成 $a_{i + 1}$ , 把 $(s - a_i + a_{i + 1}, i + 1)$ 放到堆中. 可以看出, 这种策略保证了:\n所有的子序列都会被遍历到; 子序列的遍历顺序由小到大. 通过这种操作, 我们可以很快得到第 $k$ 小的子序列. 对于本题, 要求寻找第 $k$ 大的子序列, 而且数组元素包含负数, 需要寻找一种合适的转化. 首先可以得到最大的子序列和, 把 $a$ 中的非负元素相加就可以得到. 怎么修改这个子序列呢? 对于一个非负元素, 我们可以从子序列和中把它减去来得到更小的子序列; 对于一个负元素, 我们可以在子序列之外加上这个元素来得到更小的子序列. 这两种操作可以合并成减去原数组中某些元素的绝对值. 要得到第 $k$ 大的子序列, 也就是要找到 $\\vert a\\vert$ 中第 $k$ 小的子序列. 这样, 我们就把本题转化成了简化版的问题. 代码如下:\n#define ll long long typedef pair\u0026lt;ll, int\u0026gt; pii; class Solution { public: long long kSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { ll sum = 0; for (int \u0026amp;num: nums) { if (num \u0026gt; 0) { sum += num; } else { num = -num; } } sort(nums.begin(), nums.end()); priority_queue\u0026lt;pii\u0026gt; pq; // 我们直接用最大堆来合并两个步骤 pq.emplace(sum, 0); // 当前和为 sum , 减去的子序列最大下标为 i - 1 while (--k) { // 循环 k - 1 次 auto[sum, i] = pq.top(); pq.pop(); if (i \u0026lt; nums.size()) { pq.emplace(sum - nums[i], i + 1); // 减去的子序列再减去 nums[i] if (i != 0) { pq.emplace(sum - nums[i] + nums[i - 1], i + 1); // 减去的子序列补上前面的nums[i - 1], 再减去 nums[i] } } } return pq.top().first; } }; ","date":"23 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2386-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-k-%E5%A4%A7%E5%92%8C/","section":"Posts","summary":"LeetCode-2386 找出数组的第 K 大和 # Solution 1 # 先考虑一个简化版的问题: 给定 $n$ 个非负数 $a_0, a_1, \u0026hellip;, a_n$ , 如何找出第 $k$ 小的子序列和?","title":"LeetCode-2386 找出数组的第 K 大和"},{"content":"LeetCode 九坤投资专场竞赛 # Problem 1 可以读通讯稿的组数 # 题目链接 # 九坤-01. 可以读通讯稿的组数\nSolution 1 # 如果两个编号 $a, b$ 满足条件 $a + reverse(b) == reverse(a) + b$ , 那么有 $a - reverse(a) == b - reverse(b)$ , 把对称的二元关系转化成一元的性质, 这样用哈希计数即可. 代码如下:\n#define ll long long const ll MOD = 1e9 + 7; class Solution { public: int reverse(int num) { int res = 0; int temp = 0; while (num != 0) { temp = num % 10; res = res * 10 + temp; num /= 10; } return res; } int numberOfPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = 0; unordered_map\u0026lt;int, ll\u0026gt; book; for (int num: nums) { book[num - reverse(num)]++; } for (auto it: book) { ans = (ans + (it.second - 1) * (it.second) / 2) % MOD; } return ans; } }; Problem 2 池塘计数 # 题目链接 # 九坤-02. 池塘计数\nSolution 1 # 统计池塘数量, 我们用沉岛策略避免重复计算. 代码如下:\nconst int dirs[8][2] = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}}; class Solution { public: int m, n; void visit(vector\u0026lt;string\u0026gt;\u0026amp; field, int i, int j) { field[i][j] = \u0026#39;.\u0026#39;; // 沉岛, 避免重复搜索 for (auto dir: dirs) { int x = i + dir[0]; int y = j + dir[1]; if (x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; m \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026lt; n \u0026amp;\u0026amp; field[x][y] == \u0026#39;W\u0026#39;) { visit(field, x, y); } } return; } int lakeCount(vector\u0026lt;string\u0026gt;\u0026amp; field) { m = field.size(); n = field[0].size(); int ans = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (field[i][j] == \u0026#39;W\u0026#39;) { ans++; visit(field, i, j); } } } return ans; } }; Problem 3 数字默契考验 # 题目链接 # 九坤-03. 数字默契考验\nSolution 1 # 经过若干次 $\\times 2$ 和 $\\times 3$ 的操作后能够得到相同的数, 说明 $numbers$ 数组中每个元素除了 $2$ 和 $3$ 以外的因子是完全相同的. 我们统计各个元素 $2$ 和 $3$ 的幂次与最高幂次的差之和即可. 代码如下:\n#define ll long long class Solution { public: const int TWO = 1 \u0026lt;\u0026lt; 30, THREE = 1162261467; int minOperations(vector\u0026lt;int\u0026gt;\u0026amp; numbers) { int n = numbers.size(); vector\u0026lt;int\u0026gt; part_2(n, 0), part_3(n, 0); int base = numbers[0] / __gcd(numbers[0], TWO) / __gcd(numbers[0], THREE); int max_2 = 0, max_3 = 0; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { part_2[i] = __gcd(numbers[i], TWO); part_3[i] = __gcd(numbers[i], THREE); if (numbers[i] / part_2[i] / part_3[i] != base) { return -1; } int cnt_2 = 0, cnt_3 = 0; while (part_2[i] % 2 == 0) { part_2[i] /= 2; cnt_2++; } while (part_3[i] % 3 == 0) { part_3[i] /= 3; cnt_3++; } max_2 = max(max_2, cnt_2); max_3 = max(max_3, cnt_3); ans -= cnt_2 + cnt_3; } ans += (max_2 + max_3) * n; return ans; } }; Problem 4 筹码游戏 # 题目链接 # 九坤-04. 筹码游戏\nSolution 1 # 由于筹码的地位对称, 我们只需要考虑筹码的数量而不必纠结于具体的分配. 用 $k$ 个单调不减的数字代表当前筹码的状态 $state$ . 考虑到达终点 $nums$ 的状态转移. 每次抽取筹码共有 $k$ 种可能, 每种使得 $state[i] + 1$ 得到一种新的 $state_i$ . 假设有 $m$ 个状态可以到达最终状态, 则有如下状态转移方程: $$ E(state) = \\sum_{t = 1}^{m}E(state_{j_t}) \\times \\frac{1}{kind} + (1 - \\frac{m}{kind})\\times E(state) + 1 $$ 即 $$ E(state) = \\frac{\\sum_{t = 1}^{m}E(state_{j_t}) + kind}{m} $$ 使用深度优先搜索来完成递推过程, 利用记忆化搜索减少计算量. 代码如下:\nclass Solution: def chipGame(self, nums: List[int], kind: int) -\u0026gt; float: nums = [0] * (kind - len(nums)) + sorted(nums) @cache def getRes(state): state = list(state) if state == nums: return 0 sum_E = 0 sum_p = 0 i = 0 for i in range(kind): cnt = 1 state[i] += 1 new_state = sorted(state) for x, y in zip(new_state, nums): if x \u0026gt; y: break; else: sum_E += getRes(tuple(new_state)) sum_p += 1 state[i] -= 1 return (sum_E + kind) / sum_p return getRes(tuple([0] * kind)) ","date":"23 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-%E4%B9%9D%E5%9D%A4%E6%8A%95%E8%B5%84%E4%B8%93%E5%9C%BA%E7%AB%9E%E8%B5%9B/","section":"Posts","summary":"LeetCode 九坤投资专场竞赛 # Problem 1 可以读通讯稿的组数 # 题目链接 # 九坤-01.","title":"LeetCode 九坤投资专场竞赛"},{"content":"","date":null,"permalink":"/tags/%E5%93%88%E5%B8%8C/","section":"Tags","summary":"","title":"哈希"},{"content":"LeetCode-782 变为棋盘 # Solution 1 # 这道题的要点在于看穿行列交换互不影响的特性. 我们首先假设初始局面能够通过行列交换变成一个 \u0026ldquo;棋盘\u0026rdquo; . 现在考虑每一行与第一行的关系. 由 \u0026ldquo;棋盘\u0026rdquo; 的定义可以知道, 每一行与第一行要么相同, 要么相反. 而交换两列不会影响行与行之间对应元素的相等性, 也就是说, 进行列交换的逆操作得到初始局面经过一系列行交换之后形成的局面, 在这个局面下, 每个行依然要么与第一行相同, 要么与第一行相反. 对列也是同理. 因此, 我们首先检查是否存在既不与第一行 / 列相同, 又不与第一行 / 列相反的行 / 列, 如果存在, 直接返回 -1 ; 之后判断相同相反的个数是否能形成交错的局面; 最后把二维问题分解成两个一维问题, 计算最少的交换次数. 代码如下:\nclass Solution { public: int movesToChessboard(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; board) { int n = board.size(); int row_mask_0 = 0, row_mask_1 = 0, col_mask_0 = 0, col_mask_1 = 0; int row_cnt_0 = 1, col_cnt_0 = 1; for (int i = 0; i \u0026lt; n; i++) { row_mask_0 |= board[0][i] \u0026lt;\u0026lt; i; row_mask_1 |= (1 - board[0][i]) \u0026lt;\u0026lt; i; col_mask_0 |= board[i][0] \u0026lt;\u0026lt; i; col_mask_1 |= (1 - board[i][0]) \u0026lt;\u0026lt; i; } // 每一行要么是 row_mask_0, 要么是 row_mask_1 for (int i = 1; i \u0026lt; n; i++) { int row_mask = 0; int col_mask = 0; for (int j = 0; j \u0026lt; n; j++) { row_mask |= board[i][j] \u0026lt;\u0026lt; j; col_mask |= board[j][i] \u0026lt;\u0026lt; j; } if ((row_mask != row_mask_0 \u0026amp;\u0026amp; row_mask != row_mask_1) || (col_mask != col_mask_0 \u0026amp;\u0026amp; col_mask != col_mask_1)) { return -1; } row_cnt_0 += (row_mask == row_mask_0); col_cnt_0 += (col_mask == col_mask_0); } if ((row_cnt_0 != n / 2 \u0026amp;\u0026amp; row_cnt_0 != (n + 1) / 2) || (col_cnt_0 != n / 2 \u0026amp;\u0026amp; col_cnt_0 != (n + 1) / 2)) { // 这一部分也可以通过 __builtin_popcount(mask) 判断 return -1; } // 下面考虑行交换和列交换的个数 // 对于 0 1 1 0, 要交换几次? int ans = 0; int cnt[2]; if (n % 2 == 0) { // n 为偶数时, 开头放 0 / 1 都行 for (int start = 0; start \u0026lt;= 1; start++) { cnt[start] = 0; for (int i = 0; i \u0026lt; n; i += 2) { cnt[start] += (board[0][i] != start); } } ans += min(cnt[0], cnt[1]); for (int start = 0; start \u0026lt;= 1; start++) { cnt[start] = 0; for (int i = 0; i \u0026lt; n; i += 2) { cnt[start] += (board[i][0] != start); } } ans += min(cnt[0], cnt[1]); } else { // n 为奇数时, 开头只能放数量更多的那个元素 int row_ones = __builtin_popcount(row_mask_0), col_ones = __builtin_popcount(col_mask_0); int row_start = (row_ones == n / 2)? 0: 1; int col_start = (col_ones == n / 2)? 0: 1; for (int i = 0; i \u0026lt; n; i += 2) { ans += (board[0][i] != row_start); ans += (board[i][0] != col_start); } } return ans; } }; ","date":"23 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-782-%E5%8F%98%E4%B8%BA%E6%A3%8B%E7%9B%98/","section":"Posts","summary":"LeetCode-782 变为棋盘 # Solution 1 # 这道题的要点在于看穿行列交换互不影响的特性.","title":"LeetCode-782 变为棋盘"},{"content":"数位 dp # 介绍 # OI-Wiki 对数位 dp 的基本介绍如下:\n数位：把一个数字按照个、十、百、千等等一位一位地拆开, 关注它每一位上的数字. 如果拆的是十进制数, 那么每一位数字都是 $0, 1, \u0026hellip;, 9$，其他进制可类比十进制. 数位 DP: 用来解决一类特定问题，这种问题比较好辨认，一般具有这几个特征：\n要求统计满足一定条件的数的数量 (即最终目的为计数) ; 这些条件经过转化后可以使用「数位」的思想去理解和判断; 输入会提供一个数字区间（有时也只提供上界）来作为统计的限制; 上界很大 (比如 $10^{18}$ ) , 暴力枚举验证会超时. 算法 # 从位上进行动态规划, 需要考虑:\n范围限制以及其它计数约束, 算法中表现为当前为可以使用的数字个数; 递推顺序, 从高位向地位进行动态规划; 算法复杂度, 通常利用递归 + 记忆化搜索减少时间复杂度. 对于LeetCode-2376 统计特殊整数, 灵神提供的模板如下:\nclass Solution { public: int countSpecialNumbers(int n) { auto s = to_string(n); // 把上限 n 转化为字符串 int m = s.length(), dp[m][1 \u0026lt;\u0026lt; 10]; // dp数组, 记忆化搜索需要使用, 代表 不受约束时 填了数 (先导 0 不算) 考虑了 0 - i 位, 所用数字为 mask 的数字个数. 需要注意的是, 只用二维存储, 但含义是四维的, 在递归函数中做进一步解释 memset(dp, -1, sizeof(dp)); // dp数组初始化 function\u0026lt;int(int, int, bool, bool)\u0026gt; f = [\u0026amp;](int i, int mask, bool is_limit, bool is_num) -\u0026gt; int { // 递归函数 if (i == m) return is_num; // i == m, 所有数位已经填完了, 如果是 is_num 为 true, 说明答案填了数, 返回 1 ; 否则说明考虑的是 0 (每一位都没有天数) if (!is_limit \u0026amp;\u0026amp; is_num \u0026amp;\u0026amp; dp[i][mask] \u0026gt;= 0) return dp[i][mask]; // 满足 dp 定义才能调用已有结果, 参考 dp 数组的含义 int res = 0; // 计算新结果 if (!is_num) res = f(i + 1, mask, false, false); // 可以跳过当前数位 for (int d = 1 - is_num, up = is_limit ? s[i] - \u0026#39;0\u0026#39; : 9; d \u0026lt;= up; ++d) // 枚举要填入的数字 d if ((mask \u0026gt;\u0026gt; d \u0026amp; 1) == 0) // d 不在 mask 中 res += f(i + 1, mask | (1 \u0026lt;\u0026lt; d), is_limit \u0026amp;\u0026amp; d == up, true); // 填入 d , 后续的位数变化, mask变化, is_limit 由 前面位是否为上限 以及 d 是否为该位上限 共同决定, 因为填了数, is_num 为 true if (!is_limit \u0026amp;\u0026amp; is_num) dp[i][mask] = res; // 如果不受 n 限制, 并且填了数, 就记忆化 return res; }; return f(0, 0, true, false); // 从最高位开始填, 一开始一个没有填, 受到 n 限制, 还没有填 的数的个数 } }; 最需要注意的一点就是, $dp$ 是二维的, 而 $f$ 是四维的, 所以记忆化以及调用时都要注意条件限制. 做这种处理是因为 is_limit == true 的情况只会走一次, 所以没有必要记忆化.\n","date":"19 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E4%BD%8D-dp/","section":"Posts","summary":"数位 dp # 介绍 # OI-Wiki 对数位 dp 的基本介绍如下:","title":"数位 DP"},{"content":"Puzzle Toad-5 Empty the bucket # 题目翻译 # 你现在身处沙漠, 并且拥有 $3$ 个桶 (桶的容量无限) , 里面分别有 $a, b, c$ 盎司的水. 这里 $a, b, c$ 都是正整数. 出于某个原因, 你现在需要一个空桶. 因为在沙漠中你非常需要水, 所以不能简单地把水倒掉来得到一个空桶. 你不得不把水从一个桶倒到另一个桶中. 不过在每次倒水时, 你必须让接收水的水桶中的水数量变为原来的两倍 (也就是说, $a\\rightarrow b$ 会使得 $a, b$ 变为 $a - b, 2b$). 举例来说, 水桶中的水变化的情况可能是这样的: $$ 3\\quad 2\\quad 1\\ 1\\quad 4\\quad 1\\ 0\\quad 4\\quad 2\\ $$ 证明: 无论初始的水量是多少, 在这种约束下你总是可以得到一个空桶.\n解答 # 解法 1 # 两个水桶的特殊情况 # 首先考虑只有一奇一偶两个水桶, 看看对它们进行操作会发生什么. 因为只有两个不相等的水桶, 只有一种可能的行动: 把水多的水桶向水少的水桶中倒水. 注意到这个操作使得两个水桶仍然是一奇一偶. 如果一直重复这个操作, 会发生什么? 既然水桶状态的总数有限, 最终一定会回到某个之前出现过的状态上. 事实上, 第一个重复的状态就是初始的状态. 这是因为对于序列中的任何一种状态, 它的前一个状态都是唯一的, 把偶数桶的一半水放到奇数桶中, 就能得到这个状态. 如果状态构成的环大小是 $n$ , 那么通过 $n - 1$ 次移动, 就能从初始状态到达初始状态的 \u0026ldquo;前一个\u0026rdquo; 状态. 也就是说, 如果初始状态是 $(a, b)$ , $a$ 是偶数而 $b$ 是奇数, 那么我们可以让水桶变为 $(\\frac{a}{2}, b + \\frac{a}{2})$ .\n\u0026ldquo;奇偶偶\u0026rdquo; 的解法 # 对此有把握后, 考虑一个稍微一般点的情况. 假设现在有 $3$ 个水桶, 第一个为奇数, 剩余两个为偶数, 称为 \u0026ldquo;奇偶偶\u0026rdquo; 的情况. 事实上, 我们可以在不断增加奇数桶水量的同时保持另外两个桶仍然是偶数桶, 按照这一结论, 最终一定会有某一时刻, 一个偶数桶变成了空桶. 下面来说明具体的操作: 假设水量分别为 $a, b, c$ , $a$ 为奇数, $b, c$ 为偶数. 首先, 如果 $b, c$ 都不是 $4$ 的倍数, 可以在 $b, c$ 之间倒一次水, 这样就能得到一个 $4$ 的倍数, 同时另一个仍然是偶数. 因此, 可以直接假设 $b$ 为 $4$ 的倍数, $c$ 为偶数. 这时, 我们应用两个水桶时的结论, 把 $(a, b)$ \u0026ldquo;回溯\u0026rdquo; 到前一个状态, 得到 $(a + \\frac{b}{2}, \\frac{b}{2})$ , 因为 $b$ 为 $4$ 的倍数, 所以现在 $a + \\frac{b}{2}, \\frac{b}{2}, c$ 仍然是 \u0026ldquo;奇偶偶\u0026rdquo; 的模式. 重复这一模式 (用偶数桶构造出 $4$ 的倍数, 再向奇数桶倒水) , 最终一定会有一个偶数桶变为空桶. 这样我们就解决了 \u0026ldquo;奇偶偶\u0026rdquo; 的情况.\n其它情况等价于 \u0026ldquo;奇偶偶\u0026rdquo; # 对于剩下的情况呢? \u0026ldquo;奇奇奇\u0026rdquo; 的情况很简单, 随便倒一次水就化归成了 \u0026ldquo;奇偶偶\u0026rdquo; 的情况. 对于 \u0026ldquo;偶偶偶\u0026rdquo; 的情况, 把每个桶的水量都除以 $2$ 的问题与原问题是等价的. 而对于 \u0026ldquo;奇奇偶\u0026rdquo; 的问题, 在两个奇数桶之间倒一次水, 就变为了 \u0026ldquo;偶偶偶\u0026rdquo; 的情况, 可以进一步减小问题规模. 因此, 最终 \u0026ldquo;偶偶偶\u0026rdquo; 和 \u0026ldquo;奇奇偶\u0026rdquo; 都能化为 \u0026ldquo;奇偶偶\u0026rdquo; 的情况.\n解法 2 # 把 $3$ 个水桶按水量从小到大排列, 记作 $A, B, C$ . 下面给出一种操作, 使得 $B$ 中的水会变得比 $A$ 中的水少. 作带余除法 $B ÷ A = x\\times A + y, 0\\leq y\u0026lt; A$ . 把 $x$ 写成二进制形式, 然后从低位向高位遍历, 遇到 $1$ 就从 $B$ 向 $A$ 倒水, 遇到 $0$ 就从 $C$ 向 $A$ 倒水. 容易证明这个过程就是在模拟带余除法, 最终 $B$ 剩下的水量恰好就是 $y \u0026lt; A$ . 这个过程是肯定能实现的, 因为排序保证了 $A\\leq B\\leq C$ , 而过程中 $B$ 至多倒 $x\\times A\\leq B$ 分量的水, $C$ 至多倒 $x\\times A - 1 \u0026lt; C$ 分量的水. 不断重复这个操作, 我们就能不断刷新 $3$ 个水桶中水量的最小值, 最终会得到一个空桶.\n补充 # 这道题和它的两种解法, 出自 Peter Winkler 的文章 Five Algorithmic Puzzles .\n","date":"19 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-5-empty-the-bucket/","section":"Posts","summary":"Puzzle Toad-5 Empty the bucket # 题目翻译 # 你现在身处沙漠, 并且拥有 $3$ 个桶 (桶的容量无限) , 里面分别有 $a, b, c$ 盎司的水.","title":"Puzzle Toad-5 Empty the bucket"},{"content":"LeetCode-2375 根据模式串构造最小数字 # Solution 1 # 根据长度为 $n$ 的 $pattern$ 字符串构造长度为 $n + 1$ 的 $ans$ , 由于每个数字字符只能用 $1$ 次, 而且要求 $ans$ 字典序尽可能小, 我们考虑贪心的构造模式. 遇到 $I$ , 优先选择当前剩下的最小的字符; 遇到 $D$ , 观察连续有多少个 $D$ 相邻, 从后向前逆序构造, 每次优先选择当前剩下的最小的字符. 这一部分的实现也可以用反转 $123456789$ 这个字符串的部分区间实现. 代码如下:\nclass Solution { public: string smallestNumber(string pattern) { int n = pattern.size(); pattern += \u0026#39;I\u0026#39;; // 后面补一个 $I$ , 方便统一处理 char p = \u0026#39;1\u0026#39;; // p 代表当前可用的最小字符 string ans = \u0026#34;\u0026#34;; set\u0026lt;char\u0026gt; book; // 记录用过的数字 for (int i = 0; i \u0026lt; n + 1; i++) { if (pattern[i] == \u0026#39;I\u0026#39;) { // 遇到 I , 优先选最小字符 ans += p; book.insert(p); // 记录 p++; } else { // 遇到 D , 记录有连续多少个 D , 再构造. int cnt = 0; for (int j = i; j \u0026lt; n; j++) { cnt++; if (pattern[j + 1] == \u0026#39;I\u0026#39;) { cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; ans += p + cnt; book.insert(p + cnt); break; } } } while (book.count(p)) { // 更新 p p++; } } return ans; } }; ","date":"19 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2375-%E6%A0%B9%E6%8D%AE%E6%A8%A1%E5%BC%8F%E4%B8%B2%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","section":"Posts","summary":"LeetCode-2375 根据模式串构造最小数字 # Solution 1 # 根据长度为 $n$ 的 $pattern$ 字符串构造长度为 $n + 1$ 的 $ans$ , 由于每个数字字符只能用 $1$ 次, 而且要求 $ans$ 字典序尽可能小, 我们考虑贪心的构造模式.","title":"LeetCode-2375 根据模式串构造最小数字"},{"content":"LeetCode-2370 最长理想子序列 # Solution 1 # 对于子序列问题, 首先想到动态规划. 状态的转移和末尾元素有关, 因此我们用 $dp[ch]$ 记录当前以 $ch$ 字符结尾的最长理想子序列. 从前向后遍历 $s$ 时, 更新 $dp$ 数组即可. 代码如下:\nclass Solution { public: int longestIdealString(string s, int k) { vector\u0026lt;int\u0026gt; dp(26, 0); dp[s[0] - \u0026#39;a\u0026#39;] = 1; for (int i = 1; i \u0026lt; s.size(); i++) { int temp = 0; for (int ch = 0; ch \u0026lt; 26; ch++) { if (abs(s[i] - \u0026#39;a\u0026#39; - ch) \u0026lt;= k) { temp = max(temp, dp[ch] + 1); } } dp[s[i] - \u0026#39;a\u0026#39;] = temp; } int ans = 0; for (auto res: dp) { cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;; ans = max(ans, res); } cout\u0026lt;\u0026lt;endl; return ans; } }; ","date":"18 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2370-%E6%9C%80%E9%95%BF%E7%90%86%E6%83%B3%E5%AD%90%E5%BA%8F%E5%88%97/","section":"Posts","summary":"LeetCode-2370 最长理想子序列 # Solution 1 # 对于子序列问题, 首先想到动态规划.","title":"LeetCode-2370 最长理想子序列"},{"content":"LeetCode-2369 检查数组是否存在有效划分 # Solution 1 # 划分方式和 \u0026ldquo;爬楼梯\u0026rdquo; 问题很相似, 我们用 $dp[i]$ 记录前 $i + 1$ 个元素能否产生有效划分, 根据 $nums[i], nums[i - 1], nums[i - 2]$ 的关系进行递推即可. 代码如下:\nclass Solution { public: bool validPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;bool\u0026gt; dp(n, false); dp[0] = false; dp[1] = (nums[1] == nums[0]); if (n == 2) { return dp[1]; } dp[2] = (nums[2] == nums[1] \u0026amp;\u0026amp; nums[1] == nums[0]) || (nums[2] == nums[1] + 1 \u0026amp;\u0026amp; nums[1] == nums[0] + 1); for (int i = 3; i \u0026lt; n; i++) { if (nums[i] == nums[i - 1]) { dp[i] = dp[i] + dp[i - 2]; if (nums[i - 1] == nums[i - 2]) { dp[i] = dp[i] + dp[i - 3]; } } else if (nums[i] == nums[i - 1] + 1 \u0026amp;\u0026amp; nums[i - 1] == nums[i - 2] + 1) { dp[i] = dp[i] + dp[i - 3]; } } return dp[n - 1]; } }; ","date":"18 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2369-%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9C%89%E6%95%88%E5%88%92%E5%88%86/","section":"Posts","summary":"LeetCode-2369 检查数组是否存在有效划分 # Solution 1 # 划分方式和 \u0026ldquo;爬楼梯\u0026rdquo; 问题很相似, 我们用 $dp[i]$ 记录前 $i + 1$ 个元素能否产生有效划分, 根据 $nums[i], nums[i - 1], nums[i - 2]$ 的关系进行递推即可.","title":"LeetCode-2369 检查数组是否存在有效划分"},{"content":"LeetCode-2366 将数组排序的最少替换次数 # Solution 1 # 不断把 $nums[i]$ 用 $t$ 步拆分成为 $a_{i1}, a_{i2}, \u0026hellip;, a_{i(t+1)}$ 共 $t + 1$ 个数, 最终得到一个非递减的数组. 容易想到, 后面的数尽可能大的情况下, 前面比较小的数可以不拆, 比较大的数可以少拆. 从这个角度出发, 我们从后向前遍历, 用 $mod$ 维护当前拆分成多大的数, 如果 $nums[i] \u0026lt; mod$ , 把 $mod$ 更新为 $nums[i]$ ; 如果 $nums[i] \u0026gt; mod$ , 观察 $mod$ 是否整除 $nums[i]$ , 如果整除直接拆; 如果不整除, 尽可能拆分成大的数字, 同时更新 $mod$ . 一次遍历即可. 代码如下:\n#define ll long long class Solution { public: long long minimumReplacement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { ll ans = 0; int n = nums.size(); int mod = nums[n - 1]; for (int i = n - 2; i \u0026gt;= 0; i--) { mod = min(mod, nums[i]); ans += (nums[i] - 1) / mod; if (nums[i] % mod != 0) { mod = nums[i] / (((nums[i] - 1) / mod) + 1); } } return ans; } }; ","date":"18 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2366-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%91%E6%9B%BF%E6%8D%A2%E6%AC%A1%E6%95%B0/","section":"Posts","summary":"LeetCode-2366 将数组排序的最少替换次数 # Solution 1 # 不断把 $nums[i]$ 用 $t$ 步拆分成为 $a_{i1}, a_{i2}, \u0026hellip;, a_{i(t+1)}$ 共 $t + 1$ 个数, 最终得到一个非递减的数组.","title":"LeetCode-2366 将数组排序的最少替换次数"},{"content":"LeetCode-2364 统计坏数对的数目 # Solution 1 # 求 $j - i \\not = nums[j] - nums[i]$ 的 \u0026ldquo;坏数对\u0026rdquo; 个数, 不妨改为求 $j - i = nums[j] - nums[i]$ 的 \u0026ldquo;好数对\u0026rdquo; 个数, 式子变形为 $j - nums[j] = i - nums[i]$ , 这样把二元性质转化成了一元的性质. 统计好数对个数时只需要考虑 $nums[i]$ 自身的值, 使用 $map$ 存储不同 $i - nums[j]$ 值的个数, 统计出 \u0026ldquo;好数对\u0026rdquo; 个数后用总数减去这个值就得到所求答案. 代码如下:\nclass Solution { public: long long countBadPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { long long n = nums.size(); long long ans = n * (n - 1) / 2; unordered_map\u0026lt;int, long long\u0026gt; book; for (int i = 0; i \u0026lt; n; i++) { book[i - nums[i]]++; } for (auto it = book.begin(); it != book.end(); it++) { ans -= it-\u0026gt;second * (it-\u0026gt;second - 1) / 2; } return ans; } }; ","date":"18 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2364-%E7%BB%9F%E8%AE%A1%E5%9D%8F%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2364 统计坏数对的数目 # Solution 1 # 求 $j - i \\not = nums[j] - nums[i]$ 的 \u0026ldquo;坏数对\u0026rdquo; 个数, 不妨改为求 $j - i = nums[j] - nums[i]$ 的 \u0026ldquo;好数对\u0026rdquo; 个数, 式子变形为 $j - nums[j] = i - nums[i]$ , 这样把二元性质转化成了一元的性质.","title":"LeetCode-2364 统计坏数对的数目"},{"content":"Puzzle Toad-4 Vacancy Puzzle # 题目翻译 # 敬爱的领袖 Aldan 的提前退休给 Zocor 的 Malthusian 市的执政三巨头留下了一个空缺. 现在有两个政党, 肉食爱好者党 (The Meat Lovers Party, MLP) 以及国民素食党 (the Vegetarian Party of the People, VPP) .目前, 在三巨头中, 每一方都有一个代表. MLP 的代表 Arctan 的级别最高, 另一个统治者是 Arcsin . 替代 Aldan 的神秘投票规则如下: 有一个由 $n$ 人构成的大型主席团, 目前所有人都是 VPP 的成员. 每个成员都有一个值为整数的优先级. 现在起选举过程将会一轮一轮地进行: 每一轮的开始, Arcsin 会提名主席团剩余参选人集合 $C$ 的一个子集 $S$ (最开始, $C$ 就是整个主席团), Arctan 有两个选择: 他可以吞噬 $S$ , 但之后必须把 $C \\setminus S$ 的每个成员的优先级都减少 $1$ ; 或者, 他可以吞噬 $C \\setminus S$ 并且把 $S$ 中每个成员的优先级减少 $1$ . 选举过程会一直持续, 直到出现接下来两种情况之一. 第一种情况是整个主席团都被吞噬了, 这之后 Arctan 可以从他的党派中选一个成员填补 Aldan 的空位; 另一种情况是某个成员的优先级到达 $0$ , 这之后 Arcsin 可以从优先级为 $0$ 的成员中选择一个填补 Aldan 的空位. 假设初始的主席团优先级为 $a_1, a_2, \u0026hellip;, a_n$ , 哪个党派最终会竞选成功?\n解答 # 结论 # 让我们换一种符号来解决这道题. 我们用 $a(c)$ 来记录参选者 $c\\in C$ 的优先级. 事实上, Arctan 能够取胜当且仅当初始情况满足 $$ \\phi(C) = \\sum_{c\\in C}2^{-a(c)} \u0026lt; 1 $$ 我们下面用归纳法来证明这一点. 在竞选过程的最后, 要么 $C=\\emptyset$ 且 $\\phi(C) = 0$ , Arctan 获胜, 要么 $\\exist c\\in C$ 满足 $a(c) = 0$ 且 $\\phi(C) \\geq 1$ , Arcsin获胜.\nArctan 必胜的情况 # 现在考虑竞选过程中的某一步. 记 $\\phi\u0026rsquo;$ 为 Arctan 作出选择后 $\\phi$ 函数的新值, 那么有 $$ \\phi(C) = \\frac{1}{2}\\phi\u0026rsquo;(S) + \\frac{1}{2}\\phi\u0026rsquo;(C\\setminus S) $$ 因此, 如果 $\\phi(C) \u0026lt; 1$ , 必然有 $min{\\phi\u0026rsquo;(S), \\phi\u0026rsquo;(C\\setminus S)} \u0026lt; 1$ . 因此, Arctan 总是能够通过合适的选择来保证下一个阶段 $\\phi\u0026rsquo; \u0026lt; 1$ , 如此反复直到 $C = \\emptyset$ , 从而获得最终的胜利.\nArcsin 必胜的情况 # 引理 # 如果 $\\phi(C)\\geq 1$ , 我们可以应用如下的引理:\n设 $x_1\\geq x_2\\geq \u0026hellip;\\geq x_r, r\\geq 2$ 满足 $x_i$ 都是 $2$ 的负幂项, 并且有 $x_1 + x_2 + \u0026hellip; + x_r \\geq 1$ , 则存在一种把 $x_i$ 划分成两个集合中的划分方式, 使得两个集合的和都 $\\geq \\frac{1}{2}$ . 引理的应用 # 由此可见, 假如 $\\phi(C)\\geq 1$ , 那么 Arcsin 一定能找到 $S$ 使得 $min{\\phi\u0026rsquo;(S), \\phi\u0026rsquo;(C\\setminus S)} \\geq 1$ , 由此归纳, 随着集合大小的不断减少, 总会出现 $c\\in C$ 满足 $a(c) = 0$ , 故 Arcsin 总能获胜.\n引理的证明 # 下面我们来证明这个引理. 不失一般性, 我们可以假定 $x_1 + x_2 + \u0026hellip; + x_r = 1$ . $r = 2$ 时, 引理的正确性是显而易见的. $r \\geq 3$ 时, 由于 $x_i$ 都是 $2$ 的负幂, 且 $x_1 + x_2 + \u0026hellip; + x_r = 1$ , 故必有 $x_{r - 1} = x_r$ , 在集合划分时, 我们把 $x_{r - 1}$ 和 $x_r$ 放到一个集合里, 可以视作在原序列中用 $x_{r - 1} + x_r$ 代替了 $x_{r - 1}, x_r$ . 这个过程可以不断重复直到只剩下 $2$ 个元素的平凡情况. 这样我们就归纳地构造了合法的划分.\n补充 # 本题的出处是 Joel Spencer 的论文 Randomization, Derandomization, and Antirandomization: Three games 中提出的 \u0026ldquo;Tenure Game\u0026rdquo; . 该论文发表于 Theoretical Computer Science 131 (1994), 415-430 .\n","date":"17 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-4-vacancy-puzzle/","section":"Posts","summary":"Puzzle Toad-4 Vacancy Puzzle # 题目翻译 # 敬爱的领袖 Aldan 的提前退休给 Zocor 的 Malthusian 市的执政三巨头留下了一个空缺.","title":"Puzzle Toad-4 Vacancy Puzzle"},{"content":"Puzzle Toad-3 Take the last chip # 题目翻译 # Turkey Sandwich 很担心即将到来的离散数学考试, 难以入睡. Turkey 一大早就被恶魔般的笑声唤醒了, 他看到一个顽皮的小矮人坐在床的尽头, 旁边是一堆看上去有无限多的薯条. 小矮人说: \u0026quot; Turkey 你好, 你愿意玩一个小游戏吗? 这堆薯条一共有 43546758343209876 个, 并且底部的薯条代表你永恒的灵魂. 游戏规则很简单, 第一个玩家拿走一些薯条, 但不能拿走全部的薯条. 之后我们轮流拿走一些薯条. 唯一的限制就是一个玩家拿走的薯条不能超过前一轮玩家拿走的薯条数. 拿走最后一个薯条的人获得胜利. 如果我赢了, 我就取走你的灵魂; 而如果你赢了, 你就会在考试中拿到 A . 你是要先手还是后手? \u0026quot; 对于 Turkey 来讲, 这似乎是一个合理的赌局. 你能够给 Turkey 一个策略, 让他能够应对任意薯条数的赌局吗? 如果上面这个问题对你来说太简单, 那么把规则修改成 \u0026ldquo;一个玩家拿走的薯条不能超过前一轮玩家拿走的薯条数的两倍\u0026rdquo; , 此时最优的策略是什么?\n解答 # 这里先分别给出两个问题的解答, 再来看看原站给出的解答.\nQ1 # $n = 1$ 时, 游戏无法进行, 不作讨论. $n = 2$ 时, 先手只能拿走 $1$ 个, 后手必胜. $n$ 为奇数时, 先手只要拿走 $1$ 个就可以, 之后每轮玩家都只能拿走 $1$ 个, 最后一个由先手玩家拿走, 先手必胜. $n$ 为偶数时, 如果当前局面下剩余薯条数为偶数, 那么拿走奇数个一定是必败的, 因为这会使得对面进入到必胜局面. 所以双方每次不得不拿偶数个, 这等价于 $\\frac{n}{2}$ 的情形. 如果 $n = 2^k$ , 那么等价于 $n = 2$ 的情形, 后手必胜; 否则等价于 $n$ 为奇数的情形, 先手必胜. 综上, $n = 2^k$ 时, 后手必胜; 其余情况先手必胜\nQ2 # Q2 是一个经典的博弈问题 \u0026quot; 斐波那契博弈 \u0026quot; . 我们来证明, 先手必胜当且仅当 $n$ 不是斐波那契数. 记斐波那契数列为 $f_1 = 1, f_2 = 2, f_3 = 5, \u0026hellip;$ . $n = 1, 2$ 时同 Q1 .\n后手必胜: n 为斐波那契数 # 假设 $\\forall\\ i\\leq k$ , $n = f_i$ 均满足后手必胜. 考虑 $i = k + 1, n = f_{k + 1}$ 的情形. 此时, $n = f_{k - 1} + f_k$ . 假设先手取走的数量 $\\geq f_{k - 1}$ , 则由于 $f_k \u0026lt; 2\\times f_{k - 1}$ , 后手一次可以取走剩余所有薯条, 故先手第一次取走的数量应该 $\u0026lt; f_{k - 1}$ . 在这种情况下, 我们把 $n$ 个薯条看成两堆薯条 $f_{k - 1}$ 和 $f_{k}$ . 对于 $f_{k - 1}$ , 由归纳假设可知, 无论先手怎么取, 后手都能取到这一堆的最后一根. 记后手取最后一根时取走的薯条数为 $x$ , 则先手在 $f_{k}$ 堆第一次取至多取走 $2x$ 个, 由归纳假设可知, 如果 $2x \u0026lt; f_k$ , 即先手不能一次性取完 $f_k$ 堆时, 后手必胜. 所以我们下面来寻找 $x$ 的最大值. 由于 $x + \\frac{x}{2} \\leq f_{k - 1}$ , 有 $x\\leq \\frac{2}{3} f_{k - 1}$ . 由归纳法不难得到 $\\frac{2}{3} f_{k - 1} \u0026lt; \\frac{1}{2}f_k$ , 故 $2x \u0026lt; f_k$ 成立, 该情况下先手必败.\n先手必胜: n 不为斐波那契数 # 先介绍一下齐肯多夫 (Zeckendorf) 定理: 任何正整数都可以表示成若干个不连续的斐波那契数之和, 这种表示方法可以由贪心算法 (每次选出最大可能的斐波那契数得到) . 对于 $n$ 不为斐波那契数的情况, 根据齐肯多夫定理, $n$ 可以写成 $f_{a_1}+ f_{a_2} + \u0026hellip; + f_{a_p}$ , 其中 $a_i + 1 \u0026lt; a_{i + 1}$ . 先手先取完 $f_{a_1}$ 这一堆, 由于 $a_i + 1 \u0026lt; a_{i + 1}$ , 故后手至多取 $2\\times f_{a_1} \u0026lt; f_{a_2}$ 个薯条. 前面已经证明了对于数量为斐波那契数的堆的博弈, 后手可以取到最后一根薯条, 因此本情形中 $a_2$ 堆的最后一根薯条由先手取到. 同理, 对于之后的每一个斐波那契堆, 整局的先手都是这一堆博弈中的后手, 可以取到最后一根薯条, 也可以取到整局游戏的最后一根薯条, 故先手必胜.\nPuzzle Toad 给出的解答 # 一个通用的模型 # 让我们用下面这个形式来概括这个博弈问题: 有两个玩家 $A$ 和 $B$ , 并且 $A$ 先手. 给出一个单调不减的函数 $f: N\\rightarrow N$ , 其中 $N$ 是正整数集合 ${1, 2, \u0026hellip;}$ . 第一次行动中, $A$ 可以取走小于薯条总数的任意数量的薯条. 在之后一系列的行动中, 如果一个玩家取走了 $n$ 个薯条, 那么下一步中的玩家只能取走至多 $f(n)$ 个薯条. 因此, 本题实质上是 $f(n) = n$ 和 $f(n) = 2n$ 的特殊情况.\n引理 # 定义一个集合 $\\mathcal H = {H_1 = 1 \u0026lt; H_2 \u0026lt; \u0026hellip;}$ 来表示先手必败的初始局势. 当然, 对于初始局势 $h\\not \\in \\mathcal H$ , 先手必胜. 下面给出一个定理:\n如果 $f(H_j)\\geq H_j$ , 那么 $H_{j + 1} = H_j + H_l$ , 其中 $H_l = \\underset{i\\leq j}{min}{H_i\\vert f(H_i) \\geq H_j}$ . 如果 $f(H_j) \u0026lt; H_j$ , 则先手必败的局势有限, 并且终止于 $H_j$ . 本题的解答 # 根据这个定理, 我们可以得到:\n对于 $f(n) = n$ 的博弈, $\\mathcal H = {1, 2, 4, \u0026hellip;, 2^k, \u0026hellip;}$ . 对于 $f(n) = 2n$ 的博弈, $\\mathcal H = {1, 2, 3, 5, \u0026hellip;, f_k, \u0026hellip;}$ , 其中 $f_k$ 为斐波那契数. 引理证明 # 接下来我们来证明这个定理. 假设 $f(H_j) \\geq H_j$ , 那么 $H_l = \\underset{i\\leq j}{min}{H_i\\vert f(H_i) \\geq H_j}$ 一定存在. 对于任何先手必败态 $H_i \u0026lt; H_l$ , 都有 $f(H_i) \u0026lt; H_j$ . 所以对于 $H_j + H_i$ 的初始局面, 玩家 $A$ 可以先取走 $H_i$ 个薯条, 这样留给 $B$ 的就是 $H_j$ 的先手必败态, 所以 $H_j + H_i$ 就是一个先手必胜态. 考虑一个先手必胜态 $x \u0026lt; H_l$ . 对于 $H_j + x$ 的初始局势, 玩家 $A$ 总能找到一个策略取走前 $x$ 个石子的最后一个薯条, 并且最后一次取走的薯条数为 $y$ , 且满足 $f(y) \u0026lt; H_j$ . 这样操作后, 留给 $B$ 的局面就是初始为 $H_j$ 且无法一次性取走所有薯条的先手必败局面, 这对于 $A$ 来说就是一个先手必胜态. (玩家 $A$ 总是拥有这样的策略来保证 $f(y) \u0026lt; H_j$ . 因为假设对于某一个操作方案, $A$ 移走 $x$ 堆最后一根薯条时的一共取走 $y$ 个薯条, 有 $f(y) \\geq H_j$ , 则 $y \u0026lt; H_l$ 必然是一个先手必胜态 (否则与 $H_l$ 的定义矛盾) . 此时 $A$ 只需要考虑在一堆数量 $y$ 的薯条中取走最后一根薯条时所取走的薯条个数 $y\u0026rsquo;$ . 通过这种迭代, $A$ 合法操作方案中取走 $x$ 堆最后一根薯条时取走的薯条个数 $y$ 是严格单调减的, 总能找到一种方案使得 $f(y) \u0026lt; H_j$) . 最后, 对于 $H_j + H_l$ 的初始局势, 如果 $A$ 第一次取走了至少 $H_l$ 根薯条, 因为 $f(H_l) \\geq H_j$ , 此时 $B$ 可以一次性取走剩下的所有薯条从而获胜; 如果玩家 $A$ 取走的薯条数 $\u0026lt; H_l$ , 问题就转化成了我们前面探讨过的两种情况( $H_j + H_i$ 或 $H_j + x$ )之一 , 只不过先后手交换了, 这时 $B$ 作为新局势的先手, 自然是必胜的. 至此我们把引理的第一部分证明了, 接下来证明第二部分. 假设 $f(H_j) \u0026lt; H_j$ , 如果存在必败态 $H_{j + 1} = H_j + x, x \u0026gt; 0$ . 类似前文可知, $x$ 不能为某个必败态 $H_i$, 否则玩家 $A$ 先取走 $H_i$ 个薯条, 必然有 $f(H_i) \\leq f(H_j) \u0026lt; H_j$ , 留给 $B$ 的是一个必败态 $H_j$ , 这与 $H_{j + 1}$ 为 $A$ 的必败态矛盾. 故 $x$ 只能是一个必胜态. 同样类似前文可知, 对于 $H_{j + 1}$ 的初始局势, $A$ 可以取走 $x$ 堆的最后一根薯条, 并且最后一次取走的个数 $y$ 满足 $f(y) \u0026lt; H_j$ , 留给 $B$ 一个必败态 $H_j$ , 这与 $H_{j + 1}$ 为 $A$ 的必败态矛盾. 故不存在 $H_{j + 1}$ .\n","date":"16 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-3-take-the-last-chip/","section":"Posts","summary":"Puzzle Toad-3 Take the last chip # 题目翻译 # Turkey Sandwich 很担心即将到来的离散数学考试, 难以入睡.","title":"Puzzle Toad-3 Take the last chip"},{"content":"CodeForces-66D Petya and His Friends # 题目大意 # 给定 $n$ $(2\\leq n\\leq 50)$, 构造 $a_1, a_2,\u0026hellip;, a_n$ 使得:\n$gcd(a_i, a_j) \\not = 1, \\forall\\ 1\\leq i, j\\leq n$ $gcd(a_1, a_2, \u0026hellip;, a_n) = 1$ $a_i\\not = a_j, \\forall\\ 1\\leq i\\not = j\\leq n$ 如果不存在合法构造, 输出 $-1$ .\nSolution 1 # $n = 2$ 时, 前两条要求矛盾, 输出 $-1$ . $n \\geq 3$ 时, 满足题意的构造均存在. 考虑 $a_1, a_2, \u0026hellip;, a_n$ 的因子 (不妨用 Venn 图来理解) , 用 $2, 3, 5$ 作为基本因子, 任意一个元素包含其中两个即可. 一个简单的构造如下: $2\\times 3, 2\\times 5, 3\\times 5, 2\\times 3\\times 5, 2^2\\times 3\\times 5, \u0026hellip;, 2^{n - 3}\\times 3\\times 5$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; if (n == 2) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; return 0; } cout\u0026lt;\u0026lt;6\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;10\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;15\u0026lt;\u0026lt;endl; ll res = 15; for (int i = 3; i \u0026lt; n; i++) { res *= 2; cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } return 0; } ","date":"15 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-66d-petya-and-his-friends/","section":"Posts","summary":"CodeForces-66D Petya and His Friends # 题目大意 # 给定 $n$ $(2\\leq n\\leq 50)$, 构造 $a_1, a_2,\u0026hellip;, a_n$ 使得:","title":"CodeForces-66D Petya and His Friends"},{"content":"Puzzle Toad-2 Lights of the Round Table and Solution # 题目翻译 # King Arthur 正在准备圆桌会议, 圆桌的座位编号为 $1, 2, \u0026hellip;, n$ , 每个座位前面都有一盏台灯. 当 King Arthur 走进圆桌所在的房间里时, 他发现有些台灯被人关了. 作为国王, King Arthur 不能仅仅直接把熄着的灯打开, 他得命令别人做这件事. 因此, King Arthur 需要在纸条上写好座位的编号, 然后让仆人去按下座位前台灯的开关按钮. 这场会议是讨论驱逐 Merlin 的, 并且只有当所有的台灯都亮着时, 会议才能开始. 通过水晶球, Merlin 可以看到 King Arthur 在纸条上写下的内容, 并且在仆人到达桌子前旋转圆桌, 以便阻止灯到达全部亮起的状态. 仆人可不能自己行事, 违背 King Arthur 的意图是要杀头的. 在什么样的情况下, 无论初始状态如何, King Arthur 总是能够通过下达合适的指令来使得会议顺利进行呢?\n解答 # 必胜情况 # 如果 $n = 1$ , 显然 King Arthur 是必胜的; 如果 $n = 2$ , King Arthur 也是必胜的. 如果灯一亮一灭, King Arthur 让仆人按下任一开关都能把灯变为全灭或全亮的状态 (可以看作化归成了 $n = 1$ 的情况) . 事实上, 当 $n = 2^k$ 时, King Arthur 都是必胜的. 我们下面给出两种证明方法.\n归纳证明 # $n = 1$ 时显然有必胜策略. 假设对于 $n = 2^k$ , King Arthur 拥有必胜策略. 考虑 $n = 2 ^{k + 1}$ , 我们把 $i$ 和 $i + 2^k$ 两盏灯看作一盏 \u0026ldquo;超级灯\u0026rdquo; , 定义只有当这两盏灯的状态相同时, 超级灯才亮. 显然对于 $1, 2, \u0026hellip;, 2^k$ 中的灯操作等价于对超级灯进行操作. 由归纳假设, 对于这 $2^k$ 栈超级灯, King Arthur 可以安排仆人把它们全部打开. 此时根据超级灯的定义, $i$ 和 $i + 2^k$ 都亮或者都灭. 重新定义只有当两盏灯都亮时, 超级灯才亮. 这时, King Arthur 对于 $i$ 和 $i + 2^k$ 同时下达的命令相当于对超级灯下命令. 由归纳假设, 对于这 $n$ 栈重新定义的超级灯, King Arthur 可以把它们全部打开, 这时全部的 $2^{k + 1}$ 栈灯也就都亮了. 综上, $n = 2^k$ 时, King Arthur 拥有必胜策略.\n代数证明 # 上面的证明对于一位中世纪的君王来说有些过于精妙而复杂了. 如果 King Arthur 每次都只让仆人把现在亮着的灯都关了, 能否到达一个所有的灯都熄灭的局面, 以便最后一轮全部打开呢? 这种简单的策略在 $n = 2^k$ 时竟然也是凑效的. 下面我们来证明这一点. 用状态多项式 $b(x) = b_0 + b_1x + \u0026hellip; + b_{n - 1}x^{n - 1}$ 记录 $n$ 个灯的状态. 其中 $b_i$ 考虑模 $2$ 后的数值, $x^i$ 考虑幂次模 $n$ 再 $+1$ 后的数值 (即 $x^{n + i}$ 与 $x^i$ 相同). 如果 $b_j$ 为奇数代表灯亮, 为偶数代表灯灭. King Arthur 让仆人把当前亮着的灯都关掉, 在模 $2$ 意义下相当于把 $b_i$ 中为 $1$ 的变为 $0$ , $b(x) \\leftarrow b(x)(1 + x^0)$ 恰好可以代表这一过程; 而 Merlin 把桌子旋转 $j$ 位相当于把 $(1 + x^0)$ 修改为 $(1 + x^j)$ , 即对 $x^i$ 施加的操作会影响 $x^{i + j}$ . 假设初始的状态多项式为 $t(x)$ , 经过 $m$ 轮操作后的状态多项式为 $$ t(x)\\prod_{t = 1}^{m}(1 + x^{j_t}) $$ 其中, $0\\leq j_1, j_2, \u0026hellip;, j_m\\leq n - 1$ . 假设 $m \\geq n(n - 1) + 1$ , 根据抽屉原理, $\\exist 0\\leq i\\leq n - 1$ , 满足 $i$ 在 $j_1, j_2, \u0026hellip;, j_m$ 中出现了至少 $n$ 次. 下面我们单独计算旋转 $i$ 位造成的影响. 旋转 $2$ 次, 有 $$ (1 + x^i)^2 = 1 + x^i + x^i + x^{2i} = 1 + x^{2i} $$ 重复这一步, 有 $$ (1 + x^i)^{2^p} = 1 + x^{2^pi} $$ 令 $p = k$ , 则 $2^p = 2^k = n$ , 有 $$ (1 + x^i)^n = 1 + x^{ni} = 1 + 1 = 0 $$ 故经过 $m\\geq n(n - 1) + 1$ 轮操作后, 由于 $(1 + x^i)^n = 0$ 的影响, 状态多项式 $t(x)\\prod_{t = 1}^{m}(1 + x^{j_t}) = 0$ , 所有灯全灭. 在下一轮, 所有灯能够全亮, King Arthur 是必胜的.\n必败情况 # 当 $n \\not = 2^k$ 时, King Arthur 都是必败的. 先考虑比较简单的情况: $n$ 为奇数. 如果 $n$ 为奇数且初始状态不为全亮或全灭, 一定存在相邻的两盏灯, 它们恰好为一亮一灭. 由于 $n$ 为奇数, 所以无论 King Arthur 怎样下达命令, 都会存在相邻的两个位置都被选到了或者都没被选到, Merlin 要做的就是把把桌子一亮一灭的两盏灯转到这两个位置. 通过这种操作逻辑, Merlin 总是能够保证有两盏灯一亮一灭, 从而无限期地拖延会议. 对于不为 $2$ 的幂次的偶数 $n$ , $n$ 可以写成 $2^k \\times m$ , 其中 $m$ 是奇数. 把间隔 $2^k$ 的灯放到一组, 把 $n$ 拆分成 $2^k$ 组分别考虑, 每一组都是 $m$ 个. 如果存在一组灯中两盏灯一亮一灭, 对这一组灯套用奇数时的处理策略即可.\n","date":"15 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-2-lights-of-the-round-table-and-solution/","section":"Posts","summary":"Puzzle Toad-2 Lights of the Round Table and Solution # 题目翻译 # King Arthur 正在准备圆桌会议, 圆桌的座位编号为 $1, 2, \u0026hellip;, n$ , 每个座位前面都有一盏台灯.","title":"Puzzle Toad-2 Lights of the Round Table"},{"content":"Puzzle Toad-1 Managers and Engineers # 题目翻译 # FBI 已经包围了 Norne 公司的总部. 公司大楼里有 $n$ 个人, 这些人要么是工程师, 要么是经理. 所有的电脑文件文件都被删除了, 并且所有的文档都被经理们撕碎了. FBI 的审问小组面临的问题是: 如何把大楼里的工程师和经理区分开, 以便关押所有的经理, 并且释放所有的工程师. 大楼里的 $n$ 个人中每个人都知道其它人的身份. 审问的方式是询问 $i$ 号人物: $j$ 号人物1的真实身份是经理还是工程师? 工程师总是讲真话, 但困难点在于, 经理不一定讲真话. 事实上, 这些经理都是邪恶的天才, 他们会想方设法地迷惑审问者.\n假设一半以上的人都是工程师, 能否找到一个策略, 使得最多使用 $n - 1$ 个问题就能找到一个工程师? 假设一半的人是经理, 能否通过一定数量的询问找出一个工程师? 找出一个工程师之后, 自然可以得到所有人的身份. 有没有办法能够用更少的问题确定某个人的身份? 解答 # 设置一个栈 $st$ 存储待处理的人. 在最开始, 随便选一个人放到 $st$ 里. 接下来 $n - 1$ 次操作中, 我们每次从剩下的没有参与询问的人中选一个, 记为 $x$ , 同时询问当前栈顶 $y$ : $x$ 是工程师还是经理? 如果答案是工程师, 就把 $x$ 放到栈顶, 否则把 $y$ 弹出栈顶. 经过 $n - 1$ 轮询问之后, 栈顶一定是一个工程师. 这种询问模式的核心在于, 如果答案是经理, 则至少去掉了一个经理. 由于工程师人数比经理人数多, 最后留在栈顶的一定是工程师.\n否. 经理永远说谎即可, 最终只能划分成两个大小相等的集合, 而不能具体区分其身份.\n如果 $n$ 为偶数, 可以去掉一个人, 转化为 $n - 1$ 规模的问题, 可以少问一次; 如果栈空而只剩下一个人未询问, 这个人也必定是工程师, 可以少问一次.\n","date":"15 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-1-managers-and-engineers/","section":"Posts","summary":"Puzzle Toad-1 Managers and Engineers # 题目翻译 # FBI 已经包围了 Norne 公司的总部.","title":"Puzzle Toad-1 Managers and Engineers"},{"content":"Puzzle Toad # 介绍 # Puzzle Prime 对于 Puzzle Toad 的描述如下:\nThe Puzzle TOAD is a website, created by four Carnegie Melon professors (Tom Bohman, PO Shen-Loh, Alan Frieze, Danny Sleator), where you can find a growing collection of ingenious math brain teasers.\n简而言之, Puzzle Toad 是 CMU 创建的数学趣题网站. 鉴于中文互联网上相对完整的解答翻译较少, 笔者决定开个坑 (用多久填完未定) , 把现有的将近 40 道趣题的题面与解答翻译过来. 由于水平有限, 理解与翻译难免有误, 欢迎提出指正.\n","date":"14 August 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/puzzle-toad/puzzle-toad-0-introduction/","section":"Posts","summary":"Puzzle Toad # 介绍 # Puzzle Prime 对于 Puzzle Toad 的描述如下:","title":"Puzzle Toad-0 Introduction"},{"content":"LeetCode-10 正则表达式匹配 # Solution 1 # 用 $dp[i][j]$ 记录 $s$ 的前 $i$ 个字符和 $p$ 的前 $j$ 个字符是否匹配. 本题中存在两种匹配模式: 单字符匹配 ($s[i]$ 与 $p[j]$ 相同或 $p[j]$ 为单体通配符) 与多字符匹配 ($p[j]$ 为 $$ , 可以匹配任意个 $p[j - 1]$) . 如果 $p[j]$ 不为 $$ , 则 $dp[i][j]$ 取决于 $dp[i - 1][j - 1]$ 与 $s[i]$ 和 $p[j]$ 的单字符匹配情况; 如果 $p[j]$ 为 $$ , 则根据 $s[i], s[i - 1], \u0026hellip;$ 与 $p[j - 1]$ 的匹配情况, $dp[i][j]$ 可以从 $dp[i - 1][j - 2], dp[i - 2][j - 2], \u0026hellip;$ 转化而来. 考虑这一匹配组合的特性, $.$ (这里 $.$ 代表 $.$ 或者小写字母) 能够匹配一次字符后继续使用, 也可以不再匹配字符. 因此, 如果有 $s[i] == p[j - 1]$ , 则 $dp[i][j] = dp[i - 1][j] + dp[i][j - 2]$ , 即 $p$ 的前 $j$ 个字符如果可以匹配 $s$ 的前 $i$ 字符, 也一定能匹配前 $i - 1$ 个字符, 反之亦然, 因为前提条件保证了 $s[i] == p[j - 1]$ ; 而 $p$ 前 $j$ 个字符的末尾两个 ($.*$) 也可以不参与匹配, 即我们使用 $p$ 的前 $j - 2$ 个就可以完成匹配了. 这一部分状态转移简化运用了类似递归的思想. 初始情况下, $dp[0][0]$ 为 $true$ , 我们认为两个空字符串是可以匹配的. 代码如下:\nclass Solution { public: bool isMatch(string s, string p) { int n = s.size(); int m = p.size(); auto match = [\u0026amp;](int i, int j) { //单字符匹配 if (i == 0) { return false; } if (p[j - 1] == \u0026#39;.\u0026#39;) { return true; } return s[i - 1] == p[j - 1]; }; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;bool\u0026gt;(m + 1, false)); dp[0][0] = true; for (int i = 0; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= m; j++) { if (p[j - 1] == \u0026#39;*\u0026#39;) { dp[i][j] = dp[i][j] + dp[i][j - 2]; if (match(i, j - 1)) { dp[i][j] = dp[i][j] + dp[i - 1][j]; } } else { if (match(i, j)) { dp[i][j] = dp[i][j] + dp[i - 1][j - 1]; } } } } return dp[n][m]; } }; ","date":"5 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","section":"Posts","summary":"LeetCode-10 正则表达式匹配 # Solution 1 # 用 $dp[i][j]$ 记录 $s$ 的前 $i$ 个字符和 $p$ 的前 $j$ 个字符是否匹配.","title":"LeetCode-10 正则表达式匹配"},{"content":"CodeForces-735D Taxes # 题目大意 # 给定正整数 $n\\geq 2$ , 把 $n$ 拆分成 $k$ 个 $\\geq 2$ 的正整数 $n_1, n_2, \u0026hellip;, n_k$ , $k$ 任意, 使得 $n_i$ 不为自身的最大因子之和最小.\nSolution 1 # Trick 题. 希望把 $n$ 拆分成尽可能少的素数之和. $n = 2$ 时, 无法拆分, 答案为 $1$ . $n\\geq 4$ 且为偶数时, 根据哥德巴赫猜想 (已验证的部分) , 可以拆分成两个素数之和, 答案为 $2$ . 如果 $n$ 为奇数, 首先判断 $n$ 自身是否为素数, 如果是, 答案为 $1$ ;如果不是, 看 $n$ 能否拆成两个素数之和, 即判断 $n - 2$ 是否为素数, 如果是, 答案为 $2$ ; 如果不是, 则至少拆成三个素数, 拆成其它组合也不会更优, 答案为 $3$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; bool isPrime(int x) { for (int i = 2; i \u0026lt;= sqrt(x) + 1; i++) { if (x % i == 0) { return false; } } return true; } int main() { int n; cin\u0026gt;\u0026gt;n; if (n == 2) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } else if (n % 2 == 0) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; } else { if (isPrime(n)) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } else if (isPrime(n - 2)) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl; } } return 0; } ","date":"5 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-735d-taxes/","section":"Posts","summary":"CodeForces-735D Taxes # 题目大意 # 给定正整数 $n\\geq 2$ , 把 $n$ 拆分成 $k$ 个 $\\geq 2$ 的正整数 $n_1, n_2, \u0026hellip;, n_k$ , $k$ 任意, 使得 $n_i$ 不为自身的最大因子之和最小.","title":"CodeForces-735D Taxes"},{"content":"CodeForces-280B Maximum Xor Secondary # 题目大意 # 给定一个长度为 $n$ 的数组 $a$ , 求 $a$ 的所有长度 $\\geq 2$ 的子数组中最大值与次大值的异或值的最大值.\nSolution 1 # 异或不是关键, 关键是怎样快速找出可能的最大值与次大值对. 一种相对常规的想法是, 我们固定最大值或次大值为 $a_i$ , 向左右寻找合法的次大值. 固定次大值寻找第一个 $\\geq a_i$ 的元素更容易一些, 这部分可以使用单调栈处理. 遍历元素时, 不断弹出栈顶元素直到栈空或者栈顶元素 $\\geq$ 当前元素, 如果栈空, 说明当前元素在这一侧为最大值, 不存在合法数对; 否则, 我们就找到了以当前元素为次大值, 其中一侧的最近的最大值, 这是唯二合法的数对之一. 更新 $ans$ 之后, 把当前元素入栈即可. 用正反两次遍历可以找到所有最大值与次大值的匹配. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } stack\u0026lt;int\u0026gt; st; int ans = 0; for (int i = 0; i \u0026lt; n; i++) { while (!st.empty() \u0026amp;\u0026amp; st.top() \u0026lt; a[i]) { st.pop(); } if (!st.empty()) { ans = max(a[i] ^ st.top(), ans); } st.push(a[i]); } for (int i = n - 1; i \u0026gt;= 0; i--) { while (!st.empty() \u0026amp;\u0026amp; st.top() \u0026lt; a[i]) { st.pop(); } if (!st.empty()) { ans = max(a[i] ^ st.top(), ans); } st.push(a[i]); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"5 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-280b-maximum-xor-secondary/","section":"Posts","summary":"CodeForces-280B Maximum Xor Secondary # 题目大意 # 给定一个长度为 $n$ 的数组 $a$ , 求 $a$ 的所有长度 $\\geq 2$ 的子数组中最大值与次大值的异或值的最大值.","title":"CodeForces-280B Maximum Xor Secondary"},{"content":"CodeForces-1542C Strange Function # 题目大意 # 记 $f(i)$ 为最小的正整数 $x$ , 满足 $x$ 不是 $i$ 的因子. 给定正整数 $n$ , 计算 $\\sum_{i=1}^n f(i)$ .\nSolution 1 # 先分析函数性质, 如果 $f(i) = x$ , 意味着 $1, 2, \u0026hellip;, x - 1$ 都是 $i$ 的因子, 而 $x \\nmid i$ , 即 $lcm(1, 2, \u0026hellip;, x - 1)\\mid i$ , 且 $lcm(1, 2, \u0026hellip;, x)\\nmid i$ . 因此, $1, 2, \u0026hellip;, n$ 中符合 $f(i) = x$ 的数恰有 $\\lfloor \\frac{n}{lcm(1, 2, \u0026hellip;, x - 1)}\\rfloor - \\lfloor \\frac{n}{lcm(1, 2, \u0026hellip;, x)}\\rfloor$ 个, 累加每个 $x$ 对于 $ans$ 的贡献即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { ll n; cin\u0026gt;\u0026gt;n; ll ans = 0; ll lcm = 1; for (ll i = 2; i \u0026lt; n + 2 \u0026amp;\u0026amp; lcm \u0026lt;= n; i++) { ll temp = lcm * i / __gcd(lcm, i); ans = (ans + i * (n / lcm - n / temp)) % MOD; lcm = temp; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"5 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1542c-strange-function/","section":"Posts","summary":"CodeForces-1542C Strange Function # 题目大意 # 记 $f(i)$ 为最小的正整数 $x$ , 满足 $x$ 不是 $i$ 的因子.","title":"CodeForces-1542C Strange Function"},{"content":"CodeForces-808D Array Division # 题目大意 # 给定一个长度为 $n$ 的正整数数组 $a$ , 至多选择 $a$ 的一个元素移动到数组的任意位置, 如果能够使得存在一种分割方式使得 $a$ 的左右两部分和相等, 输出 $YES$ ; 否则输出 $NO$ .\nSolution 1 # 首先 $a$ 的和必须是偶数, 否则直接输出 $NO$ . 由于需要考虑左侧的区间和, 我们计算出 $a$ 的前缀数组 $pre$ . 如果 $\\exist 0\\leq i\\leq n - 1, s.t.\\ pre[i] = \\frac{pre[n - 1]}{2}$ , 则不需要操作就可以达到目的, 输出 $YES$ . 下面考虑移动元素的情况. 如果把左侧的元素移动到右侧, 对于每个 $i$ , 我们考虑所有 $i\\leq j \u0026lt; n$ , 查看是否有 $pre[j] - a_i = \\frac{pre[n - 1]}{2}$ . 但直接这样做时间复杂度为 $O(n^2)$ , 无法通过本题. 根据数组元素均为正整数, $pre$ 数组单调增的特性, 我们可以用二分搜索来将时间复杂度减少至 $O(nlogn)$ . 把右侧元素移动的左侧的情况类似. 对于每个 $i$ , 考虑所有 $0\\leq j \u0026lt; i$ , 查看是否有 $pre[j] + a_i = \\frac{pre[n - 1]}{2}$ 即可, 这一部分同样需要使用二分搜索优化. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0); vector\u0026lt;ll\u0026gt; pre(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; pre[i] = (i == 0)? a[i]: pre[i - 1] + a[i]; } if (pre[n - 1] % 2 == 1) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } for (int i = 0; i \u0026lt; n; i++) { // 不需要移动元素 if (pre[i] == pre[n - 1] / 2 ) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else { // 左侧元素移动至右侧 int left = i; int right = n - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (pre[mid] - a[i] == pre[n - 1] / 2) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else if (pre[mid] - a[i] \u0026lt; pre[n - 1] / 2) { left = mid + 1; } else { right = mid - 1; } } // 右侧元素移动至左侧 left = 0; right = i - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (pre[mid] + a[i] == pre[n - 1] / 2) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else if (pre[mid] + a[i] \u0026lt; pre[n - 1] / 2) { left = mid + 1; } else { right = mid - 1; } } } } cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 我们二分搜索的过程可以使用哈希表代替. 使用两个哈希表分别存储左侧 (包括自身) 的数和右侧数, 判断是否能够通过移动元素将 $pre[i]$ 达到目标值 $\\frac{pre[n - 1]}{2}$ .\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0); vector\u0026lt;ll\u0026gt; pre(n, 0); map\u0026lt;ll, ll\u0026gt; l_map, r_map; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; r_map[a[i]]++; pre[i] = (i == 0)? a[i]: pre[i - 1] + a[i]; } if (pre[n - 1] % 2 == 1) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } for (int i = 0; i \u0026lt; n; i++) { l_map[a[i]]++; // 更新左侧 (包括自身) 的元素 r_map[a[i]]--; // 更新右侧的元素 if (r_map[a[i]] == 0) { // 右侧不存在 a_i 了, 清除 r_map.erase(a[i]); } if (pre[i] == pre[n - 1] / 2) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else if (pre[i] \u0026lt; pre[n - 1] / 2) { // 不足, 从右侧补 if (r_map.count(pre[n - 1] / 2 - pre[i])) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } } else { // 超过, 从左侧删 if (l_map.count(pre[i] - pre[n - 1] / 2)) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; return 0; } } } cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } ","date":"4 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-808d-array-division/","section":"Posts","summary":"CodeForces-808D Array Division # 题目大意 # 给定一个长度为 $n$ 的正整数数组 $a$ , 至多选择 $a$ 的一个元素移动到数组的任意位置, 如果能够使得存在一种分割方式使得 $a$ 的左右两部分和相等, 输出 $YES$ ; 否则输出 $NO$ .","title":"CodeForces-808D Array Division"},{"content":"逆元 学习笔记 # 问题背景 # 我们经常遇到一些需要对运算结果取模的问题. 由于加法、减法、乘法对于模运算都是封闭的, 可以在大量运用取模运算防止溢出. 但除法对于模运算来说并非封闭的, 本来可以整除的情况在取完模之后没法进行除法运算了, 而把之前的结果全部保存又会导致溢出. 因此我们需要找到一种能够在一定程度上代替除法的操作.\n逆元 # 参考加法运算中的相反数, 以及乘法运算中的倒数, 对于模意义下的除法存在逆元, 同样有 $a\\times a^{-1} \\equiv 1\\ (mod\\ p)$ . 那么对于给定的 $a$ 和 $p$ , 怎样计算出 $a$ 在模 $p$ 意义下的逆元呢? 下面介绍两种常见的求解逆元的方法: 费马小定理和扩展欧几里得算法.\n费马小定理 # 费马小定理告诉我们, 若存在整数 $a, p$ , 满足 $gcd(a, p) = 1$ , 则有 $a^{p - 1}\\equiv 1\\ (mod\\ p)$ . 如果 $p$ 已经是素数了, 那么只要 $p\\nmid a$ , 自然有 $a^{p - 1}\\equiv 1\\ (mod\\ p)$ , 即 $a\\times a^{p - 2} \\equiv 1\\ (mod\\ p)$ . $a^{p - 2}$ 恰好就是 $a$ 的逆元. 我们利用快速幂计算出 $a^{p - 2}$ 即可.\n扩展欧几里得算法 # 扩展欧几里得算法用于构造裴蜀定理的合法解, 即对于 $a, b$ , 求出一对 $x, y$ , 满足 $ax + by = gcd(a, b)$ . 对于 $ax\\equiv 1\\ (mod\\ p)$ , 可以转化为 $ax + py\\equiv 1\\ (mod\\ p)$ , 利用扩展欧几里得算法求解.\n","date":"4 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%86%E5%85%83/","section":"Posts","summary":"逆元 学习笔记 # 问题背景 # 我们经常遇到一些需要对运算结果取模的问题.","title":"逆元 学习笔记"},{"content":"CodeForces-1426F Number of Subsequences # 题目大意 # 给定一个长度为 $n$ 且由 $a,b,c,?$ 四种字符构成的字符串 $s$ . 每个 $?$ 都可能是 $a, b, c$ 三种字符中的任意一种. 求 $s$ 的所有变化中子序列 $abc$ (不要求连续) 出现的次数.\nSolution 1 # 要求出 $s$ 所有变化中子序列 $abc$ 的出现次数, 显然一个 $abc$ 匹配中, 需要的 $?$ 越多, 它在所有变化中出现得次数就越少. 我们根据这一点, 根据 $?$ 个数分别统计 $abc$ 的个数, 用 $cnt$ 数组记录. 怎么快速地进行统计呢? 考虑从左向右遍历, 遇到 $c$ 或 $?$ 时, 才可能产生新的 $abc$ , 对于一个 $c$ 或 $?$ , 我们需要知道, 在它前面一共出现了多少次 $ab, ?b, a?, ??$ . 以 $ab$ 为例, 这一部分实质上是对 $b$ 前面 $a$ 的个数的累加 (类似前缀和的前缀和) . 第一次遍历, 我们记录每个元素前面 $a$ 的个数和 $?$ 的个数. 第二次遍历, 遇到 $b$ , 我们就累加 $a$ 和 $?$ 的个数, 遇到 $c$ 我们就计算匹配子序列的个数, 遇到 $?$ 的情况特殊一点, 我们先把 $?$ 视作 $c$ , 计算匹配子序列的个数, 再把 $?$ 视作 $b$ , 计算匹配前缀的个数, 注意这两步顺序是不可以颠倒的. 得到 $cnt$ 数组后, 我们就能计算出 $ans$ 了. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; ll quickpow(ll x, ll n){ ll res = x; ll ans = 1; while (n) { if(n \u0026amp; 1){ ans = (ans * res) % MOD; } res = (res * res) % MOD; n = n\u0026gt;\u0026gt;1; } return ans; } int main() { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;ll\u0026gt; pre_a(n + 1, 0); vector\u0026lt;ll\u0026gt; pre_d(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { pre_a[i] = (pre_a[i - 1] + (s[i - 1] == \u0026#39;a\u0026#39;)) % MOD; // 记录每个字符前面有多少个 a pre_d[i] = (pre_d[i - 1] + (s[i - 1] == \u0026#39;?\u0026#39;)) % MOD; // 记录每个字符前面有多少个 ? } ll cnt_ab = 0, cnt_ad = 0, cnt_db = 0, cnt_dd = 0; // 匹配前缀的累加数量 ll ans = 0; vector\u0026lt;ll\u0026gt; cnt(4, 0); for (int i = 0; i \u0026lt; n; i++) { if (s[i] == \u0026#39;b\u0026#39;) { cnt_ab = (cnt_ab + pre_a[i]) % MOD; cnt_db = (cnt_db + pre_d[i]) % MOD; } else if (s[i] == \u0026#39;?\u0026#39;) { cnt[1] = (cnt[1] + cnt_ab) % MOD; cnt[2] = (cnt[2] + cnt_db + cnt_ad) % MOD; cnt[3] = (cnt[3] + cnt_dd) % MOD; cnt_ad = (cnt_ad + pre_a[i]) % MOD; cnt_dd = (cnt_dd + pre_d[i]) % MOD; } else if (s[i] == \u0026#39;c\u0026#39;) { cnt[0] = (cnt[0] + cnt_ab) % MOD; cnt[1] = (cnt[1] + cnt_db + cnt_ad) % MOD; cnt[2] = (cnt[2] + cnt_dd) % MOD; } } for (int i = 0; i \u0026lt; 4; i++) { if (i \u0026lt;= pre_d[n]) { ans = (ans + cnt[i] * quickpow(3, pre_d[n] - i)) % MOD; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 从匹配子串前缀的角度考虑, 对于 $abc$ , 匹配进度为 $a, ab, abc$ , 不妨用 $f[i][j]$ 记录前 $i + 1$ 个字符中, 第 $j$ 中匹配模式的数量之和. 设一共有 $m$ 个 $?$ , 则可能的字符串一共有 $3^m$ 个. 如果第 $i$ 个字符是 $a$ , 则在 $f[i - 1][j]$ 的基础上又增加了 $3^m$ 个 $a$ , 写成状态转移方程如下: $$ f[i][0] = f[i - 1][0] + 3^m\\ f[i][1] = f[i - 1][1]\\ f[i][2] = f[i - 1][2] $$ 对于 $b$, 则有: $$ f[i][0] = f[i - 1][0]\\ f[i][1] = f[i - 1][0] + f[i - 1][1]\\ f[i][2] = f[i - 1][2] $$ 对于 $c$ , 同样有: $$ f[i][0] = f[i - 1][0]\\ f[i][1] = f[i - 1][1]\\ f[i][2] = f[i - 1][1] + f[i - 1][2] $$ 下面我们来考虑 $?$ 带来的状态转移. 在 $3^m$ 个子串中, $?$ 为 $a, b, c$ 的情况各为 $\\frac{1}{3}$ . 因此对上述三种情况作平均即可. 有如下状态转移方程: $$ f[i][0] = f[i - 1][0] + 3^{m - 1}\\ f[i][1] = \\frac{f[i - 1][0]}{3} + f[i - 1][1]\\ f[i][2] = \\frac{f[i - 1][1]}{3} + f[i - 1][2] $$ 最终所求答案即为 $f[n - 1][2]$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; const ll INV3 = 333333336; // INV3 为 3 关于 1e9 + 7 的逆元 ll quickpow(ll x, ll n){ ll res = x; ll ans = 1; while (n) { if(n \u0026amp; 1){ ans = (ans * res) % MOD; } res = (res * res) % MOD; n = n\u0026gt;\u0026gt;1; } return ans; } int main() { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; ll m = 0; for (char ch: s) { if (ch == \u0026#39;?\u0026#39;) { m++; } } m = quickpow(3, m); // 计算 3 ^ m vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n, vector\u0026lt;ll\u0026gt;(3)); dp[0][0] = (s[0] == \u0026#39;a\u0026#39;) * m + (s[0] == \u0026#39;?\u0026#39;) * m * INV3 % MOD; for (int i = 1; i \u0026lt; n; i++) { if (s[i] != \u0026#39;?\u0026#39;) { dp[i][0] = (s[i] == \u0026#39;a\u0026#39;)? (dp[i - 1][0] + m) % MOD: dp[i - 1][0]; dp[i][1] = (s[i] == \u0026#39;b\u0026#39;)? (dp[i - 1][0] + dp[i - 1][1]) % MOD: dp[i - 1][1]; dp[i][2] = (s[i] == \u0026#39;c\u0026#39;)? (dp[i - 1][1] + dp[i - 1][2]) % MOD: dp[i - 1][2]; } else { dp[i][0] = (dp[i - 1][0] + m * INV3) % MOD; dp[i][1] = (dp[i - 1][0] * INV3 + dp[i - 1][1]) % MOD; dp[i][2] = (dp[i - 1][1] * INV3 + dp[i - 1][2]) % MOD; } } cout\u0026lt;\u0026lt;dp[n - 1][2]\u0026lt;\u0026lt;endl; return 0; } Solution 3 # 一种清晰的分割方式是根据中心点分割. 对于每个 $b$ 或 $?$ , 统计其左侧的 $a$ 和 $?$ , 以及右侧的 $c$ 和 $?$ . 注意这种统计方式下, $b$ 和 $?$ 是没有区别的, 两者所在的字符串数量只由左侧和右侧的 $?$ 数量决定 (这一步其实已经把 $?$ 自身给排除了) . 设左侧有 $l_a$ 个 $a$ , $l_d$ 个 $?$ , 右侧有 $r_c$ 个 $c$ , $r_d$ 个 $?$ . 则匹配模式的个数如下所示: $$ ac:\\ l_a \\times r_c \\times 3^{l_d + r_d} \\ ?c:\\ l_d \\times r_c \\times 3^{l_d + r_d - 1} \\ a?:\\ l_a \\times r_d \\times 3^{l_d + r_d - 1} \\ ??:\\ l_d \\times r_d \\times 3^{l_d + r_d - 2} $$ 累加即可得到答案. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MOD = 1e9 + 7; const ll INV3 = 333333336; ll quickpow(ll x, ll n){ ll res = x; ll ans = 1; while (n) { if(n \u0026amp; 1){ ans = (ans * res) % MOD; } res = (res * res) % MOD; n = n\u0026gt;\u0026gt;1; } return ans; } int main() { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;ll\u0026gt; l_a(n, 0), l_d(n, 0), r_c(n, 0), r_d(n, 0); for (int i = 0; i \u0026lt; n; i++) { l_a[i] = i == 0? 0: l_a[i - 1] + (s[i - 1] == \u0026#39;a\u0026#39;); l_d[i] = i == 0? 0: l_d[i - 1] + (s[i - 1] == \u0026#39;?\u0026#39;); r_c[n - 1 - i] = i == 0? 0: r_c[n - i] + (s[n - i] == \u0026#39;c\u0026#39;); r_d[n - 1 - i] = i == 0? 0: r_d[n - i] + (s[n - i] == \u0026#39;?\u0026#39;); } ll ans = 0; for (int i = 1; i \u0026lt; n - 1; i++) { if (s[i] == \u0026#39;b\u0026#39; || s[i] == \u0026#39;?\u0026#39;) { ll pow = quickpow(3, l_d[i] + r_d[i]); ans = (ans + ((l_a[i] * r_c[i]) % MOD * pow) % MOD) % MOD; ans = (ans + ((l_d[i] * r_c[i]) % MOD * pow) % MOD * INV3) % MOD; ans = (ans + ((l_a[i] * r_d[i]) % MOD * pow) % MOD * INV3) % MOD; ans = (ans + (((l_d[i] * r_d[i]) % MOD * pow) % MOD * INV3) % MOD * INV3) % MOD; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"4 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1426f-number-of-subsequences/","section":"Posts","summary":"CodeForces-1426F Number of Subsequences # 题目大意 # 给定一个长度为 $n$ 且由 $a,b,c,?","title":"CodeForces-1426F Number of Subsequences"},{"content":"CodeForces-1186D Vus the Cossack and Numbers # 题目大意 # 给定 $n$ 的和为 $0$ 的浮点数数组 $a_1, a_2, \u0026hellip;, a_n$ , 构造出一个和为 $0$ 的整数数组 $b_1, b_2, \u0026hellip;, b_n$ , 满足 $b_i = \\lfloor a_i\\rfloor$ 或 $\\lceil a_i\\rceil$ .\nSolution 1 # 不妨设浮点数数组不包含恰好为整数的数. 假设合题意的构造中有 $x$ 个数向上取整 (设为前 $x$ 个数) , 则有 $0 = \\sum_{i = 1}^{n} b_i = \\sum_{i = 1}^{x} (1 + \\lfloor a_i\\rfloor) + \\sum_{i = x + 1}^{n} \\lfloor a_i\\rfloor = x + \\sum_{i = 1}^{n}(\\lfloor a_i\\rfloor - a_i)$ , 故 $x = \\sum_{i = 1}^{n}(a_i - \\lfloor a_i \\rfloor)$ . 计算出 $x$ 后, 构造 $b$ 即可. 需要注意一些精度方面的问题. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;double\u0026gt; a(n, 0); vector\u0026lt;int\u0026gt; b(n, 0); double sum = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; sum += a[i] - floor(a[i]); } int int_sum; if (sum - floor(sum) \u0026lt; 1e-6) { int_sum = floor(sum); } else { int_sum = ceil(sum); } for (int i = 0, cnt = 0; i \u0026lt; n; i++) { if (a[i] - floor(a[i]) \u0026lt; 1e-6) { b[i] = int(a[i]); } else { b[i] = cnt \u0026lt; int_sum? ceil(a[i]): floor(a[i]); cnt++; } cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;endl; } return 0; } Solution 2 # 在 Solution 1 中, 我们通过计算得到了上取整的元素个数. 一种更本质的想法是, $\\sum_{i = 1}^{n}\\lfloor a_i\\rfloor \\leq \\sum_{i = 1}^{n} a_i = 0, \\sum_{i = 1}^{n}\\lceil a_i\\rceil \\geq \\sum_{i = 1}^{n}a_i = 0$ .初始令 $b_i = \\lfloor a_i\\rfloor$ , 不断地让 $b$ 中的不为整数的元素 $+ 1$ . 类似介值定理, 一定有一刻整个数组和恰为 $0$ , 这样就得到了一个合法的构造. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;double\u0026gt; a(n, 0); vector\u0026lt;int\u0026gt; b(n, 0); int sum = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; b[i] = floor(a[i]); sum += b[i]; } for (int i = 0; i \u0026lt; n; i++) { if (sum \u0026lt; 0 \u0026amp;\u0026amp; a[i] - b[i] \u0026gt; 1e-6) { b[i]++; sum++; } cout\u0026lt;\u0026lt;b[i]\u0026lt;\u0026lt;endl; } return 0; } ","date":"3 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1186d-vus-the-cossack-and-numbers/","section":"Posts","summary":"CodeForces-1186D Vus the Cossack and Numbers # 题目大意 # 给定 $n$ 的和为 $0$ 的浮点数数组 $a_1, a_2, \u0026hellip;, a_n$ , 构造出一个和为 $0$ 的整数数组 $b_1, b_2, \u0026hellip;, b_n$ , 满足 $b_i = \\lfloor a_i\\rfloor$ 或 $\\lceil a_i\\rceil$ .","title":"CodeForces-1186D Vus the Cossack and Numbers"},{"content":"","date":null,"permalink":"/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/","section":"Tags","summary":"","title":"浮点数"},{"content":"CodeForces-1060C Maximum Subrectangle # 题目大意 # 给定长度为 $n$ 的数列 $a$ 和长度为 $m$ 的数列 $b$ , 根据 $a, b$ 构造出一个 $n \\times m$ 的矩阵 $c$ , 满足 $c_{ij} = a_i\\times b_j$ . 给出一个上界 $x$ , 求 $c$ 的所有子矩阵中, 元素和不超过 $x$ 的子矩阵的最大面积.\nSolution 1 # 子矩阵面积 $\\sum_{i = x_1}^{x_2}\\sum_{j = y_1}^{y_2}c_{ij} = \\sum_{i = x_1}^{x_2}a_i\\times \\sum_{j = y_1}^{y_2}b_j$ , 实际上是寻找 $a, b$ 的子段和, 在满足子段和积 $\\leq x$ 的条件下寻找子段长度积的最大值. 因此, 我们希望对于一个子段, 在值尽可能小的情况下, 长度尽可能大. 为了遍历所有情况, 我们固定长度, 记录 $a, b$ 每个长度子段的最小值, 再两两匹配, 如果满足条件再更新最大积. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;ll\u0026gt; a(n, 0), b(m, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i] += (i == 0)? 0: a[i - 1]; } for (int i = 0; i \u0026lt; m; i++) { cin\u0026gt;\u0026gt;b[i]; b[i] += (i == 0)? 0: b[i - 1]; } ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; len_a(n + 1, 1e9 + 7), len_b(m + 1, 1e9 + 7); for (int len = 1; len \u0026lt;= n; len++) { for (int i = len - 1; i \u0026lt; n; i++) { ll seq_sum = (i == len - 1)? a[i]: a[i] - a[i - len]; len_a[len] = min(len_a[len], seq_sum); } } for (int len = 1; len \u0026lt;= m; len++) { for (int i = len - 1; i \u0026lt; m; i++) { ll seq_sum = (i == len - 1)? b[i]: b[i] - b[i - len]; len_b[len] = min(len_b[len], seq_sum); } } int ans = 0; for (int i = 1; i \u0026lt;= n; i++) { for (int j = m; j \u0026gt;= 0; j--) { if (len_a[i] * len_b[j] \u0026lt;= x) { ans = max(ans, i * j); break; } } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 记录这道题目, 主要目的是学习一种枚举的思想: 对于约束很多的优化问题, 可以固定一个约束, 考虑另一个约束的最优值. 这样在遍历时可以节约很多时间.\n","date":"3 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1060c-maximum-subrectangle/","section":"Posts","summary":"CodeForces-1060C Maximum Subrectangle # 题目大意 # 给定长度为 $n$ 的数列 $a$ 和长度为 $m$ 的数列 $b$ , 根据 $a, b$ 构造出一个 $n \\times m$ 的矩阵 $c$ , 满足 $c_{ij} = a_i\\times b_j$ .","title":"CodeForces-1060C Maximum Subrectangle"},{"content":"CodeForces-1043D Mysterious Crime # 题目大意 # 给定 $m$ 个 $1, 2, \u0026hellip;, n$ 的排列, 求这些排列共同拥有的连续子数组的个数.\nSolution 1 # 用矩阵 $a[i][j], 0\\leq i\\leq m - 1, 0\\leq j\\leq n - 1$ 来记录这些排列. 共同的连续子数组也必须是 $a[0]$ 的连续子数组. 考虑一个包含了 $a[0][j]$ 的最长子数组是否包含 $a[0][j + 1]$ , 我们就需要知道在其它 $m - 1$ 个数组中, 值为 $a[0][j]$ 和 $a[0][j + 1]$ 的元素的下标 $pos_0$ 和 $pos_1$ , 如果 $pos_1 = pos_0 + 1$ 在这 $m - 1$ 个数组中都成立, 则我们的连续子数组可以继续延长. 因此, 在读取数组 $a$ 时, 用 $pos[i][a[i][j]] = j$ 来记录各个值得下标, 方便后续的判断. 我们从 $a[0][0]$ 遍历到 $a[0][n - 1]$ , 记录各个值所在的连续子数组最长的长度是多少. 对于一个长度为 $len$ 的连续子数组, 它一共拥有 $\\frac{len\\times (len + 1)}{2}$ 个子数组 (包括自身) , 我们累加就能得到答案. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(m, vector\u0026lt;int\u0026gt;(n, 0)); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(m, vector\u0026lt;int\u0026gt;(n + 1, 0)); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i][j]); pos[i][a[i][j]] = j; } } ll cnt = 1; ll ans = 0; for (int j = 1; j \u0026lt; n; j++) { bool isValid = true; for (int i = 1; i \u0026lt; m \u0026amp;\u0026amp; isValid; i++) { if (pos[i][a[0][j]] != pos[i][a[0][j - 1]] + 1) { isValid = false; } } if (isValid) { cnt++; } else { ans += cnt * (cnt + 1) / 2; cnt = 1; } } ans += cnt * (cnt + 1) / 2; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"3 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1043d-mysterious-crime/","section":"Posts","summary":"CodeForces-1043D Mysterious Crime # 题目大意 # 给定 $m$ 个 $1, 2, \u0026hellip;, n$ 的排列, 求这些排列共同拥有的连续子数组的个数.","title":"CodeForces-1043D Mysterious Crime"},{"content":"LeetCode-899 有序队列 # Solution 1 # $k = 1$ 时, 每次只能把字符串第一个元素移到最后, 本质上是在环上寻找最小字典序字符串, 可以把 $s$ 复制一份寻找长度为一半的最小字典序字符串; $k \\geq 2$ 时, 经过试验后可以猜想: 任意字符串都能经过有限次操作后变成严格升序的字符串. 由于 $k \u0026gt; 2$ 时的操作比 $k = 2$ 更强, 我们以 $k = 2$ 为例来证明猜想. 从环的意义上考虑, 选择第一个放到末尾相当没有操作, 选择第二个放到末尾相当于交换一对元素. 很显然, 经过有限次两两交换, 我们可以得到一个升序字符串. 代码如下:\nclass Solution { public: string orderlyQueue(string s, int k) { if (k \u0026gt;= 2) { map\u0026lt;char, int\u0026gt; book; for (auto ch: s) { book[ch]++; } string ans = \u0026#34;\u0026#34;; for (auto it = book.begin(); it != book.end(); it++) { for (int i = 0; i \u0026lt; it-\u0026gt;second; i++) { ans += it-\u0026gt;first; } } return ans; } else { s += s; string ans = s.substr(0, s.size() / 2); for (int i = 1; i \u0026lt; s.size() / 2; i++) { if (s.substr(i, s.size() / 2) \u0026lt; ans) { ans = s.substr(i, s.size() / 2); } } return ans; } } }; ","date":"3 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-899-%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/","section":"Posts","summary":"LeetCode-899 有序队列 # Solution 1 # $k = 1$ 时, 每次只能把字符串第一个元素移到最后, 本质上是在环上寻找最小字典序字符串, 可以把 $s$ 复制一份寻找长度为一半的最小字典序字符串; $k \\geq 2$ 时, 经过试验后可以猜想: 任意字符串都能经过有限次操作后变成严格升序的字符串.","title":"LeetCode-899 有序队列"},{"content":"LeetCode-473 火柴拼正方形 # Solution 1 # 回溯算法, 具体的细节见代码注释.\nclass Solution { public: int edges[4]; // edges 记录正方形的四个边 int len = 0; // 记录每条边的长度 bool dfs(int index, vector\u0026lt;int\u0026gt;\u0026amp; matchsticks) { // 递归函数, 考虑第 index 个边的放置能否符合要求 if (index == matchsticks.size()) { // 如果已经放完了, 说明可以拼成正方形, 返回 true return true; } for (int i = 0; i \u0026lt; 4; i++) { // 还没有放完, 依次考虑四条边 edges[i] += matchsticks[index]; // 每条边先加上当前火柴长度 if (edges[i] \u0026lt;= len \u0026amp;\u0026amp; dfs(index + 1, matchsticks)) { // 如果当前边长度 \u0026lt;= len, 还可以继续放, 如果后续的放置满足要求, 则满足要求, 返回 true return true; } edges[i] -= matchsticks[index]; // 回溯, 撤销前面的操作 } return false; // 一直没能找到合法的方案, 返回 false } bool makesquare(vector\u0026lt;int\u0026gt;\u0026amp; matchsticks) { for (int match: matchsticks) { len += match; } if (len % 4 != 0) { // 先计算总长度, 应当是 4 的倍数 return false; } len /= 4; memset(edges, 0, sizeof(edges)); sort(matchsticks.begin(), matchsticks.end(), greater\u0026lt;int\u0026gt;()); // 先从大的火柴棍开始试, 减少搜索量 return dfs(0, matchsticks); } }; ","date":"2 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-473-%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/","section":"Posts","summary":"LeetCode-473 火柴拼正方形 # Solution 1 # 回溯算法, 具体的细节见代码注释.","title":"LeetCode-473 火柴拼正方形"},{"content":"","date":null,"permalink":"/tags/%E9%80%92%E5%BD%92/","section":"Tags","summary":"","title":"递归"},{"content":"LeetCode-1240 铺瓷砖 # Solution 1 # 很标准的回溯算法, 具体的细节见代码注释. 代码如下:\nclass Solution { public: int grid[13][13]; // 0 代表没铺瓷砖, 1 代表铺了瓷砖 int ans = 13 * 13; // 全用 1 × 1 的瓷砖, 答案不超过 13 × 13 void dfs(int n, int m, int cur) { // 递归函数, n × m 的地板, 现在用了 cur 块瓷砖 if (cur \u0026gt;= ans) { // 如果当前所用瓷砖已经超过目前最优解, 不会得到更优解了, 跳过 return; } bool isFull = true; // 记录当前地板是否已经铺满 int row, col; // 记录第一个空格的坐标 for (int i = 0; i \u0026lt; n \u0026amp;\u0026amp; isFull; i++) { for (int j = 0; j \u0026lt; m \u0026amp;\u0026amp; isFull; j++) { if (grid[i][j] == 0) { isFull = false; row = i; col = j; } } } if (isFull) { // 如果铺满了, 更新答案 ans = cur; return; } // 如果没有铺满, 从大到小开始试瓷砖 for (int len = min(n - row, m - col); len \u0026gt;=1; len--) { bool isEmpty = true; // 判断 len 大小的瓷砖占用的地方是否是空地 for (int i = row; i \u0026lt; row + len \u0026amp;\u0026amp; isEmpty; i++) { for (int j = col; j \u0026lt; col + len \u0026amp;\u0026amp; isEmpty; j++) { if (grid[i][j] == 1) { isEmpty = false; } } } if (!isEmpty) { // 如果不是空地, 说明 len 太大, 到循环的下一步试更小的瓷砖 continue; } else { // 如果是空地, 说明 len 可用, 继续递归, 先把当前的铺满 for (int i = row; i \u0026lt; row + len; i++) { for (int j = col; j \u0026lt; col + len; j++) { grid[i][j] = 1; } } dfs(n, m, cur + 1); // 递归下一步, 所用瓷砖数量 + 1 // 回溯, 把这一步铺的瓷砖撤销, 不影响循环的下一步 for (int i = row; i \u0026lt; row + len; i++) { for (int j = col; j \u0026lt; col + len; j++) { grid[i][j] = 0; } } } } } int tilingRectangle(int n, int m) { if (n == m) { // 简单情况直接返回答案 return 1; } memset(grid, 0, sizeof(grid)); // 初始化空地 dfs(n, m, 0); // 开始递归 return ans; } }; 补充 # 关于这道题目, LeetCode 的题解区 有不少文章都讲解了动态规划的算法 (复杂度$O(n^4)$) , 这些算法能通过本题数据 $(n, m \\leq 13)$ , 但在更大的数据下存在反例. 本问题事实上是 NP 完全问题, 不存在多项式时间内的解法, 上文所用的 dfs 回溯才是正确的解法.\n","date":"2 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1240-%E9%93%BA%E7%93%B7%E7%A0%96/","section":"Posts","summary":"LeetCode-1240 铺瓷砖 # Solution 1 # 很标准的回溯算法, 具体的细节见代码注释.","title":"LeetCode-1240 铺瓷砖"},{"content":"CodeForces-1381A2 Prefix Flip (Hard Version) # 题目大意 # 给定两个长度为 $n$ 的 $01$ 字符串 $a, b$ , 每次操作可以选择 $a$ 的一个前缀, 先把 $0$ 变成 $1$ , $1$ 变成 $0$ , 再反转前缀. 要求用不超过 $2n$ 次操作把 $a$ 变成 $b$ , 输出操作序列.\nSolution 1 # 容易想到的操作就是模拟, 从后往前操作. 用至多 $2$ 次操作就可以把一位变成与 $b$ 相同. 这种方法可以通过本题的 Easy 版本, 但 $O(n^2)$ 的复杂度不足以通过 Hard 版本. 能否从一个角度思考, 不需要修改字符串本身呢? 一种巧妙的解法是, 我们把 $a$ 变成 $b$ 的过程拆分成两个子过程: $a$ 变为全 $0/1$ 字符串, 再由全 $0/1$ 字符串变为 $b$ . 进一步转化, 可以看作把 $a$ 和 $b$ 分别变为全 $0/1$ 字符串, 如果两个全 $0/1$ 字符串不同, 再用一次操作反转即可. 其中 $b$ 的操作是对 $a$ 的操作的逆序, 我们应该倒着输出. 把 $a, b$ 变成全 $0/1$ 字符串只需要检查每一位与后一位是否相同, 如果不同就对整个前缀进行操作即可, 对于每个字符串, 这一步至多需要 $n - 1$ 步, 总共的步骤至多为 $2\\times (n - 1) + 1 = 2 n - 1$ 步, 符合要求. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; string a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; vector\u0026lt;int\u0026gt; a_o, b_o; a_o.resize(0); b_o.resize(0); for (int i = 0; i \u0026lt; n - 1; i++) { if (a[i] != a[i + 1]) { a_o.push_back(i + 1); } if (b[i] != b[i + 1]) { b_o.push_back(i + 1); } } if (a[n - 1] != b[n - 1]) { a_o.push_back(n); } cout\u0026lt;\u0026lt;a_o.size() + b_o.size()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for (int x: a_o) { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for (int i = b_o.size() - 1; i \u0026gt;= 0; i--) { cout\u0026lt;\u0026lt;b_o[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"1 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1381a2-prefix-flip-hard-version/","section":"Posts","summary":"CodeForces-1381A2 Prefix Flip (Hard Version) # 题目大意 # 给定两个长度为 $n$ 的 $01$ 字符串 $a, b$ , 每次操作可以选择 $a$ 的一个前缀, 先把 $0$ 变成 $1$ , $1$ 变成 $0$ , 再反转前缀.","title":"CodeForces-1381A2 Prefix Flip (Hard Version)"},{"content":"CodeForces-706C Hard problem # 题目大意 # 给定 $n$ 个字符串 $s_1, s_2, \u0026hellip;, s_n$ 和反转它们需要的代价 $a_1, a_2, \u0026hellip;, a_n$ . 返回把字符串数组修改成按字典序排列的最少代价; 如果不能做到这一点, 返回 $-1$ .\nSolution 1 # 对于一个字符串, 我们可以反转, 也可以选择不反转, 根据前一个字符串是否反转, 可以得到相应的代价变化. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long const ll MAXN = 1e15 + 10; string reverse_string(string s) { string res = \u0026#34;\u0026#34;; for (int i = s.size() - 1; i \u0026gt;= 0; i--) { res += s[i]; } return res; } int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0); vector\u0026lt;string\u0026gt; s(n), r(n); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;s[i]; r[i] = reverse_string(s[i]); } vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; dp(n, vector\u0026lt;ll\u0026gt;(2, MAXN)); // dp[i][0] 表示 0 - i 个字符串, 第 i 个不反转 合法的最小代价 dp[0][0] = 0; dp[0][1] = a[0]; for (int i = 1; i \u0026lt; n; i++) { if (s[i] \u0026gt;= s[i - 1]) { dp[i][0] = min(dp[i][0], dp[i - 1][0]); } if (s[i] \u0026gt;= r[i - 1]) { dp[i][0] = min(dp[i][0], dp[i - 1][1]); } if (r[i] \u0026gt;= s[i - 1]) { dp[i][1] = min(dp[i][1], dp[i - 1][0] + a[i]); } if (r[i] \u0026gt;= r[i - 1]) { dp[i][1] = min(dp[i][1], dp[i - 1][1] + a[i]); } } ll ans = min(dp[n- 1][0], dp[n - 1][1]) == MAXN? -1: min(dp[n- 1][0], dp[n - 1][1]); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"1 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-706c-hard-problem/","section":"Posts","summary":"CodeForces-706C Hard problem # 题目大意 # 给定 $n$ 个字符串 $s_1, s_2, \u0026hellip;, s_n$ 和反转它们需要的代价 $a_1, a_2, \u0026hellip;, a_n$ .","title":"CodeForces-706C Hard problem"},{"content":"LeetCode-2334 元素值大于变化阈值的子数组 # Solution 1 # 按照如下的逻辑思考: 以 $\\frac{threshold}{k}$ 为下限, 随着 $k$ 增大, 满足条件的元素会越来越多. 随着元素增多, 联通区域会变大, 如果有一个联通区域长度 $\u0026gt; k$ , 就得到了一个合题意的答案. 这个增加元素/合并区域的过程提示我们使用并查集来处理. 代码如下:\nclass Solution { typedef pair\u0026lt;int, int\u0026gt; pii; vector\u0026lt;int\u0026gt; root, sz; // root 记录连通域最右侧节点, sz 记录连通域大小 // Union-Find 结构 int Find(int x) { if (root[x] != x) { root[x] = Find(root[x]); } return root[x]; } int Union (int x, int y) { // 合并两个连通区域, 并返回新区域的大小 x = Find(x); y = Find(y); if (x == y) { return sz[y]; } root[x] = y; sz[y] += sz[x]; return sz[y]; } public: int validSubarraySize(vector\u0026lt;int\u0026gt;\u0026amp; nums, int threshold) { // 随着 k 增大, 能用的数越来越多 // 我们枚举 k 从 1 - n, 在枚举的过程中对集合进行合并 int n = nums.size(); root.resize(n); sz.resize(n, 1); for (int i = 0; i \u0026lt; n; i++) { root[i] = i; } // 把数组排序, 从大的元素开始考虑, 后面的能够参与连通块时, 前面的也必然可以 vector\u0026lt;pii\u0026gt; vec; for (int i = 0; i \u0026lt; n; i++) { vec.emplace_back(nums[i], i); } sort(vec.begin(), vec.end()); vector\u0026lt;bool\u0026gt; used(n, false); for (int k = 1, pos = n - 1; k \u0026lt;= n; k++) { while (pos \u0026gt;= 0 \u0026amp;\u0026amp; vec[pos].first \u0026gt; threshold / k) { int x = vec[pos].second; int len = 1; used[x] = true; if (x \u0026gt; 0 \u0026amp;\u0026amp; used[x - 1]) { len = max(len, Union(x - 1, x)); } if (x \u0026lt; n - 1 \u0026amp;\u0026amp; used[x + 1]) { len = max(len, Union(x, x + 1)); } cout\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; if (len \u0026gt;= k) { // 联通块的大小 \u0026gt;= k, , 满足了题目定义 return k; } pos--; } } return -1; } }; Solution 2 # 同样考虑到联通区域由下限决定, 我们可以考虑以每个元素为最小值的联通区域能有多大, 再判断是不是一个合法的联通区域. 这一部分是经典的单调栈处理左右边界问题. 代码如下:\nclass Solution { public: int validSubarraySize(vector\u0026lt;int\u0026gt;\u0026amp; nums, int threshold) { int n = nums.size(); stack\u0026lt;int\u0026gt; s; // 处理左侧边界 vector\u0026lt;int\u0026gt; left(n); for (int i = 0; i \u0026lt; n; i++) { while (!s.empty() \u0026amp;\u0026amp; nums[s.top()] \u0026gt;= nums[i]) { s.pop(); } left[i] = s.empty()? -1: s.top(); s.push(i); } // 处理右侧边界 s = stack\u0026lt;int\u0026gt;(); vector\u0026lt;int\u0026gt; right(n); for (int i = n - 1; i \u0026gt;= 0; i--) { while (!s.empty() \u0026amp;\u0026amp; nums[s.top()] \u0026gt;= nums[i]) { s.pop(); } right[i] = s.empty()? n: s.top(); s.push(i); } // 寻找合法连通块 for (int i = 0; i \u0026lt; n; i++) { int k = right[i] - left[i] - 1; if (nums[i] \u0026gt; threshold / k) { return k; } } return -1; } }; ","date":"1 August 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2334-%E5%85%83%E7%B4%A0%E5%80%BC%E5%A4%A7%E4%BA%8E%E5%8F%98%E5%8C%96%E9%98%88%E5%80%BC%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","section":"Posts","summary":"LeetCode-2334 元素值大于变化阈值的子数组 # Solution 1 # 按照如下的逻辑思考: 以 $\\frac{threshold}{k}$ 为下限, 随着 $k$ 增大, 满足条件的元素会越来越多.","title":"LeetCode-2334 元素值大于变化阈值的子数组"},{"content":"CodeForces-1503A Balance the Bits # 题目大意 # 给定一个长度为 $n$ 的 $01$ 字符串 $s$ , 根据 $s$ 构造两个长度同样为 $n$ 的括号字符串 $a, b$ , 满足:\n$a, b$ 都是合法的括号匹配字符串; $a[i]$ 与 $b[i]$ 相同当且仅当 $a[i]$ 为 $1$ . 如果存在合法构造, 输出 $YES$ 并给出一个构造; 否则输出 $NO$ .\nSolution 1 # 假设存在合法构造, 设 $a, b$ 相同的部分中, $($ 有 $x$ 个, $)$ 有 $y$ 个; 不同的部分中, 考虑 $a$ , $($ 有 $z$ 个, $)$ 有 $w$ 个, 则由 $a$ 的括号匹配, 有 $x + z = y + w$ ; 再由 $b$ 的括号匹配, 有 $x + w = y + z$ , 得到 $x = y, z = w$ , 故原字符串至少满足 $0$ 和 $1$ 的个数都是偶数. 得到这一限制后, 我们来尝试构造 $a, b$ . 由于括号的数量匹配已经有保证了, 下面尽可能满足 $($ 数量不少于 $)$ 数量即可. 对于 $1$ 的前一半, 我们全部选择 $($ , 对于后一半全部选择 $)$ . 对于 $0$ , 由于 $a, b$ 的对称性, 我们交替选择 $($ 与 $)$ . 这种贪心的构造方法能够保证如果存在解, 这种方法一定能构造出合法的. 在构造过程中, 检验到 $)$ 数量大于 $($ 则说明不存在合法构造. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; string s; cin\u0026gt;\u0026gt;s; if (n % 2 != 0) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; continue; } int num_0 = 0, num_1 = 0; for (auto ch: s) { num_0 += ch == \u0026#39;0\u0026#39;; num_1 += ch == \u0026#39;1\u0026#39;; } if (num_0 % 2 != 0) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; continue; } int cnt_0 = 0, cnt_1 = 0; int cnt = 0; string a = \u0026#34;\u0026#34;, b = \u0026#34;\u0026#34;; int flag = 0; for (auto ch: s) { if (ch == \u0026#39;1\u0026#39;) { cnt++; if (cnt \u0026lt;= num_1 / 2) { a += \u0026#39;(\u0026#39;; cnt_0++; b += \u0026#39;(\u0026#39;; cnt_1++; } else { a += \u0026#39;)\u0026#39;; cnt_0--; b += \u0026#39;)\u0026#39;; cnt_1--; } } else { if (flag == 0) { a += \u0026#39;(\u0026#39;; cnt_0++; b += \u0026#39;)\u0026#39;; cnt_1--; } else { a += \u0026#39;)\u0026#39;; cnt_0--; b += \u0026#39;(\u0026#39;; cnt_1++; } flag = 1 - flag; } if (cnt_0 \u0026lt; 0 || cnt_1 \u0026lt; 0) { break; } } if (cnt_0 \u0026lt; 0 || cnt_1 \u0026lt; 0) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; continue; } cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; } return 0; } ","date":"29 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1503a-balance-the-bits/","section":"Posts","summary":"CodeForces-1503A Balance the Bits # 题目大意 # 给定一个长度为 $n$ 的 $01$ 字符串 $s$ , 根据 $s$ 构造两个长度同样为 $n$ 的括号字符串 $a, b$ , 满足:","title":"CodeForces-1503A Balance the Bits"},{"content":"CodeForces-1328D Carousel # 题目大意 # 一个环上有 $a_1, a_2, \u0026hellip;, a_n$ 这 $n$ 个数字, 要求对这些数字染色, 使得相邻的两个数字如果数字不同, 颜色也必须不同. 求满足一个条件最少染几种颜色, 并给出一个构造.\nSolution 1 # 首先要读清题意, 不要求同一种数字染同一种颜色, 只要求相邻的不同数字染不同颜色. 最简单的情况是只有一种数字, 染一种颜色就够了; 如果有两种及以上的数字, 需要考虑环的长度 $n$ 的奇偶性. 如果 $n$ 为偶数, 我们间隔染色 $ABABAB\u0026hellip;$ 能使相邻的数字颜色不同, 必然满足条件; 如果 $n$ 是奇数, 从一点按 $ABABAB\u0026hellip;$ 间隔染色, 最后染的一点会与这一点颜色相同, 只有这两点数字相同才合法. 为此, 搜索环上是否存在相邻的数字相同, 如果存在, 则用两种颜色交替染; 否则必须在最后添加一个新颜色, 共计使用 $3$ 种颜色. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long typedef pair\u0026lt;ll, ll\u0026gt; pii; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n, 0); set\u0026lt;int\u0026gt; book; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; book.insert(a[i]); } if (book.size() == 1) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; n; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;; } cout\u0026lt;\u0026lt;endl; } else { if (n % 2 == 0) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; n; i += 2) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } else { bool flag = true; for (int i = 0; i \u0026lt; n; i++) { if (a[i] == a[(i + 1) % n]) { flag = false; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; int p = 1; for (int j = 0; j \u0026lt; n; j++) { cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39; \u0026#39;; if (j != i) { p = 3 - p; } } cout\u0026lt;\u0026lt;endl; break; } } if (flag) { cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; n - 1; i += 2) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;endl; } } } } return 0; } 如果同样的数字必须染同样的颜色? # 我一开始就把题目理解成这样了. 在这种要求下, 需要以数字为顶点建图, 如果存在相邻关系就连一条边. 记这个图为 $G$ ,考虑 $G$ 的所有子图中最大的完全图 $K_m$ , 则把 $K_m$ 合法染色至少需要 $m$ 种颜色; 同时对于完全图上的每个顶点, 连接它的所有边可以拆分成一系列不超过 $K_m$ 的完全图, 可以用 $m$ 种颜色合法染色; 对于那些更边缘的点, 继续这样染色即可. 综上, $m$ 种颜色是最少的.\n","date":"29 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1328d-carousel/","section":"Posts","summary":"CodeForces-1328D Carousel # 题目大意 # 一个环上有 $a_1, a_2, \u0026hellip;, a_n$ 这 $n$ 个数字, 要求对这些数字染色, 使得相邻的两个数字如果数字不同, 颜色也必须不同.","title":"CodeForces-1328D Carousel"},{"content":"CodeForces-1554B Cobb # 题目大意 # 给定 $n, k\\ (2\\leq n\\leq 10^5, 1\\leq k\\leq min(n, 100))$ 和一个长度为 $n$ 的数组 $a\\ (0\\leq a_i \\leq n)$ , 求 $\\underset{1\\leq i \u0026lt; j\\leq n}{max}i\\times j - k\\times (a_i | a_j)$ .\nSolution 1 # 学会使用必要条件进行优化. $(a_i | a_j) \u0026lt; 2n$ , 故 $ans \u0026gt; n\\times (n - 1) - k\\times 2n$ . 而对于 $j$ , $i\\times j - k\\times (a_i | a_j) \\leq j\\times (j - 1)$ , 只有 $j\\times (j - 1) \u0026gt; ans$ 才可能优化答案. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { ll n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;ll\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } ll ans = n * (n - 1) - 2 * k * n; for (ll j = n; j \u0026gt;= 2; j--) { if (j * (j - 1) \u0026lt; ans) { break; } for (ll i = j - 1; i \u0026gt;= 1; i--) { ans = max(ans, i * j - k * (a[i] | a[j])); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"29 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1554b-cobb/","section":"Posts","summary":"CodeForces-1554B Cobb # 题目大意 # 给定 $n, k\\ (2\\leq n\\leq 10^5, 1\\leq k\\leq min(n, 100))$ 和一个长度为 $n$ 的数组 $a\\ (0\\leq a_i \\leq n)$ , 求 $\\underset{1\\leq i \u0026lt; j\\leq n}{max}i\\times j - k\\times (a_i | a_j)$ .","title":"CodeForces-1554B Cobb"},{"content":"CodeForces-1527C Sequence Pair Weight # 题目大意 # 给定一个长度为 $n$ 的序列 $a$, 求 $$ \\sum_{1\\le l\u0026lt;r\\le n}\\sum_{l\\le i\u0026lt;j\\le r}I(a_i = a_j) $$\nSolution 1 # 求 $a$ 子数组相等元素的对数和, 考虑每一对元素的贡献, 对于 $a_i = a_j$ , 在 $i\\times (n + 1 - j)$ 个子数组中出现过. 我们使用哈希表存储一个值对应的下标, 利用后缀和优化即可. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long // 前缀/后缀和优化 int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; ll ans = 0; vector\u0026lt;ll\u0026gt; a(n, 0); map\u0026lt;ll, vector\u0026lt;ll\u0026gt;\u0026gt; book; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; book[a[i]].push_back(i); } for (auto it: book) { int m = it.second.size(); vector\u0026lt;ll\u0026gt; suf(m + 1, 0); for (int i = m - 1; i \u0026gt;= 0; i--) { suf[i] = suf[i + 1] + n - it.second[i]; } for (int i = 0; i \u0026lt; m; i++) { ans += (it.second[i] + 1) * suf[i + 1]; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"27 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1527c-sequence-pair-weight/","section":"Posts","summary":"CodeForces-1527C Sequence Pair Weight # 题目大意 # 给定一个长度为 $n$ 的序列 $a$, 求 $$ \\sum_{1\\le l\u0026lt;r\\le n}\\sum_{l\\le i\u0026lt;j\\le r}I(a_i = a_j) $$","title":"CodeForces-1527C Sequence Pair Weight"},{"content":"CodeForces-1467C Three Bags # 题目大意 # 输入三个长度分别为 $n_1, n_2, n_3$ 的数组 $a, b, c$ . 每次操作选两个数组各取出一个数, 作差后再放回其中一个数组中. 经过 $n_1 + n_2 + n_3$ 次操作后只剩下一个数, 求可能的最大值.\nSolution 1 # 对于三个数 $x, y, z$ , 可以把 $y$ 作为跳板, 通过 $x - (y - z)$ 来把 $z$ 加到 $x$ 上. 下面来选择承担 $y$ 功能的数. 如果想把数加到 $a_i$ 上, 对于 $a_j, j\\not = i$ , 可以用 $b, c$ 中的数减去. 对于 $b, c$ 中的数, 这里有两种决策: 可以各选择对方的一个数作为跳板, 以及选择一整个数组作为另一个数组跳板, 这取决于是否存在一个整体都很大的数组. 对于前一种决策, 需要从三个数组的最小值里选出两个作为跳板, 最终结果为 $$\\sum_{1\\leq i\\leq n_1}a_i + \\sum_{1\\leq i\\leq n_2}b_i + \\sum_{1\\leq i\\leq n_3}c_i - 2\\times (\\underset{1\\leq i\\leq n_1}{min}a_i + \\underset{1\\leq i\\leq n_2}{min}b_i + \\underset{1\\leq i\\leq n_3}{min}c_i - \\underset{S = a,b,c}{max}\\underset{x\\in S}{min}\\ x) $$ 对于后一种决策, 最终结果为 $$\\sum_{1\\leq i\\leq n_1}a_i + \\sum_{1\\leq i\\leq n_2}b_i + \\sum_{1\\leq i\\leq n_3}c_i - 2\\times \\underset{S=a,b,c}{min}\\sum_{x\\in S}x $$ 答案是两者的最大值. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { ll n1, n2, n3; ll m1 = 1e9 + 7, m2 = 1e9 + 7, m3 = 1e9 + 7; ll s1 = 0, s2 = 0, s3 = 0; ll ans = 0; ll t; cin\u0026gt;\u0026gt;n1\u0026gt;\u0026gt;n2\u0026gt;\u0026gt;n3; while (n1--) { cin\u0026gt;\u0026gt;t; m1 = min(m1, t); s1 += t; } while (n2--) { cin\u0026gt;\u0026gt;t; m2 = min(m2, t); s2 += t; } while (n3--) { cin\u0026gt;\u0026gt;t; m3 = min(m3, t); s3 += t; } ans = s1 + s2 + s3 - 2 * (m1 + m2 + m3 - max(max(m1, m2), m3)); ans = max(ans, s1 + s2 - s3); ans = max(ans, s1 + s3 - s2); ans = max(ans, s2 + s3 - s1); cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"26 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1467c-three-bags/","section":"Posts","summary":"CodeForces-1467C Three Bags # 题目大意 # 输入三个长度分别为 $n_1, n_2, n_3$ 的数组 $a, b, c$ .","title":"CodeForces-1467C Three Bags"},{"content":"CodeForces-1305C Kuroni and Impossible Calculation # 题目大意 # 给定正整数 $m$ 和一个长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ , 求 $\\prod_{1\\leq i \u0026lt; j\\leq n}\\vert a_i - a_j\\vert\\ mod\\ m$ .\nSolution 1 # Trick 题. 本题的模数 $m$ 范围相对较小. 对于 $n \u0026gt; m$ 的情况, 由抽屉原理, $\\exist \\ 1\\leq i \u0026lt; j\\leq n, s.t.\\ a_i\\equiv a_j\\ mod\\ m$ , 故 $\\prod_{1\\leq i \u0026lt; j\\leq n}\\vert a_i - a_j\\vert \\equiv 0\\ mod\\ m$ . 对于 $n \\leq m$ 的情况, 数据范围较小, 直接暴力求解. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { ll n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;ll\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } if (n \u0026gt; m) { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } else { sort(a.begin(), a.end()); ll ans = 1; for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { ans = (ans * (a[j] - a[i])) % m; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"26 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1305c-kuroni-and-impossible-calculation/","section":"Posts","summary":"CodeForces-1305C Kuroni and Impossible Calculation # 题目大意 # 给定正整数 $m$ 和一个长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ , 求 $\\prod_{1\\leq i \u0026lt; j\\leq n}\\vert a_i - a_j\\vert\\ mod\\ m$ .","title":"CodeForces-1305C Kuroni and Impossible Calculation"},{"content":"CodeForces-1519D Maximum Sum of Products # 题目大意 # 给定长度为 $n$ 的正整数数组 $a_1, a_2,\u0026hellip;, a_n$ 和 $b_1, b_2, \u0026hellip;, b_n$ . 可以选择 $a$ 的一段区间翻转, 求 $\\sum_{i=1}^{n}a_i\\times b_i$ 的可能最大值.\nSolution 1 # 对于一段区间 $[l, r]$ , 反转它带来的变化量为 $\\sum_{i = l}^{r}a_i\\times b_{l + r - i} - \\sum_{i = l}^{r}a_i\\times b_i =-\\frac{1}{2} \\sum_{i = l}^{r}(a_i - a_{l + r - i})\\times (b_i - b_{l + r - i})$ , 注意到变化量的值只与首尾两两匹配的 $a_i, b_i$ 有关. 对于 $a_i, a_j, b_i, b_j$ , 只有 $(a_i - a_j)\\times (b_i - b_j) \u0026lt; 0$ 时, 交换 $a_i, a_j$ 才是有利的. 这一点说明最终反转的区间 $[l, r]$ 必然满足 $(a_l - a_r)\\times(b_l - b_r) \u0026lt; 0$ . 注意到目标函数的对称性, 我们把 $l + r$ 相同的区间放到一块处理. 考虑区间 $[l_1, r_1]$ 与 $[l_2, r_2]$ , 有 $l_1 \u0026lt; l_2 \u0026lt; r_2 \u0026lt; r_1$ , 两者变化量之差为 $f[l_1, r_1] - f[l_2, r_2] = \\sum_{i = l_1}^{l_2 - 1}-1\\times(a_i - a_{l_1 + r_1 - i})\\times(b_i - b_{l_1 + r_1 - i})$ , 可见这些区间中间的变化量是相同的, 区别在于外围的变化量. 我们从小到大枚举 $l$ , 计算 $f[l, r]$ 的过程中, 如果某个时刻外围累积变化量 $inc \u0026lt; 0$ , 那么之后会计算到的更小的区间一定是更优的, 直接停止当前的计算即可; 反之, 如果一个大区间被完整地计算了, 那么与其中心点相同的小区间一定不是最优的, 不需要再次计算. 优化之后的算法对于每个 $l + r$ 都只计算了最大的区间, 时间复杂度为 $O(n^2)$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0), b(n, 0); ll ap = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;b[i]; ap += a[i] * b[i]; // 初始量 } ll max_inc = 0; set\u0026lt;int\u0026gt; book; // 存储哪些 l + r 区间被计算过了 for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { if ((a[i] - a[j]) * (b[i] - b[j]) \u0026lt; 0 \u0026amp;\u0026amp; !book.count(i + j)) { ll inc = 0; book.insert(i + j); for (int k = i; k \u0026lt;= j + i - k; k++) { inc += (ll)(-1) * (a[k] - a[j + i - k]) * (b[k] - b[j + i - k]); if (inc \u0026lt; 0) { book.erase(i + j); break; } } max_inc = max(max_inc, inc); } } } cout\u0026lt;\u0026lt;ap + max_inc\u0026lt;\u0026lt;endl; return 0; } ","date":"26 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1519d-maximum-sum-of-products/","section":"Posts","summary":"CodeForces-1519D Maximum Sum of Products # 题目大意 # 给定长度为 $n$ 的正整数数组 $a_1, a_2,\u0026hellip;, a_n$ 和 $b_1, b_2, \u0026hellip;, b_n$ .","title":"CodeForces-1519D Maximum Sum of Products"},{"content":"CodeForces-1497C2 k-LCM (hard version) # 题目大意 # 给定正整数 $n, k$ , $3\\leq k\\leq n$ , 构造数组 $a_1, a_2, \u0026hellip;, a_k$ , 使得 $\\sum_{1\\leq i\\leq k}a_i = n$ 且 $lcm({a_i|1\\leq i\\leq n}) \\leq \\lfloor \\frac{n}{2}\\rfloor$ .\nSolution 1 # 因为 $lcm(1, a) = a$ , 所以先输出 $k - 3$ 个 $1$ , 再考虑把 $m = n - (k - 3)$ 拆分成 $3$ 个数.\n若 $m = 2t + 1$ , 则拆分为 $1, t, t$ ; 如果 $m = 4t + 2$ , 则拆分为 $2, 2t, 2t$ ; 如果 $m = 4t + 4$ , 则拆分为 $t + 1, t + 1, 2t + 2$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i = 1; i \u0026lt;= k - 3; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } n = n - (k - 3); if (n % 2 == 1) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 1) / 2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 1) / 2\u0026lt;\u0026lt;endl; } else if (n % 4 == 2) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 2) / 2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 2) / 2\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;(n - 4) / 4 + 1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 4) / 4 + 1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;(n - 4) / 2 + 2\u0026lt;\u0026lt;endl; } } return 0; } ","date":"26 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1497c2-k-lcm-hard-version/","section":"Posts","summary":"CodeForces-1497C2 k-LCM (hard version) # 题目大意 # 给定正整数 $n, k$ , $3\\leq k\\leq n$ , 构造数组 $a_1, a_2, \u0026hellip;, a_k$ , 使得 $\\sum_{1\\leq i\\leq k}a_i = n$ 且 $lcm({a_i|1\\leq i\\leq n}) \\leq \\lfloor \\frac{n}{2}\\rfloor$ .","title":"CodeForces-1497C2 k-LCM (hard version)"},{"content":"CodeForces-1359C Mixing Water # 题目大意 # 你有无限多杯热水和冷水, 热水温度为 $h$ , 冷水温度为 $c$ , 同时有一个容量无限大的空桶. 你的目标是让桶内的水温度到达 $t$ , $t$ 满足 $c\\leq t\\leq h$ . 为此, 你可以按下列方式向桶中倒水:\n第 $1$ 次, 倒入一杯热水; 第 $2$ 次, 倒入一杯冷水; 第 $3$ 次, 倒入一杯热水; 第 $4$ 次, 倒入一杯冷水; $\\dots$ 至少倒一杯水, 求使得桶内温度尽可能接近 $t$ , 最少需要倒几次水.\nSolution 1 # 根据题意, 必须倒 $m$ 杯热水, $m$ 或 $m - 1$ 杯冷水. 如果 $h = t$ , 倒一杯热水刚好满足要求; 如果 $h + c \\geq 2\\times t$ , 则倒了 $2 × m$ 杯水后, 再倒热水会让温度升高, 进一步偏离目标 $t$ , 因此倒 $2$ 杯水达到最优; 如果 $h + c \u0026lt; 2 × t$ , 假设已经倒了 $2 \\times m$ 杯水, 显然下一杯水会让温度升高, 升高的幅度从随 $m$ 增大而减小. 我们可以二分搜索一个最优的 $m$ , 也可以从单调性入手, 整数 $m$ 必定在浮点数解的两侧. 比较 $\\lfloor \\frac{t - h}{h + c - 2\\times t} \\rfloor$ 与 $\\lfloor \\frac{t - h}{h + c - 2\\times t} \\rfloor + 1$ 时的温度即可. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int T; cin\u0026gt;\u0026gt;T; while (T--) { int h, c, t; cin\u0026gt;\u0026gt;h\u0026gt;\u0026gt;c\u0026gt;\u0026gt;t; h = h - t; c = c - t; if (h == 0) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } else if (h + c \u0026gt;= 0) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; } else { int m = floor(-1.0 * h / (h + c)); if (((m + 1) * (h + c) - c) * (2 * m + 3) + ((m + 2) * (h + c) - c) * (2 * m + 1) \u0026gt; 0) { cout\u0026lt;\u0026lt;2 * m + 3\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;2 * m + 1\u0026lt;\u0026lt;endl; } } } return 0; } ","date":"26 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1359c-mixing-water/","section":"Posts","summary":"CodeForces-1359C Mixing Water # 题目大意 # 你有无限多杯热水和冷水, 热水温度为 $h$ , 冷水温度为 $c$ , 同时有一个容量无限大的空桶.","title":"CodeForces-1359C Mixing Water"},{"content":"CodeForces-1349A Orac and LCM # 题目大意 # 给定 $n$ 个正整数 $a_1, \u0026hellip;, a_n$ , 求 $gcd({lcm(a_i, a_j)|1\\leq i\u0026lt; j\\leq n})$ .\nSolution 1 # 考虑 $gcd({lcm(a_i, a_j)|1\\leq i\u0026lt; j\\leq n})$ 的含义. 对于每个质因子, 两两之间找出更大的指数, 取最小值, 即找出每个质因子第二小的指数. 容易想到 $gcd({a_i|1\\leq i\\leq n})$ 能够找出每个质因子最小的指数, 如何求出第二小的指数呢? 考虑 $a_i × a_j$ , 这一操作会叠加指数, 则计算 $gcd({a_ia_j|1\\leq i\u0026lt;j\\leq n})$ 可以得到每个质因子最小的指数与第二小的指数之和, $\\frac{gcd({a_ia_j|1\\leq i\u0026lt;j\\leq n})}{gcd({a_i|1\\leq i\\leq n})}$ 就是我们要找的第二小的指数. 因为 $gcd({a_ia_j|1\\leq i\u0026lt;j\\leq n}) = gcd({gcd({a_ia_j|1\\leq i\u0026lt; j})\\ |\\ 1\u0026lt; j\\leq n}) = gcd({a_j\\times gcd({a_i|1\\leq i\u0026lt; j})\\ |\\ 1\u0026lt; j\\leq n})$ . 我们可以一边读取 $a_i$ 一边更新 $res$ 与 $gcd({a_j|1\\leq j\u0026lt; i})$ , 最后除以 $gcd({a_i|1\\leq i\\leq n})$ 即可. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n, 0); ll res = 1, gcd = 1; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; res = (i == 1) ? a[i] * gcd : __gcd(res, a[i] * gcd); gcd = (i == 0)? a[0]: __gcd(gcd, a[i]); } cout \u0026lt;\u0026lt; res / gcd \u0026lt;\u0026lt; endl; return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1349a-orac-and-lcm/","section":"Posts","summary":"CodeForces-1349A Orac and LCM # 题目大意 # 给定 $n$ 个正整数 $a_1, \u0026hellip;, a_n$ , 求 $gcd({lcm(a_i, a_j)|1\\leq i\u0026lt; j\\leq n})$ .","title":"CodeForces-1349A Orac and LCM"},{"content":"CodeForces-118D Caesar\u0026rsquo;s Legions # 题目大意 # 给定 $0$ 的个数 $n_0$ , $1$ 的个数 $n_1$ , 以及 $k_0, k_1$ , 把 $0\\ 1$ 排成一列, 要求连续的 $0$ 个数不超过 $k_0$ , 连续的 $1$ 个数不超过 $k_1$ , 求满足要求的排列的个数.\nSolution 1 # 考虑一个合法的排列, 为了方便递推, 我们关心的是排列长度、末尾元素的种类以及个数. 为了保证排列是由给定的元素构成的, 还要加上一维来代表剩余 $0$ 的个数. 我们用 $dp[i][type][j][r]$ 代表长度为 $i$ , 末尾元素种类为 $type$ , 末尾连续元素个数为 $j$ , 还剩余 $r$ 个 $0$ 的排列个数. 对于 $j \\geq 2$ 的排列, 需要从 $j - 1$ 转移得到; 对于 $j = 1$ 的排列, 需要从另一种元素结尾的排列转移得到. 状态转移方程如下: $$ dp[i][type][j][r] = \\begin{cases} \\sum_{1\\leq p\\leq k_{1 - type}}dp[i - 1][1 - type][p][r + I(type = 1)], j = 1\\ dp[i - 1][type][j - 1][r + I(type = 0)], j\\geq 2 \\end{cases} $$ 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long const int MOD = 1e8; int main() { int n[2], k[2]; cin\u0026gt;\u0026gt;n[0]\u0026gt;\u0026gt;n[1]\u0026gt;\u0026gt;k[0]\u0026gt;\u0026gt;k[1]; int N = n[0] + n[1]; int dp[210][2][11][110]; dp[1][0][1][n[0] - 1] = 1; dp[1][1][1][n[0]] = 1; for (int i = 2; i \u0026lt;= N; i++) { // type == 0 for (int j = 1; j \u0026lt;= min(n[0], k[0]); j++) { for (int r = 0; r \u0026lt;= n[0]; r++) { if (j != 1) { dp[i][0][j][r] = dp[i - 1][0][j - 1][r + 1]; } else { for (int p = 1; p \u0026lt;= min(n[1], k[1]); p++) { dp[i][0][j][r] = (dp[i][0][j][r] + dp[i - 1][1][p][r + 1]) % MOD; } } } } // type == 1 for (int j = 1; j \u0026lt;= min(n[1], k[1]); j++) { for (int r = 0; r \u0026lt;= n[0]; r++) { if (j != 1) { dp[i][1][j][r] = dp[i - 1][1][j - 1][r]; } else { for (int p = 1; p \u0026lt;= min(n[0], k[0]); p++) { dp[i][1][j][r] = (dp[i][1][j][r] + dp[i - 1][0][p][r]) % MOD; } } } } } ll res = 0; for (int type = 0; type \u0026lt;= 1; type++) { for (int j = 1; j \u0026lt;= k[type]; j++) { res = (res + dp[N][type][j][0]) % MOD; } } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-118d-caesars-legions/","section":"Posts","summary":"CodeForces-118D Caesar\u0026rsquo;s Legions # 题目大意 # 给定 $0$ 的个数 $n_0$ , $1$ 的个数 $n_1$ , 以及 $k_0, k_1$ , 把 $0\\ 1$ 排成一列, 要求连续的 $0$ 个数不超过 $k_0$ , 连续的 $1$ 个数不超过 $k_1$ , 求满足要求的排列的个数.","title":"CodeForces-118D Caesar's Legions"},{"content":"CodeForces-478C Table Decorations # 题目大意 # 你正在为宴会装饰桌子, 一张桌子需要用 $3$ 个气球装饰, 且这 $3$ 个气球颜色不能是同一种颜色. 给你 $r$ 个红色气球, $g$ 个绿色气球, $b$ 个蓝色气球, 求最多能装饰的桌子数.\nSolution 1 # 我们可以用 $abb$ 和 $abc$ 两种模式来装饰桌子. 一个朴素的想法是, 三种颜色的气球数量差不多时, 尽可能均摊, 即用 $abc$ 模式来装饰桌子. 而有一种气球数量特别多时, 优先使用 $abb$ 模式显然更合理. 不妨设 $r\\leq g\\leq b$ , 如果有 $b\\geq 2\\times(r + g)$ , 由于一次装饰至少消耗掉一个 $r$ 或 $g$ , 至多装饰 $r + g$ 个桌子, 我们可以用 $rbb$ 和 $gbb$ 来达到这个上界. 如果 $b \u0026lt; 2\\times(r + g)$ , 我们仍然可以一次使用两个 $b$ , 但在某一时刻, $b$ 的数量会和 $r, g$ 很接近. 考虑最终的两种形态: $t, t, b^\\ (b^ \\leq t + 2)$ , 以及 $t, t + 1, t + 1$ . 因为 $t\\leq b^* = b - 2\\times(r - t) - 2\\times(g - t)\\leq t + 2$ , 有 $\\frac{2r + 2g - b}{3}\\leq t\\leq \\frac{2r + 2g - b + 2}{3}$ . 判断 $t$ 是否满足 $t \\leq r$ , 如果满足, 则总桌子数为 $(r - t) + (b - t) + t$ . 如果不满足, 说明无法转化到 $t, t, b^*$ , 考虑转化到 $t, t + 1, t + 1$ . 同样计算约束, 有 $t = \\frac{2r + 2g - b - 1}{3}$ , 此时总桌子数为 $(r - t) + (g - (t + 1)) + t$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { vector\u0026lt;ll\u0026gt; a(3, 0); cin\u0026gt;\u0026gt;a[0]\u0026gt;\u0026gt;a[1]\u0026gt;\u0026gt;a[2]; sort(a.begin(), a.end()); if (a[2] \u0026gt;= 2 * (a[0] + a[1])) { cout\u0026lt;\u0026lt;a[0] + a[1]\u0026lt;\u0026lt;endl; return 0; } ll res = 0; ll t = (2 * a[0] + 2 * a[1] - a[2] + 2) / 3; if (t \u0026lt;= a[0]) { res = (a[0] - t) + (a[1] - t) + t; } else { t = (2 * a[0] + 2 * a[1] - a[2] - 1) / 3; res = (a[0] - t) + (a[1] - (t + 1)) + t; } cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 对于 $b\\geq 2\\times(r + g)$ 的处理不变, 考虑 $b\u0026lt; 2\\times(r + g)$ 时, 因为 $1$ 个桌子用掉 $3$ 个气球, 数量上的约束使得答案不超过 $\\lfloor \\frac {r + g + b}{3}\\rfloor$ . 事实上这个上界能取到. 考虑 Solution 1 中的分析过程, 不管化为 $t, t, b^\\ (b^ \\leq t + 2)$ 还是 $t, t + 1, t + 1$ , 最终没有用上的气球都至多是 $2$ 个, 其余的气球全部用上了, 答案自然是 $\\lfloor \\frac {r + g + b}{3}\\rfloor$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { vector\u0026lt;ll\u0026gt; a(3, 0); cin\u0026gt;\u0026gt;a[0]\u0026gt;\u0026gt;a[1]\u0026gt;\u0026gt;a[2]; sort(a.begin(), a.end()); if (a[2] \u0026gt;= 2 * (a[0] + a[1])) { cout\u0026lt;\u0026lt;a[0] + a[1]\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;(a[0] + a[1] + a[2]) / 3\u0026lt;\u0026lt;endl; } return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-478c-table-decorations/","section":"Posts","summary":"CodeForces-478C Table Decorations # 题目大意 # 你正在为宴会装饰桌子, 一张桌子需要用 $3$ 个气球装饰, 且这 $3$ 个气球颜色不能是同一种颜色.","title":"CodeForces-478C Table Decorations"},{"content":"CodeForces-1358C Celex Update # 题目大意 # 有一个如下图所示的矩阵. 给定 $x_1,y_1, x_2,y_2$ , 求 $(x_1, y_1)$ 到 $(x_2, y_2)$ 的路径中, 不同路径和的个数.\nSolution 1 # 这道题是结论题. 对于一条向右再向下的路径, 我们可以把把右上角的拐角翻折(对于初始的情况来说, 就是 $(x_2, y_1)\\rightarrow (x_2 - 1, y_1 + 1)$) , 这会使得路径和 $+1$ . 通过这种操作我们可以获得最小路径和和最大路径和之间的每个值, 共有 $(x_2 - x_1)\\times (y_2 - y_1) + 1$ 个值. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; #define ll long long int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { ll x1, y1, x2, y2; cin\u0026gt;\u0026gt;x1\u0026gt;\u0026gt;y1\u0026gt;\u0026gt;x2\u0026gt;\u0026gt;y2; cout\u0026lt;\u0026lt;(x2 - x1) * (y2 - y1) + 1\u0026lt;\u0026lt;endl; } return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1358c-celex-update/","section":"Posts","summary":"CodeForces-1358C Celex Update # 题目大意 # 有一个如下图所示的矩阵.","title":"CodeForces-1358C Celex Update"},{"content":"CodeForces-474D Flowers # 题目大意 # 给定正整数 $k$. 称一个 $01$ 字符串是好的当且仅当其可以通过不断把连续 $k$ 个 $1$ 全部改成 $0$ 来成为全 $0$ 字符串. 求长度在 $[l, r]$ 内的好 $01$ 字符串个数.\nSolution 1 # 长度为 $n$ 的好 $01$ 字符串可以由长度为 $n - 1$ 的好 $01$ 字符串补上一个 $0$ 构成, 也可以由长度为 $n - k$ 的好 $01$ 字符串补上连续 $k$ 个 $1$ 构成. 记 $dp[i]$ 为长度为 $i$ 的好 $01$ 字符串个数, 则 $dp[i] = dp[i - 1] + dp[i - k]$ . 每次询问 $\\sum_{i = l}^{r} dp[i]$ , 可以用前缀和处理. 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; const int N = 1e5 + 10; const int MOD = 1e9 + 7; int dp[N]; int main() { int t, k; cin\u0026gt;\u0026gt;t\u0026gt;\u0026gt;k; for (int i = 0; i \u0026lt; k; i++) { dp[i] = 1; } for (int i = k; i \u0026lt; N; i++) { dp[i] = (dp[i - k] + dp[i - 1]) % MOD; } for (int i = 1; i \u0026lt; N; i++) { dp[i] = (dp[i] + dp[i - 1]) % MOD; } while (t--) { int l, r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;(dp[r] - dp[l - 1] + MOD) % MOD\u0026lt;\u0026lt;endl; } return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-474d-flowers/","section":"Posts","summary":"CodeForces-474D Flowers # 题目大意 # 给定正整数 $k$.","title":"CodeForces-474D Flowers"},{"content":"CodeForces-1203D2 Remove the Substring (hard version) # 题目大意 # 给定两个字符串 $s$ 和 $t$ , 保证 $t$ 是 $s$ 的子序列(不要求连续) . 从 $s$ 中删除一段连续子串, 使得 $t$ 仍是 $s$ 的子序列, 求删除子串的可能最大长度.\nSolution 1 # 从 $s$ 中删除了一段连续子序列, 将 $s$ 断成了两截, 分别匹配 $t$ 的一部分. 从这一角度考虑, 计算出 $t$ 的前/后缀与 $s$ 的前/后缀的匹配情况. 记 $s[0:pre[i]]$ 与 $t[0:i]$ 匹配, $s[suf[i]: n - 1]$ 与 $t[i: m - 1]$ 匹配. 我们要计算删除子串的最大长度, 就希望前缀的匹配尽可能靠前, 后缀的匹配尽可能靠后, 遍历 $t$ 的分界点 $i$ , 对于给定的 $i$ , 最大子串的长度为 $suf[i + 1] - pre[i] - 1$ . 代码如下:\n#include \u0026#34;bits/stdc++.h\u0026#34; using namespace std; int main() { string s, t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; int n = s.size(), m = t.size(); // pre[i]: t[0 - i] 字符至少需要 s[0 - pre[i]] 来匹配 // suf[i]: t[i - (m - 1)] 字符至少需要 s[suf[i] - n] 来匹配 // 枚举计算 ans 即可, t 的 0 - i 被 0 - pre[i] 覆盖, (i + 1) - m - 1被 suf[i + 1] - n 覆盖 // 考虑动态规划计算 pre 和 suf vector\u0026lt;int\u0026gt; pre(m, 0), suf(m, 0); int p = 0; for (int i = 0; i \u0026lt; n; i++) { if (s[i] == t[p]) { pre[p] = i; p++; if (p == m) { break; } } } p = m - 1; for (int i = n - 1; i \u0026gt;= 0; i--) { if (s[i] == t[p]) { suf[p] = i; p--; if (p == -1) { break; } } } int ans = max(n - 1 - pre[m - 1], suf[0]); // 越界特殊处理 for (int i = 0; i \u0026lt; m - 1; i++) { ans = max(ans, suf[i + 1] - pre[i] - 1); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"25 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1203d2-remove-the-substring-hard-version/","section":"Posts","summary":"CodeForces-1203D2 Remove the Substring (hard version) # 题目大意 # 给定两个字符串 $s$ 和 $t$ , 保证 $t$ 是 $s$ 的子序列(不要求连续) .","title":"CodeForces-1203D2 Remove the Substring (hard version)"},{"content":"memset 函数 # 函数签名 # #include \u0026lt;string.h\u0026gt; void *memset(void *buffer, int ch, size_t count) memset 函数把 ch 拷贝到 buffer 从头开始的 count 个字符里, 并返回 buffer 指针. memset 函数应用于将一段内存初始化为某个值, 函数本身应用于字符串初始化.\n初始化 int 数组 # memset 函数可以应用于初始化 int 类型数组. 在 C 语言中, char 类型占 1 个字节, int 类型占 4 个字节, 所以应用 memset 函数对 int 类型数组进行初始化时, 实际上会将每个 int 的 4 个字节看成 4 个 char 分别初始化. 应用 0x3f 初始化, 每个 int 会被初始化为 0x3f3f3f3f .\n","date":"22 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9D%82%E8%B0%88/memset-%E5%87%BD%E6%95%B0/","section":"Posts","summary":"memset 函数 # 函数签名 # #include \u0026lt;string.","title":"memset 函数"},{"content":"CodeForces-466C Number of Ways # 题目大意 # 给定一个长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ , 求数对 $(i, j)$ 的数量, 其中 $(i, j)$ 满足 $2\\leq i\\leq j\\leq n - 1$ 且 $\\sum_{k = 1}^{i - 1}a_k =\\sum_{k = i}^{j}a_k = \\sum_{k = j + 1}^{n} a_k$ .\nSolution 1 # 数组和 $sum$ 显然必须是 $3$ 的倍数. 如果满足了这一点, 我们先寻找满足 $\\sum_{k = 1}^{i}a_k = \\frac{sum}{3}$ 的 $i$ , 对于每个 $i$ , 需要统计满足 $i \u0026lt; j\\leq n - 1$ 与 $\\sum_{k = 1}^{j}a_k = \\frac{2}{3}\\times sum$ 的 $j$ 的个数. 随着 $i$ 增大, $j$ 的数量严格不增, 所以我们可以用栈来计数. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n + 1, 0); long long sum = 0; for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; a[i] += a[i - 1]; // 前缀和 } if (a[n] % 3 != 0) { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; return 0; } vector\u0026lt;int\u0026gt; idx; stack\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= n - 1; i++) { if (a[i] == a[n] / 3) { idx.push_back(i); // 存储 i } if (a[n - i] == a[n] / 3 * 2) { st.push(n - i); // 存储 j, j 倒着存 } } ll ans = 0; for (int i = 0; i \u0026lt; idx.size(); i++) { while (st.top() \u0026lt;= idx[i]) { st.pop(); if (st.empty()) { cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } } ans += st.size(); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"22 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-466c-number-of-ways/","section":"Posts","summary":"CodeForces-466C Number of Ways # 题目大意 # 给定一个长度为 $n$ 的数组 $a_1, a_2, \u0026hellip;, a_n$ , 求数对 $(i, j)$ 的数量, 其中 $(i, j)$ 满足 $2\\leq i\\leq j\\leq n - 1$ 且 $\\sum_{k = 1}^{i - 1}a_k =\\sum_{k = i}^{j}a_k = \\sum_{k = j + 1}^{n} a_k$ .","title":"CodeForces-466C Number of Ways"},{"content":"CodeForces-1336A Linova and Kingdom # 题目大意 # 给定 $n$ 个节点的有根树, 根是 $1$ 号节点. 你可以选择 $k$ 个节点将其设置为工业城市, 其余设置为旅游城市. 对于一个工业城市, 定义它的幸福值为工业城市到根的路径经过的旅游城市的数量. 求所有工业城市的幸福值之和的最大可能值.\nSolution 1 # 看到题目和样例, 第一反应当然是贪心, 优先选择深度最大的节点. 但按这种策略操作时, 如果选择的新工业城市其子节点已经是工业城市, 这个操作会影响到所有的子节点. 针对这一点进行修正, 选择 $i$ 节点变为工业城市的价值变化量为该节点提供的幸福值与子树中除自身外所有节点幸福值的减少量之差, 即 $val[i] = (d[i] - 1) - (cs[i] - 1) = d[i] - cs[i]$ , 其中 $d[i]$ 是深度, $cs[i]$ 为子树(包括自己)节点数量. 依据 $val$ 大小选择同时也能保证在选择一个节点时, 其子节点已经被选过了, 定义是满足的. 根据边建图时, 我们用 $g[i]$ 存储 $i$ 节点相连的边. 遍历子节点时, 为了区分 $i$ 的子节点与父节点, $dfs()$ 函数被设计成传入父节点参数与子节点参数. 初始使用 $dfs(0, 1)$ , 规定 $0$ 是 $1$ 的父节点. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; g[200010]; long long d[200010], cs[200010], val[200010]; void dfs(int p, int c) { d[c] = d[p] + 1; cs[c] = 1; for (int i = 0; i \u0026lt; g[c].size(); i++) { if (g[c][i] != p) { dfs(c, g[c][i]); cs[c] += cs[g[c][i]]; } } } int main() { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i = 1; i \u0026lt; n; i++) { int u, v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; g[u].push_back(v); g[v].push_back(u); } dfs(0, 1); for (int i = 1; i \u0026lt;= n; i++) { val[i] = d[i] - cs[i]; } sort(val + 1, val + n + 1, [\u0026amp;](int a, int b) { return a \u0026gt; b; }); long long ans = 0; for (int i = 1; i \u0026lt;= k; i++) { ans += val[i]; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"22 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1336a-linova-and-kingdom/","section":"Posts","summary":"CodeForces-1336A Linova and Kingdom # 题目大意 # 给定 $n$ 个节点的有根树, 根是 $1$ 号节点.","title":"CodeForces-1336A Linova and Kingdom"},{"content":"LeetCode-757 设置交集大小至少为2 # Solution 1 # 对于每个区间的被选中的元素, 我们当然希望这些元素也是被其它区间覆盖. 由此可以引出一种贪心的策略: 我们把区间排序, 再从左向右遍历, 遍历时优先选择最右侧的元素. 由于我们优先选择第一个区间最右侧的两个元素, 所以对 $Intervals$ 排序时, 应当按 $Intervals[i][1]$ 升序排序. 如果第二维相同, 如果有左边界最靠右的区间无法利用前面的元素, 这一系列区间的最优选择都与这个区间相同(必然是最优选择之一). 因此第二维升序, 相同时再按第一维降序排列. 之后贪心地选择即可. 代码如下:\nclass Solution { public: int intersectionSizeTwo(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { int n = intervals.size(); sort(intervals.begin(), intervals.end(), [\u0026amp;](vector\u0026lt;int\u0026gt; a, vector\u0026lt;int\u0026gt; b) { return (a[1] == b[1])? (a[0] \u0026gt; b[0]): (a[1] \u0026lt; b[1]); }); int ans = 2; int idx_1 = intervals[0][1] - 1, idx_2 = intervals[0][1]; for (int i = 1; i \u0026lt; n; i++) { if (intervals[i][0] \u0026gt; idx_2) { ans += 2; idx_1 = intervals[i][1] - 1; idx_2 = intervals[i][1]; } else if (intervals[i][0] \u0026gt; idx_1) { ans += 1; idx_1 = idx_2; idx_2 = intervals[i][1]; } } return ans; } }; ","date":"22 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-757-%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/","section":"Posts","summary":"LeetCode-757 设置交集大小至少为2 # Solution 1 # 对于每个区间的被选中的元素, 我们当然希望这些元素也是被其它区间覆盖.","title":"LeetCode-757 设置交集大小至少为2"},{"content":"CodeForces-431C k-Tree # 题目大意 # 有一颗无限大的 $k$ 叉树, 每个节点都有 $k$ 个子节点, 边权分别是 $1, 2, \u0026hellip;, k$ . 规定路径价值为经过的边的边权之和. 求从上至下、价值为 $n$ 且至少经过一条边权至少为 $d$ 的路径数量.\nSolution 1 # 这道题其实和树没什么关系. 我们规定 $dp[i][isValid][j]$ 为前 $i$ 条边, 是否包含了一条边权至少为 $d$ 的边, 价值为 $j$ 的路径数量. 最后的答案就是 $\\sum_{1\\leq i\\leq n}dp[i][1][n]$ . 枚举第 $i$ 条边的边权进行递推. 不难得到下面的状态转移方程: $$ \\begin{cases} dp[i][0][j] = \\sum_{1\\leq x\\leq j - 1} (I(x \u0026lt; d) \\times dp[i - 1][0][j - x])\\ dp[i][1][j] = \\sum_{1\\leq x\\leq j - 1} (dp[i - 1][1][j - x] + I(x\\geq d) × dp[i - 1][0][j - x]) \\ \\end{cases} $$ 实际编写代码时, 我们利用刷表法来进行递推. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long MOD = 1e9 + 7; int main() { int n, k, d; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;d; vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(2, vector\u0026lt;long long\u0026gt;(n + 1, 0))); for (int j = 1; j \u0026lt;= min(k, n); j++) { if (j \u0026gt;= d) { dp[1][1][j] = 1; } else { dp[1][0][j] = 1; } } for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= k; j++) { // 枚举第 i 条边价值为 j for (int t = 1; t \u0026lt;= n - j; t++) { if (j \u0026gt;= d) { dp[i][1][t + j] += dp[i - 1][0][t] + dp[i - 1][1][t]; dp[i][1][t + j] %= MOD; } else { dp[i][1][t + j] += dp[i - 1][1][t]; dp[i][0][t + j] += dp[i - 1][0][t]; dp[i][0][t + j] %= MOD; } } } } long long ans = 0; for (int i = 1; i \u0026lt;= n; i++) { ans += dp[i][1][n]; ans %= MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 状态的设计能否更精简一些? 实际上, 第一维 (边的个数) 是可以舍弃的. 直接根据后两个维度就可以递推了. 仔细观察我们的做法, 维度在状态转移时并没有起到实质性的作用. 这是因为我们最后得到的答案是遍历维度的和.\n记 $dp[i][isValid]$ 为价值为 $i$ , 是否包含了一条边权至少为 $d$ 的边的路径数量. 由如下递推关系: $$ \\begin{cases} dp[i][0] = \\sum_{1\\leq j\\leq i - 1}(I(j \u0026lt; d) \\times dp[i - j][0])\\ dp[i][1] = \\sum_{1\\leq j\\leq i - 1}(dp[i - j][1] + I(j \\geq d)\\times dp[i - j][0]) \\end{cases} $$ 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const long long MOD = 1e9 + 7; int main() { int n, k, d; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;d; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;long long\u0026gt;(2, 0)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= min(i, k); j++) { if (j \u0026lt; d) { dp[i][0] += dp[i - j][0]; dp[i][0] %= MOD; dp[i][1] += dp[i - j][1]; dp[i][1] %= MOD; } else { dp[i][1] += dp[i - j][0] + dp[i - j][1]; dp[i][1] %= MOD; } } } cout\u0026lt;\u0026lt;dp[n][1]\u0026lt;\u0026lt;endl; return 0; } 在计算 dp[i] 之前, dp[j] 已经计算完了, 不会出现混乱.\n","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-431c-k-tree/","section":"Posts","summary":"CodeForces-431C k-Tree # 题目大意 # 有一颗无限大的 $k$ 叉树, 每个节点都有 $k$ 个子节点, 边权分别是 $1, 2, \u0026hellip;, k$ .","title":"CodeForces-431C k-Tree"},{"content":"CodeForces-377A Maze # 题目大意 # 给定一个由空地 $.$ 与 障碍 $#$ 构成的地图, 其中所有的空地都四联通. 要求把 $k$ 个空地变成墙 $X$ , 使得剩下的空地仍然联通. 返回改变后的地图.\nSolution 1 # 为了不破坏空地的连通性, 我们需要尽可能先从联通块的 \u0026ldquo;外层\u0026rdquo; 进行改变. 一个可行的思路是从任意一个空地开始, 利用深度优先搜索并存储点, 再倒着改变. 不过一种更巧妙的思路是, 我们先把空地都变成墙, 再利用深度优先搜索开拓出一个连通块, 扩展连通块明显更容易实现. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int dirs[4][2] = {{1,0},{0,-1},{0,1},{-1,0}}; void dfs (int x, int y, int \u0026amp;k, vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; \u0026amp;grid) { if (x \u0026lt; 0 || x \u0026gt;= grid.size() || y \u0026lt; 0 || y \u0026gt;= grid[0].size()) { return; } if (grid[x][y] != \u0026#39;X\u0026#39;) { return; } if (k == 0) { return; } grid[x][y] = \u0026#39;.\u0026#39;; k--; for (auto dir: dirs) { dfs(x + dir[0], y + dir[1], k, grid); } return; } int main() { int n, m, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt; grid(n, vector\u0026lt;char\u0026gt;(m, \u0026#39;#\u0026#39;)); int x, y; int cnt = 0; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { cin\u0026gt;\u0026gt;grid[i][j]; if (grid[i][j] == \u0026#39;.\u0026#39;) { grid[i][j] = \u0026#39;X\u0026#39;; x = i; y = j; cnt++; } } } k = cnt - k; dfs(x, y, k, grid); for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; m; j++) { cout\u0026lt;\u0026lt;grid[i][j]; } cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-377a-maze/","section":"Posts","summary":"CodeForces-377A Maze # 题目大意 # 给定一个由空地 $.","title":"CodeForces-377A Maze"},{"content":"","date":null,"permalink":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"深度优先搜索"},{"content":"CodeForces-1196D2 RGB Substring (hard version) # 题目大意 # 给定 $n, k$ 和一个由 $R, G, B$ 组成的字符串 $s$ , 现在需要修改字符串 $s$ 使得存在一个长度 $\\geq k$ 的子串是字符串 $RGBRGBRGB\u0026hellip;$ 的子串. 求最少的修改次数.\nSolution 1 # 由于 $RGBRGBRGB\u0026hellip;$ 的循环节长度为 $3$ , 我们分别考虑 $3$ 种匹配模式. 对于每一种, 把 $s$ 与无限长的串进行匹配, 如果 $s[i]$ 不符合就记录 $val[i] = 1$ . 寻找长度为 $k$ 的最小区间和, 可以用滑动窗口, 也可以用前缀和处理. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int q; cin\u0026gt;\u0026gt;q; while (q--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; string s; cin\u0026gt;\u0026gt;s; string t[3] = {\u0026#34;RGB\u0026#34;, \u0026#34;GBR\u0026#34;, \u0026#34;BRG\u0026#34;}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; val(3, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; n; j++) { val[i][j] = (j == 0)? (s[j] != t[i][j % 3]): val[i][j - 1] + (s[j] != t[i][j % 3]); } } int ans = INT_MAX; for (int i = 0; i \u0026lt; 3; i++) { ans = min(ans, val[i][k - 1]); for (int j = k; j \u0026lt; n; j++) { ans = min(ans, val[i][j] - val[i][j - k]); } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } 这道题比较重要的地方就是匹配的思路. 从大的尺度来看问题, 把用无限长的串与原串进行匹配, 再寻找子串的匹配数. 如果一开始考虑太多子串的细节, 反而比较难做.\n","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1196d2-rgb-substring-hard-version/","section":"Posts","summary":"CodeForces-1196D2 RGB Substring (hard version) # 题目大意 # 给定 $n, k$ 和一个由 $R, G, B$ 组成的字符串 $s$ , 现在需要修改字符串 $s$ 使得存在一个长度 $\\geq k$ 的子串是字符串 $RGBRGBRGB\u0026hellip;$ 的子串.","title":"CodeForces-1196D2 RGB Substring (hard version)"},{"content":"","date":null,"permalink":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/","section":"Tags","summary":"","title":"前缀和"},{"content":"CodeForces-510C Fox And Names # 题目大意 # 给定 $n$ 个字符串, 如果存在一种新的字典序符合这些字符串的排列方式, 则输出一种字典序; 否则输出 $Impossible$ .\nSolution 1 # 如果 $s_i$ 和 $s_{i + 1}$ 不存在前缀关系, 则我们可以找到一对字母的排序关系. 我们的目标就是通过一对对字母的关系重构出所有字母的排序关系. 这是一个典型的拓扑排序问题. 先根据字母对建图, 再利用拓扑排序判断是否有环. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;string\u0026gt; s(n, \u0026#34;\u0026#34;); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; mp(26); // mp[] 记录有向边指向的点 vector\u0026lt;int\u0026gt; in(26); // in 记录入度 for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;s[i]; } // 建立有向图 for (int i = 0; i \u0026lt; n - 1; i++) { int pos = 0; int len = min(s[i].size(), s[i + 1].size()); while (s[i][pos] == s[i + 1][pos] \u0026amp;\u0026amp; pos \u0026lt; len) { pos++; // 找出第一个相异的字符位置 \u0026amp; 判断前缀关系 } if (pos \u0026lt; len) { // 因为相异跳出循环, 获得一对字母的关系 mp[s[i][pos] - \u0026#39;a\u0026#39;].push_back(s[i + 1][pos] - \u0026#39;a\u0026#39;); // 更新边 in[s[i + 1][pos] - \u0026#39;a\u0026#39;]++; // 更新入度 } else { // 因为字符串长度限制跳出循环, 说明存在前缀关系 if (s[i].size() \u0026gt; s[i + 1].size()) { // 如果前缀排在后面, 不符合字典序排序 cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;\u0026lt;\u0026lt;endl; return 0; } } } // 拓扑排序 queue\u0026lt;int\u0026gt; q; // 队列存储入度为0的点 for (int i = 0; i \u0026lt; 26; i++) { if (in[i] == 0) { q.push(i); } } string ans = \u0026#34;\u0026#34;; // 列表存储顶点 while (!q.empty()) { int temp = q.front(); q.pop(); ans += (char)(temp + \u0026#39;a\u0026#39;); for (int i = 0; i \u0026lt; mp[temp].size(); i++) { in[mp[temp][i]]--; // 删除边(这一步不需要模拟), 同时更新入度 if (in[mp[temp][i]] == 0) { q.push(mp[temp][i]); // 更新q } } } if (ans.size() == 26) { // 如果所有顶点都加入了, 说明不剩下边了, 能够拓扑排序 cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } else { // 有向图存在环, 无法重构字典序 cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;\u0026lt;\u0026lt;endl; } return 0; } ","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-510c-fox-and-names/","section":"Posts","summary":"CodeForces-510C Fox And Names # 题目大意 # 给定 $n$ 个字符串, 如果存在一种新的字典序符合这些字符串的排列方式, 则输出一种字典序; 否则输出 $Impossible$ .","title":"CodeForces-510C Fox And Names"},{"content":"","date":null,"permalink":"/tags/%E5%AD%97%E5%85%B8%E5%BA%8F/","section":"Tags","summary":"","title":"字典序"},{"content":"","date":null,"permalink":"/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"Tags","summary":"","title":"拓扑排序"},{"content":"拓扑排序 # 定义 # 有向无环图(DAG, Directed Acyclic Graph)指的是一个无回路的有向图. 拓扑排序(Topological Sorting)是一个有向无环图里所有顶点的线性序列, 且该序列满足下面两个条件:\n每个顶点出现且只出现一次 如果存在一条从顶点 $A$ 到顶点 $B$ 的路径, 那么在序列中 $A$ 出现在 $B$ 的前面. Kahn 算法 # 对于有向图 $G = (V, E)$ , 定义 $S$ 为 $G$ 中所有入度为 $0$ 的顶点构成的集合, $L$ 是一个空列表. 每次从 $S$ 中取出一个顶点 $u$ 放入 $L$ , 然后将 $u$ 的所有边 $(u, v_1), (u, v_2), \u0026hellip;, (u, v_m)$ 删除. 对于边 $(u, v)$ , 如果删除之后 $v$ 的入度变为 $0$ , 则把 $v$ 加入到 $S$ 中. 不断重复上述操作, 直到集合 $S$ 为空. 检查 $G$ 中是否剩下任何边. 如果有, 那么 $G$ 一定存在环路, 无法进行拓扑排序; 否则返回 $L$ , $L$ 中顶点的顺序就是拓扑排序的结果. Kahn 算法的时间复杂度是 $O(E+V)$ .\n","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","section":"Posts","summary":"拓扑排序 # 定义 # 有向无环图(DAG, Directed Acyclic Graph)指的是一个无回路的有向图.","title":"拓扑排序"},{"content":"CodeForces-1371D Grid-00100 # 题目大意 # 记 $R_i$ 为矩阵行和, $C_j$ 为矩阵列和. 给定正整数 $n, k, k\\leq n^2$ , 构造一个形状为 $n \\times n$ 且有 $k$ 个元素是 $1$ 的 $01$ 矩阵 $A$ , 使得 $f(A) = (\\underset{1\\leq i\\leq n}{max}\\ R_i - \\underset{1\\leq i\\leq n}{min}\\ R_i)^2 + (\\underset{1\\leq j\\leq n}{max}\\ C_j - \\underset{1\\leq j\\leq n}{min}\\ C_j)^2$ 最小.\nSolution 1 # 目标: 尽可能减小行和列的差异. 如果 $n = k$ , 容易想到按对角线排布 $1$ , 这样 $f(A) = 0$ .如果 $n = 2k$ 呢? 我们在对角线元素下方再分别布置 $1$ 同样能使 $f(A) = 0$ (这其实是模 $n$ 意义下的另一条对角线, 一共有 $n$ 条) . 沿这些对角线放置 $1$ , 若 $n = mk, 0\\leq m\\leq n$ , $f(A) = 0$ , 达到最小值. 当$n = mk + d, 0\\leq m\\leq n - 1, 1\\leq d\\leq n - 1$ 时, 行列最大值都是 $m + 1$ , 最小值都是 $m$ , 这已经是最平均(最优)的分配了, 此时 $f(A) = 2$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void print_grim(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a) { int n = a.size(); int row_min = INT_MAX, row_max = 0, col_min = INT_MAX, col_max = 0; for (int i = 0; i \u0026lt; n; i++) { int row_sum = 0; for (int j = 0; j \u0026lt; n; j++) { row_sum += a[i][j]; } row_min = min(row_min, row_sum); row_max = max(row_max, row_sum); } for (int j = 0; j \u0026lt; n; j++) { int col_sum = 0; for (int i = 0; i \u0026lt; n; i++) { col_sum += a[i][j]; } col_min = min(col_min, col_sum); col_max = max(col_max, col_sum); } cout\u0026lt;\u0026lt;(row_max - row_min) * (row_max - row_min) + (col_max - col_min) * (col_max - col_min)\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cout\u0026lt;\u0026lt;a[i][j]; } cout\u0026lt;\u0026lt;endl; } } int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; a(n, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; n \u0026amp;\u0026amp; k \u0026gt; 0; i++) { for (int j = 0; j \u0026lt; n \u0026amp;\u0026amp; k \u0026gt; 0; j++) { a[j][(j + i) % n] = 1; k--; } } print_grim(a); } return 0; } ","date":"21 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1371d-grid-00100/","section":"Posts","summary":"CodeForces-1371D Grid-00100 # 题目大意 # 记 $R_i$ 为矩阵行和, $C_j$ 为矩阵列和.","title":"CodeForces-1371D Grid-00100"},{"content":"CodeForces-1458A Row GCD # 题目大意 # 给定长度为 $n$ 的数列 $a$ 和长度为 $m$ 的数列 $b$ , 对每个 $1\\leq j\\leq m$ , 计算 $gcd(a_1 + b_j, a_2 + b_j, \u0026hellip;, a_n + b_j)$ .\nSolution 1 # 参照辗转相除法的思想, $gcd(a_1 + b_j, a_2 + b_j, \u0026hellip;, a_n + b_j) = gcd(a_1 + b_j, a_2 - a_1, \u0026hellip;, a_n - a_1)$ . 我们预处理出 $gcd(a_2 - a_1, \u0026hellip;, a_n - a_1)$ , 再和 $a_1 + b_j$ 求最大公约数. $n = 1$ 时需要特判. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;long long\u0026gt; a(n, 0), b(m, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } for (int i = 0; i \u0026lt; m; i++) { cin\u0026gt;\u0026gt;b[i]; } if (n == 1) { for (int j = 0; j \u0026lt; m; j++) { cout\u0026lt;\u0026lt;a[0] + b[j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } sort(a.begin(), a.end()); long long c = (n \u0026gt;= 3)? __gcd(a[2] - a[0], a[1] - a[0]): a[1] - a[0]; for (int i = 3; i \u0026lt; n; i++) { c = __gcd(a[i] - a[0], c); } for (int j = 0; j \u0026lt; m; j++) { cout\u0026lt;\u0026lt;__gcd(a[0] + b[j], c)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"20 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1458a-row-gcd/","section":"Posts","summary":"CodeForces-1458A Row GCD # 题目大意 # 给定长度为 $n$ 的数列 $a$ 和长度为 $m$ 的数列 $b$ , 对每个 $1\\leq j\\leq m$ , 计算 $gcd(a_1 + b_j, a_2 + b_j, \u0026hellip;, a_n + b_j)$ .","title":"CodeForces-1458A Row GCD"},{"content":"CodeForces-44H Phone Number # 题目大意 # 给定一个长度为 $n$ 的数列 $s$ , $0\\leq s[i]\\leq 9$ , 按如下方式生成长度同样为 $n$ 的数列 $t$ :\n$t[0] \\in {0, 1, \u0026hellip;, 9}$ 如果 $s[i] + t[i - 1]$ 能被 $2$ 整除, 则 $t[i] = \\frac{s[i] + t[i - 1]}{2}$ ; 否则 $t[i] = \\lfloor \\frac{s[i] + t[i - 1]}{2}\\rfloor$ 或 $\\lceil \\frac{s[i] + t[i - 1]}{2}\\rceil$ . 求生成的数列中, 与 $s$ 不相同的数列的个数.\nSolution 1 # 先考虑生成的 $t$ 的个数. 根据 $t[i - 1]$ 可以得到 $t[i]$ 的可能值, 每次生成带来两个维度的变化: 数列长度 $i$ 与末尾元素 $j$ . 我们记 $dp[i][j]$ 为生成过程中长度 $i$ 且末尾元素为 $j$ 的数列个数. 直接写出 $dp[i][j]$ 由哪些 $dp[i - 1][k]$ 转化而来有些困难, 我们遍历 $dp[i - 1][k]$ 来进行递推(俗称 \u0026ldquo;刷表法\u0026rdquo; ) , 按题意可以计算出 $dp[n][j]$ 的值, 对 $j$ 累加就得到了所有 $t$ 的个数. 如果生成的数列 $t$ 与 $s$ 相同, 则对于 $2\\leq i\\leq n$ , 有 $s[i] = \\lfloor \\frac{s[i] + s[i - 1]}{2}\\rfloor$ 或 $\\lceil \\frac{s[i] + s[i - 1]}{2}\\rceil$ , 得到 $\\vert s[i] - s[i - 1]\\vert \\leq 1$ . 根据这一点可以判断输出答案时是否需要 $-1$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; int n = s.size(); vector\u0026lt;long long\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { a[i] = s[i - 1] - \u0026#39;0\u0026#39;; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;long long\u0026gt;(10, 0)); for (int j = 0; j \u0026lt;= 9; j++) { dp[1][j] = 1; } for (int i = 2; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt;= 9; j++) { if ((j + a[i]) % 2 == 0) { dp[i][(j + a[i]) / 2] += dp[i - 1][j]; } else { dp[i][(j + a[i]) / 2] += dp[i - 1][j]; dp[i][(j + a[i]) / 2 + 1] += dp[i - 1][j]; } } } long long ans = 0; for (int j = 0; j \u0026lt;= 9; j++) { ans += dp[n][j]; } for (int i = 2; i \u0026lt;= n; i++) { if (abs(a[i] - a[i - 1]) \u0026gt; 1) { cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } } cout\u0026lt;\u0026lt;ans - 1\u0026lt;\u0026lt;endl; return 0; } ","date":"20 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-44h-phone-number/","section":"Posts","summary":"CodeForces-44H Phone Number # 题目大意 # 给定一个长度为 $n$ 的数列 $s$ , $0\\leq s[i]\\leq 9$ , 按如下方式生成长度同样为 $n$ 的数列 $t$ :","title":"CodeForces-44H Phone Number"},{"content":"CodeForces-1342C Yet Another Counting Problem # 题目大意 # 给定正整数 $a, b, l, r$ , 查询满足 $x\\in [l, r]$ 且 $(x\\ mod\\ a)\\ mod\\ b\\not = (x\\ mod\\ b)\\ mod\\ a$ 的 $x$ 的个数.\nSolution 1 # 不妨先设 $a \u0026lt; b$ . 因为既要 $mod\\ a$ 又要 $mod\\ b$ , 我们考虑一个周期 $[0, lcm(a, b) - 1]$ . 对于 $x\\in [0, lcm(a, b) - 1]$ , 需要 $x\\ mod\\ a\\not = x\\ mod\\ b$ . 显然 $x\\in [0, b - 1]$ 时是不满足条件的. 而对小数据试验后可以猜测 $\\forall\\ x\\in [b, lcm(a, b) - 1]$ , 都有 $x\\ mod\\ a\\not = x\\ mod\\ b$ . 下面我们来证明这一点. 假设 $\\exist\\ x\\in [b, lcm(a, b) - 1], s.t.\\ x\\ mod\\ a = x\\ mod\\ b$ , 设 $x = kb + t, 0\\leq t\\leq a$ , 则 $t=x\\ mod\\ b = x\\ mod\\ a = kb\\ mod\\ a + t$, 有 $kb\\ mod\\ a=0$ . 由 $a|kb, b|kb$ , 可得 $lcm(a, b)|kb$ . 因为 $kb \u0026lt; x \u0026lt; lcm(a, b)$ , 所以 $kb = 0$ . 而 $x = kb + t = t \u0026lt; a \u0026lt; b$ 与 $x\\in [b, lcm(a, b) - 1]$ 矛盾. 由上述证明可以得知, $x$ 在每个周期区间内数量均为 $lcm(a, b) - b$ . 统计 $[l, r]$ 区间时, 可以转化成 $[0, r]$ 与 $[0, l - 1]$ 区间的数目之差. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { long long a, b, q; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;q; long long d = a / __gcd(a, b) * b; long long y = max(a, b); vector\u0026lt;long long\u0026gt; ans; while (q--) { long long res = 0; long long l, r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; res = ((r / d) * (d - y) + max(r % d - y + 1, (long long)(0))) - (((l - 1) / d) * (d - y) + max((l - 1) % d - y + 1, (long long)(0))); ans.push_back(res); } for (auto res: ans) { cout\u0026lt;\u0026lt;res\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"20 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1342c-yet-another-counting-problem/","section":"Posts","summary":"CodeForces-1342C Yet Another Counting Problem # 题目大意 # 给定正整数 $a, b, l, r$ , 查询满足 $x\\in [l, r]$ 且 $(x\\ mod\\ a)\\ mod\\ b\\not = (x\\ mod\\ b)\\ mod\\ a$ 的 $x$ 的个数.","title":"CodeForces-1342C Yet Another Counting Problem"},{"content":"CodeForces-1373D Maximum Sum on Even Positions # 题目大意 # 给定一个数列 $a_0, a_1, \u0026hellip;, a_{n - 1}$ , 你可以选择一段连续区间将其反转, 求能够得到的偶数位元素和的最大值.\nSolution 1 # 这道题我们只关心下标的奇偶性而不关心其具体的次序, 从这个角度思考反转操作带来的变化. 如果区间长度为奇数, 元素下标奇偶性不变, 对结果没有影响; 如果区间长度为奇数, 我们获得的收益就是奇下标元素和减去偶下标元素和. 根据区间最左侧元素下标的奇偶性分类讨论, 可以转化成差分数组 $d$ 的最大/最小子段和问题. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; long long get_max_seqsum(vector\u0026lt;long long\u0026gt; d) { int len = d.size(); long long res = 0; long long sum = 0; for (int i = 0; i \u0026lt; len; i++) { sum += d[i]; if (sum \u0026lt;= 0) { sum = 0; } else { res = max(res, sum); } } return res; } int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;long long\u0026gt; a(n, 0); long long sum = 0; long long ans = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; if (i % 2 == 0) { sum += a[i]; } } vector\u0026lt;long long\u0026gt; d_even, d_odd; for (int i = 1; i \u0026lt; n; i++) { if (i % 2 == 0) { d_odd.push_back(-(a[i] - a[i - 1])); } else { d_even.push_back(a[i] - a[i - 1]); } } cout\u0026lt;\u0026lt;sum + max(get_max_seqsum(d_odd), get_max_seqsum(d_even))\u0026lt;\u0026lt;endl; } return 0; } ","date":"20 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1373d-maximum-sum-on-even-positions/","section":"Posts","summary":"CodeForces-1373D Maximum Sum on Even Positions # 题目大意 # 给定一个数列 $a_0, a_1, \u0026hellip;, a_{n - 1}$ , 你可以选择一段连续区间将其反转, 求能够得到的偶数位元素和的最大值.","title":"CodeForces-1373D Maximum Sum on Even Positions"},{"content":"CodeForces-1038D Slime # 题目大意 # 有 $n$ 个史莱姆排成一列, 每个史莱姆的价值为 $a_i$ . 史莱姆可以吞噬它相邻的史莱姆, 并让自身价值减去被吞噬者的价值. 经过 $n - 1$ 次吞噬后, 只剩下一个史莱姆, 求其可能的最大价值.\nSolution 1 # 执行的都是\u0026quot;减\u0026quot;的运算, 一个常规的思考模式是, 对于负数我们尽可能减去, 对于一个正数, 我们尽可能减去一个减去了它的数(负负得正). 关键是如何最大化这一操作收益呢? 由于我们至少要减掉一个数, 可以估计上界是由 $n$ 个值添加至少一个负号后得到的. 也就是说, 减去一个最小值之后, 对于剩下的数, 可以加上正数, 减去负数, 得到最大得分. 下面我们通过构造证明这一操作总是可行的. 考虑连续的一段正数, 假如其左右侧不存在负数(整个数组都是非负的), 则有最小值依次减去周围值, 再由两侧任意一个数减掉这个最小值即可. 如正数段一侧存在负数, 用负数减去正数段可以把正数段并入负数中, 如此合并直到剩下最后一个正数段, 我们留一个正数, 其余合并到负数里, 再用这个正数减去所有负数即可. 两种情况下都能实现最优操作. 具体实现时, 可以在读入数据的过程中计算绝对值和与最大值、最小值. 如果最大值为负, 则计算的结果中多了两倍的最大值绝对值. 如果最小值为正, 则计算的结果中多了两倍的最小值, 修正后可以得到答案. $n = 1$ 时需要特判, 我们无法进行任何操作, 直接返回答案. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; if (n == 1) { int ans = 0; cin\u0026gt;\u0026gt;ans; cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } long long maxnum = -(1e9 + 7); long long minnum = 1e9 + 7; long long ans = 0; long long temp = 0; while (n--) { cin\u0026gt;\u0026gt;temp; ans += max(temp, -1 * temp); maxnum = max(maxnum, temp); minnum = min(minnum, temp); } if (maxnum \u0026lt; 0) { ans += (long long)(2) * maxnum; } if (minnum \u0026gt; 0) { ans -= (long long)(2) * minnum; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"19 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1038d-slime/","section":"Posts","summary":"CodeForces-1038D Slime # 题目大意 # 有 $n$ 个史莱姆排成一列, 每个史莱姆的价值为 $a_i$ .","title":"CodeForces-1038D Slime"},{"content":"CodeForces-1051D Bicolorings # 题目大意 # 给定一个 $2\\times n$ 的棋盘, 可以对上面的格子黑白染色. 求染色后棋盘上的联通块的个数正好为 $t$ 的染色方案数.\nSolution 1 # 以 $0, 1$ 分别代表黑和白. 对于每一列, 我们有 $4$ 种染色方案, 分别为 $00$ , $01$ , $10$ , $11$ . 每次染色会带来列的数量和连通块数目的变化, 因此我们至少需要设定两个状态. 考虑具体的状态转移, 每次染色还与前一列末尾的染色情况关联, 因此我们需要设定一个三维的 $dp$ 数组, 其中 $dp[i][j][k]$ 为前 $i$ 列染色后构成 $j$ 个连通块, 且尾列状态为 $k$ 的染色方案数. 枚举可能的染色方法, 可以得到相应的状态转移方程. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 998244353; int main() { int n, t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;t; vector\u0026lt;vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt;(max(t + 1, 3), vector\u0026lt;long long\u0026gt;(4, 0))); for (int k = 0; k \u0026lt;= 3; k++) { dp[1][1][k] = 1; } for (int i = 2; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= max(t, 2); j++) { for (int k = 0; k \u0026lt;= 3; k++) { int k_0 = k \u0026amp; 1; int k_1 = (k \u0026gt;\u0026gt; 1) \u0026amp; 1; for (int l = 0; l \u0026lt;= 3; l++) { int l_0 = l \u0026amp; 1; int l_1 = (l \u0026gt;\u0026gt; 1) \u0026amp; 1; if (k_0 == k_1) { if (k_0 == l_0 || k_0 == l_1) { dp[i][j][k] += dp[i - 1][j][l]; dp[i][j][k] %= MOD; } else { dp[i][j][k] += dp[i - 1][j - 1][l]; dp[i][j][k] %= MOD; } } else { if (l_0 == l_1) { dp[i][j][k] += dp[i - 1][j - 1][l]; dp[i][j][k] %= MOD; } else if (k_0 == l_0) { dp[i][j][k] += dp[i - 1][j][l]; dp[i][j][k] %= MOD; } else { dp[i][j][k] += (j \u0026gt;= 2)? dp[i - 1][j - 2][l]: 0; dp[i][j][k] %= MOD; } } } } } } long long ans = 0; for (int k = 0; k \u0026lt;= 3; k++) { ans += dp[n][t][k]; ans %= MOD; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } 我按照末尾状况再分类讨论的, 实际上把方程写好直接 dp 就可以了, 没有必要搞这么繁琐. Solution 2 # 实际上是对 Solution 1 的优化. 很多思想值得学习. 这里贴上 0x3F 的 AC 代码:\npackage main import .\u0026#34;fmt\u0026#34; func main() { const m = 998244353 var n, k int Scan(\u0026amp;n, \u0026amp;k) if k == 1 { Print(2) return } f := make([][2]uint, k+1) f[1] = [2]uint{2, 0} f[2] = [2]uint{0, 2} for i := 2; i \u0026lt;= n; i++ { for j := min(k, i*2); j \u0026gt; 1; j-- { f[j][0] = (f[j][0] + f[j][1]*2 + f[j-1][0]) % m f[j][1] = (f[j][1] + f[j-1][0]*2 + f[j-2][1]) % m } } Print((f[k][0] + f[k][1]) % m) } func min(a, b int) int { if a \u0026gt; b { return b }; return a } 这份代码优化了什么?\n用滚动数组优化状态转移, 完成了降维 前 $j$ 列最多拥有 $2^k$ 个连通块, 可以减少不必要的枚举 以 $0$ 代表 $00, 11$ , 以 $1$ 代表 $01, 10$ , 利用对称性合并了状态. 不得不感叹, Coding 真是一门艺术.\n","date":"19 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1051d-bicolorings/","section":"Posts","summary":"CodeForces-1051D Bicolorings # 题目大意 # 给定一个 $2\\times n$ 的棋盘, 可以对上面的格子黑白染色.","title":"CodeForces-1051D Bicolorings"},{"content":"CodeForces-573B Bear and Blocks # 题目大意 # 有连续 $n$ 列柱子, 第 $i$ 列由 $h_i$ 个小方块堆成. 每次操作可以消去所有与外界接触的小方块, 求消除所有柱子所需要的次数.\nSolution 1 # 一个柱子被消掉有两种方法: 一种左/右侧的柱子已经消去, 则这根柱子会被一次全部消去; 另一种是柱子每次都消去最上方的小方块直至完全消失. 我们记 $dp[i]$ 为第 $i$ 根柱子完全消失所用的次数. 先考虑第一种情况, 以左侧为例, 有 $dp[i] = dp[i - 1] + 1$ . 再仔细思考一下第二种情况. 如果柱子低于左右两侧的柱子, 那么每次都会消去一个小方块, 否则会一次性抹平到左右侧最低的柱子, 再慢慢消去顶端的小方块. 自己慢慢消去需要 $h_i$ 次, 而通过周围柱子消去(这里以左侧柱子为例), 则是 $h_{i - 1} + 1$ 次. 事实上不必再考虑 $h_{i - 1} + 1$ 以及之后的迭代. 对于每根柱子, 我们都要比较 $dp[i - 1] + 1$ 与 $h_i$ . 在考虑第 $i$ 根柱子时, $dp[i - 1] + 1$ 实际上已经同时继承了两种消去方式, 我们只需要和 $h_i$ 比较即可. 最终状态转移方程如下: $$ dp[i] = max(dp[i - 1] + 1, dp[i + 1] + 1, h_i) $$ 具体实现时, 我们可以添加两根高度为 $0$ 的虚拟柱子, 从左向右遍历更新一次 $dp$ , 再从右向左遍历更新一次 $dp$ . 最终 $\\underset{1 \\leq i\\leq n}{max}\\ dp[i]$ 就是所求次数. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; int ans = 0; vector\u0026lt;int\u0026gt; h(n + 2, 0); vector\u0026lt;int\u0026gt; dp(n + 2, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;h[i]; } for (int i = 1; i \u0026lt;= n; i++) { dp[i] = min(dp[i - 1] + 1, h[i]); } for (int i = n; i \u0026gt;= 1; i--) { dp[i] = min(dp[i], min(dp[i + 1] + 1, h[i])); ans = max(ans, dp[i]); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"18 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-573b-bear-and-blocks/","section":"Posts","summary":"CodeForces-573B Bear and Blocks # 题目大意 # 有连续 $n$ 列柱子, 第 $i$ 列由 $h_i$ 个小方块堆成.","title":"CodeForces-573B Bear and Blocks"},{"content":"","date":null,"permalink":"/tags/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/","section":"Tags","summary":"","title":"抽屉原理"},{"content":"题目大意 # $2006$ 个不等于 $119$ 的数构成的数列, 满足任意连续子区间之和都不等于 $119$ , 求数列和的最小值.\n解答 # 考虑 $119$ 个数 $a_1, a_2, \u0026hellip;, a_{119}$, 其假设前缀和数列 $s_1, s_2, \u0026hellip;, s_{119}$ 不存在 $119$ 的倍数, 则由抽屉原理可以得到 $\\exist 1\\leq i\u0026lt; j\\leq 119, s.t.\\ s_i \\equiv s_j\\ mod\\ 119$ , 作差得到 $\\sum_{k=i + 1}^{j}a_k\\equiv 0\\ mod\\ 119$ , 综上任意 $119$ 的数组成的数列必定存在连续子区间和为 $119$ 的倍数. 由题意知不能和不能为 $119$ , 则至少为 $119 × 2 = 338$ . 因为 $2006 = 119 × 16 + 102$ , 故数列和的最小值至少为 $338 × 16 + 102 = 3910$ . 下面给出一个合法的构造: 取 $a_{119}, a_{338}, \u0026hellip;, a_{1904} = 120$ , 其余数都为 $1$ . 故最小值为 $3910$\n","date":"18 July 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%B6%A3%E9%A2%98/%E8%B6%A3%E9%A2%981_%E6%95%B0%E5%88%97%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","section":"Posts","summary":"题目大意 # $2006$ 个不等于 $119$ 的数构成的数列, 满足任意连续子区间之和都不等于 $119$ , 求数列和的最小值.","title":"趣题: 数列和的最小值"},{"content":"CodeForces-1096D Easy Problem # 题目大意 # 给定一个字符串 $s$ 和删除 $s[i]$ 的代价 $a[i]$ , 求使得 $s$ 不含有子序列(不要求连续) $hard$ 的最小代价.\nSolution 1 # 对于字符串子序列的问题, 我们考虑利用动态规划进行求解. 对于字符 $s[i]$ , 它对于我们字符串匹配的影响如下:\n如果 $s[i]\\in hard$ , 则匹配数可能增加 如果 $s[i]\\not \\in hard$ , 则匹配数不变 因此我们计算基于匹配数的最小代价. 记 $dp[i][j]$ 为 $s$ 的前 $i + 1$ 个字符中, 至多匹配 $hard$ 的前 $j$ 个字符的代价. 如果 $s[i] = hard[j]$ , 如果我们付出 $a[i]$ 的代价删除它, 则 $dp[i][j]$ 由 $dp[i - 1][j]$ 转移得到; 否则要满足不构成字符匹配条件, 只能由 $dp[i - 1][j - 1]$ 转移得到. 有如下状态转移方程: $$ dp[i][j] = max(dp[i - 1][j] + a[i], dp[i - 1][j - 1]) $$\n进一步优化可以使用滚动数组. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const string HARD = \u0026#34;hard\u0026#34;; int main() { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; vector\u0026lt;long long\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n, vector\u0026lt;long long\u0026gt;(4, 0)); dp[0][0] = (s[0] == HARD[0])? a[0]: 0;; dp[0][1] = 0; dp[0][2] = 0; dp[0][3] = 0; for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; 4; j++) { if (s[i] == HARD[j]) { dp[i][j] = (j == 0)? dp[i - 1][j] + a[i]: min(dp[i - 1][j] + a[i], dp[i - 1][j - 1]); } else { dp[i][j] = dp[i - 1][j]; } } } cout\u0026lt;\u0026lt;dp[n - 1][3]\u0026lt;\u0026lt;endl; return 0; } ","date":"18 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1096d-easy-problem/","section":"Posts","summary":"CodeForces-1096D Easy Problem # 题目大意 # 给定一个字符串 $s$ 和删除 $s[i]$ 的代价 $a[i]$ , 求使得 $s$ 不含有子序列(不要求连续) $hard$ 的最小代价.","title":"CodeForces-1096D Easy Problem"},{"content":"CodeForces-1283E New Year Parties # 题目大意 # 给定一个数组 $a$ , 对于每个元素 $a_i$ , 可以选择将其替换为 $a_i - 1, a_i, a_i + 1$ 中的一个. 返回修改后数组不同的元素个数的最小值和最大值.\nSolution 1 # 先讨论最小值. 我们需要尽可能地将不同的值合并, 合并时向左还是向右其实没有区别. 对于一个元素 $x$ , 如果 $x - 1$ 已经有了, 我们就把它和 $x - 1$ 合并, 否则把 $x$ 替换成 $x + 1$ , 这样会增大与后续 $x + 1$ 和 $x + 2$ 合并的可能性. 一种形式上更优雅的统计方式是, 记 $cnt[i]$ 为 值为 $i$ 的元素的数量, 我们按 $i$ 逐个统计 $cnt[i]$ , 遇到 $cnt[i]$ , 计数 $+ 1$ , 之后从 $i + 3$ 开始统计. 这是因为 $i + 2$ 与 $i + 1$ 是能与 $i$ 合并的. 求最小值的代码如下:\nfor (int i = 1; i \u0026lt;= n;) { if (cnt[i]) { ans++; i += 3; } else { i += 1; } } 再讨论最大值. 最大值希望尽可能分开元素, 我们同样试试贪心算法. 对如果 $cnt[i] \\geq 2$ , 我们可以不断向一侧延展直至遇到空位(这一过程可以想象成水中的涟漪) . 我们优先向左侧延展, 如果还剩下值, 先算上自身的, 如果还有剩余, 再考虑右侧( $i + 1$ ). 如果右侧是空位, 我们可以把右侧填上, 再从 $i + 2$ 继续. 如果右侧不是空位, 我们同样分配给它一个, 再从 $i + 1$ 继续. 尽管一个数只能移动一次的限制让这部分贪心算法可能会让人混淆, 但仔细考虑之后会发现, 我们的移动策略实际上已经保证了不会让一个数连续移动两次). 如果追求更清晰的写法, 可以另开一个数组做相关记录. 求最大值的代码如下:\nfor (int i = 1; i \u0026lt;= n; i++) { if (cnt[i] == 0) { continue; // 没有数就跳过 } if (cnt[i - 1] == 0) { cnt[i]--; // 左侧有空缺, 优先填左侧的 ans++; } if (cnt[i]) { ans++; // 如果填完后自己还有剩余, 加上自己 } if (cnt[i] \u0026gt;= 2) { // 如果自己的数量还很多, 考虑右侧 if (cnt[i + 1] == 0) { // 右侧有空缺, 我们把右侧填上, 再跳过右侧 ans++; i++; } else if (cnt[i + 1] \u0026gt; 0) { // 右侧没有空缺, 借给右侧一个, 便于右侧进一步传递至最右侧的空位 cnt[i]--; cnt[i + 1]++; } } } 两部分合并之后, 最终的代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MAXN=2e5+10; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; cnt(MAXN, 0); int ans = 0; for (int i = 0; i \u0026lt; n; i++) { int temp; cin\u0026gt;\u0026gt;temp; cnt[temp]++; } for (int i = 1; i \u0026lt;= n;) { if (cnt[i]) { ans++; i += 3; } else { i += 1; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;\u0026#34; \u0026#34;; ans = 0; vector\u0026lt;int\u0026gt; a(MAXN, 0); for (int i = 1; i \u0026lt;= n; i++) { if (cnt[i] == 0) { continue; } if (cnt[i - 1] == 0) { cnt[i]--; ans++; } if (cnt[i]) { ans++; } if (cnt[i] \u0026gt;= 2) { cnt[i]--; cnt[i + 1]++; if (cnt[i + 1] == 0) { ans++; i++; } } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"18 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1283e-new-year-parties/","section":"Posts","summary":"CodeForces-1283E New Year Parties # 题目大意 # 给定一个数组 $a$ , 对于每个元素 $a_i$ , 可以选择将其替换为 $a_i - 1, a_i, a_i + 1$ 中的一个.","title":"CodeForces-1283E New Year Parties"},{"content":"CodeForces-739A Alyona and mex # 题目大意 # 定义 $mex(S)$ 为 $S$ 中未出现的最小非负整数. 给定 $n$ 和一系列区间 $[l_i, r_i], 1\\leq l_i\\leq r_i\\leq n$ , 构造一个长度为 $n$ 的数列 $a$ , 使得 $\\underset{1\\leq i\\leq m}{min}\\ mex(a[l_i, r_i])$ 最大.\nSolution 1 # 很精彩的一道构造题! 单独考虑一个区间 $[l_i, r_i]$ , $mex((a[l_i, r_i]) = r_i - l_i + 1$ , 我们把区间填满 $0, 1, \u0026hellip;, r_i - l_i$ 即可. 考虑多个区间的情形是这道题的关键. 一个很容易陷入的误区是过于考虑区间交叠的细节处理. 如果试图从各个区间的重叠情况来进行贪心处理, 很难有一个令人满意的策略. 现在已经知道 $\\underset{1\\leq i\\leq m}{min}\\ mex(a[l_i, r_i])$ 的一个上界 $L = \\underset{1\\leq i\\leq m}{min}\\ r_i - l_i + 1$ , 不如关心能否给出一个构造使得上界能够取到. 要使得任意长度 $\\geq L$ 的区间都覆盖了 $0, 1, \u0026hellip;, L - 1$ , 一个合题意的构造是 $0, 1, \u0026hellip;, L - 1, 0, 1, \u0026hellip;.$ . 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; int len = INT_MAX; for (int i = 0; i \u0026lt; m; i++) { int l, r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; len = min(r - l + 1, len); } cout\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; n; i++) { cout\u0026lt;\u0026lt;i % len\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"18 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-739a-alyona-and-mex/","section":"Posts","summary":"CodeForces-739A Alyona and mex # 题目大意 # 定义 $mex(S)$ 为 $S$ 中未出现的最小非负整数.","title":"CodeForces-739A Alyona and mex"},{"content":"CodeForces-1081B Farewell Party # 题目大意 # 有 $n$ 个人参加了一个派对, 每个人带着一顶标有 $1, 2, \u0026hellip;, n$ 中一个数的帽子, $a_i$ 是 $i$ 号人口中和他自己帽子不一样的人数. 输入 $n$ 和数组 $a$ , 判断这种情况是否可能发生. 如果可能, 输出 $Possible$ 并且给出一种合法的帽子的分布; 否则输出 $Impossible$ .\nSolution 1 # 我们记 $b_i = n - a_i$ , 则 $b_i$ 代表与 $i$ 号人帽子相同的人数(包括他自己) , 这些人对应的 $b$ 值也应该与 $b_i$ 相等. 我们根据 $b_i$ 的值就可以把人划分成许多类, 每一类中也可能有不同的帽子, 只不过恰好 $b_i$ 值相同, 这要求满足 $b_i = k$ 的元素 $i$ 的个数应该是 $k$ 的整数倍. 根据这一点我们分配具体的帽子数值即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; map\u0026lt;int, int\u0026gt; book; vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; book[n - a[i]]++; //根据b_i值统计人数 } for (auto it = book.begin(); it != book.end(); it++) { if (it-\u0026gt;second % it-\u0026gt;first != 0) { // 人数应当是b_i的整数倍 cout \u0026lt;\u0026lt; \u0026#34;Impossible\u0026#34; \u0026lt;\u0026lt; endl; return 0; } } cout\u0026lt;\u0026lt;\u0026#34;Possible\u0026#34;\u0026lt;\u0026lt;endl; int num = 1; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; idx; for (auto it = book.begin(); it != book.end(); it++) { for (int i = 0; i \u0026lt; it-\u0026gt;second / it-\u0026gt;first; i++) { for (int j = 0; j \u0026lt; it-\u0026gt;first; j++) { idx[it-\u0026gt;first].push_back(num); // 记录一个b_i值对应的帽子号码 } num++; } } for (int i = 0; i \u0026lt; n; i++) { cout\u0026lt;\u0026lt;idx[n - a[i]][idx[n - a[i]].size() - 1]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; idx[n - a[i]].pop_back(); // 按顺序输出帽子号码 } cout\u0026lt;\u0026lt;endl; return 0; } ","date":"15 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1081b-farewell-party/","section":"Posts","summary":"CodeForces-1081B Farewell Party # 题目大意 # 有 $n$ 个人参加了一个派对, 每个人带着一顶标有 $1, 2, \u0026hellip;, n$ 中一个数的帽子, $a_i$ 是 $i$ 号人口中和他自己帽子不一样的人数.","title":"CodeForces-1081B Farewell Party"},{"content":"CodeForces-439C Devu and Partitioning of the Array # 题目大意 # 给定 $n, k, p$ 和一个数组 $a_1, a_2, \u0026hellip;, a_n$ , 如果能把数组分成 $k$ 个数组(不要求连续), 使得其中 $p$ 个和为偶数, $k - p$ 个和为奇数, 则输出 $YES$ 并给出具体方案, 否则输出 $NO$ .\nSolution 1 # 单独 $1$ 个奇数构成一个奇数数组, 每 $2$ 个奇数构成一个偶数数组. 首先奇数的个数要多于目标奇数数组的个数, 偶数的个数 $+$ 多余奇数对的个数要多余目标偶数数组的个数, 之后分配即可. 这道题需要考虑好各种细节情况. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n, k, p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;p; int q = k - p; vector\u0026lt;int\u0026gt; odd_idx, even_idx; vector\u0026lt;int\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; if (a[i] % 2 == 0) { even_idx.push_back(i); } else { odd_idx.push_back(i); } } int odd_num = odd_idx.size(); int even_num = even_idx.size(); if (odd_num \u0026lt; q) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } int odd_res = odd_num - q; if (odd_res % 2 != 0) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } int even_new = odd_res / 2; if (even_num + even_new \u0026lt; p) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; if (p != 0) { for (int i = 0; i \u0026lt; q; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;endl; } if (even_num \u0026gt;= p) { for (int i = 0; i \u0026lt; p - 1; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[even_idx[i]]\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;(even_num - p + 1 + odd_res)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for (int i = p - 1; i \u0026lt; even_num; i++) { cout\u0026lt;\u0026lt;a[even_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for (int i = q; i \u0026lt; odd_num; i++) { cout\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } else { int vac = p - even_num; for (int i = 0; i \u0026lt; even_num; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[even_idx[i]]\u0026lt;\u0026lt;endl; } for (int i = q; i \u0026lt;= q + 2 * (vac - 2) ; i += 2) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[odd_idx[i + 1]]\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;odd_num - (q + 2 * (vac - 2) + 2)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for (int i = q + 2 * (vac - 2) + 2; i \u0026lt; odd_num; i++) { cout\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } else { for (int i = 0; i \u0026lt; q - 1; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;odd_num - q + 1 + even_num\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for (int i = q - 1; i \u0026lt; odd_num; i++) { cout\u0026lt;\u0026lt;a[odd_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } for (int i = 0; i \u0026lt; even_num; i++) { cout\u0026lt;\u0026lt;a[even_idx[i]]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 坑真的不少\u0026hellip;\n","date":"15 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-439c-devu-and-partitioning-of-the-array/","section":"Posts","summary":"CodeForces-439C Devu and Partitioning of the Array # 题目大意 # 给定 $n, k, p$ 和一个数组 $a_1, a_2, \u0026hellip;, a_n$ , 如果能把数组分成 $k$ 个数组(不要求连续), 使得其中 $p$ 个和为偶数, $k - p$ 个和为奇数, 则输出 $YES$ 并给出具体方案, 否则输出 $NO$ .","title":"CodeForces-439C Devu and Partitioning of the Array"},{"content":"CodeForces-1042C Array Product # 题目大意 # 给你一个长度为$n$的整数序列, 你可以执行以下两种操作:\n选 $0\u0026lt;i,j\u0026lt;=n,i\\not =j$ , 将 $a_j$ 替换为 $a_i × a_j$ , 删除 $a_i$ . 选一个未被删除的 $a_i$ , 将其删除. 该操作在任意时刻均可执行，最多执行一次. 你需要操作 $n - 1$ 次, 使得剩下的数最大. 由于这个数可能非常大, 输出你的操作序列. Solution 1 # 题目不难, 但是一些特殊情况的非常需要细致的思考. 操作的核心在于删除某时刻的一个 $a_i$ , 实际上相当于选择一部分元素删除, 使得剩下的和最大. 如果有负数, 我们希望负数个数为偶数. 如果有 $0$ 我们也希望尽可能将 $0$ 全部删掉; 需要注意的是不能把所有元素都删了, 有时候剩下一个 $0$ 已经是最优解了. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n + 1, 0); vector\u0026lt;int\u0026gt; idx_0, idx_1, idx_2; //0 ,正, 负 int val = -1e9 - 7; int idx = -1; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; a[i]; if (a[i] == 0) { idx_0.push_back(i); } else if (a[i] \u0026gt; 0) { idx_1.push_back(i); } else if (a[i] \u0026lt; 0) { idx_2.push_back(i); if (a[i] \u0026gt; val) { val = a[i]; idx = i; } } } if (idx_0.size() == 0) { if (idx_2.size() % 2 == 0) { for (int i = 2; i \u0026lt;= n; i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } } else { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;idx\u0026lt;\u0026lt;endl; int pos = (idx == 1)? 2: 1; for (int i = 1; i \u0026lt;= n; i++) { if (i != idx \u0026amp;\u0026amp; i != pos) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos\u0026lt;\u0026lt;endl; } } } } else { if (idx_2.size() % 2 == 0) { vector\u0026lt;bool\u0026gt; flag(n + 1, true); for (int i = 1; i \u0026lt; idx_0.size(); i++) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;idx_0[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;idx_0[0]\u0026lt;\u0026lt;endl; flag[idx_0[i]] = false; } if (idx_1.size() == 0 \u0026amp;\u0026amp; idx_2.size() == 0) { return 0; } cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;idx_0[0]\u0026lt;\u0026lt;endl; flag[idx_0[0]] = false; int pos = 1; while (!flag[pos] \u0026amp;\u0026amp; pos \u0026lt;= n) { pos++; } for (int i = 1; i \u0026lt;= n; i++) { if (flag[i] \u0026amp;\u0026amp; i != pos) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos\u0026lt;\u0026lt;endl; } } } else { vector\u0026lt;bool\u0026gt; flag(n + 1, true); for (int i = 1; i \u0026lt; idx_0.size(); i++) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; idx_0[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; idx_0[0] \u0026lt;\u0026lt; endl; flag[idx_0[i]] = false; } cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; idx_0[0] \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; flag[idx_0[0]] = false; if (idx_2.size() == 1 \u0026amp;\u0026amp; idx_1.size() == 0) { return 0; } cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; idx \u0026lt;\u0026lt; endl; flag[idx] = false; int pos = 1; while (!flag[pos] \u0026amp;\u0026amp; pos \u0026lt;= n) { pos++; } for (int i = 1; i \u0026lt;= n; i++) { if (flag[i] \u0026amp;\u0026amp; i != pos) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; pos \u0026lt;\u0026lt; endl; } } } } return 0; } 写得有点啰嗦, 更简洁的代码可以参考洛谷题解区.\n","date":"15 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1042c-array-product/","section":"Posts","summary":"CodeForces-1042C Array Product # 题目大意 # 给你一个长度为$n$的整数序列, 你可以执行以下两种操作:","title":"CodeForces-1042C Array Product"},{"content":"CodeForces-1025C Plasticine zebra # 题目大意 # 有一个由 $b$ 和 $w$ 构成的字符串 $s$ , 每次操作可以把 $s$ 分为两部分分别翻转, 求任意次操作能得到的最长的 $b$ , $w$ 交错的子字符串的长度.\nSolution 1 # 不要被翻转这一操作给迷惑了! 把 $s$ 分成 $s_1$ 和 $s_2$ 两部分, 颠倒后重置, 相当于把 $s_2$ 接到了 $s_1$ 的前面, 再颠倒. 把原字符串看成一个环, 我们要求的就是环上最长 $b$ , $w$ 交错子字符串的长度. 实际操作时可以把 $s$ 复制一份模拟环. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { string s; cin\u0026gt;\u0026gt;s; s = s + s; int cnt = 1; int ans = 1; for (int i = 1; i \u0026lt; s.size(); i++) { if (s[i] == s[i - 1]) { ans = max(ans, cnt); cnt = 1; } else { cnt++; } } ans = max(cnt, ans); cout\u0026lt;\u0026lt;min(ans, int(s.size()) / 2)\u0026lt;\u0026lt;endl; // 不能超过原字符串的长度 return 0; } ","date":"14 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1025c-plasticine-zebra/","section":"Posts","summary":"CodeForces-1025C Plasticine zebra # 题目大意 # 有一个由 $b$ 和 $w$ 构成的字符串 $s$ , 每次操作可以把 $s$ 分为两部分分别翻转, 求任意次操作能得到的最长的 $b$ , $w$ 交错的子字符串的长度.","title":"CodeForces-1025C Plasticine zebra"},{"content":"CodeForces-1105C Ayoub and Lost Array # 题目大意 # 给定三个正整数 $n, l, r$ , 求满足如下条件的数组数目:\n数组有 $n$ 个元素 数组的每个元素都在 $[l, r]$ 内 数组元素之和为 $3$ 的倍数 Solution 1 # 一下子构造出整个数组可能有些困难, 我们不妨一个个向数组里添加数. 添加数带来的是长度与数组和 $mod\\ 3$ 两方面的变化, 可以用这两个参数作为数组的状态. 以 $dp[i][j]$ 表示长度为 $i$ , 元素和 $mod\\ 3$ 为 $j$ 的数组个数, 则有如下状态转移方程: $$ dp[i][j] = \\sum_{k = 0}^{2}dp[i - 1][k] × num[(j - k)\\ mod\\ 3] $$ 其中 $num$ 数组我们可以预先处理出来. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; int main() { long long n, l, r; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; vector\u0026lt;long long\u0026gt;num(3, 0); num[0] = r / 3 - (l - 1) / 3; num[1] = (r + 2) / 3 - (l + 1) / 3; num[2] = (r + 1) / 3 - l / 3; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;long long\u0026gt;(3, 0)); dp[0][0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 0; j \u0026lt; 3; j++) { dp[i][j] = dp[i - 1][j] * num[0] + dp[i - 1][(j + 2) % 3] * num[1] + dp[i - 1][(j + 1) % 3] * num[2]; dp[i][j] %= MOD; } } cout\u0026lt;\u0026lt;dp[n][0]\u0026lt;\u0026lt;endl; return 0; } ","date":"14 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1105c-ayoub-and-lost-array/","section":"Posts","summary":"CodeForces-1105C Ayoub and Lost Array # 题目大意 # 给定三个正整数 $n, l, r$ , 求满足如下条件的数组数目:","title":"CodeForces-1105C Ayoub and Lost Array"},{"content":"CodeForces-468A 24 Game # 题目大意 # 有一个长度为 $n$ 的序列 $1, 2, \u0026hellip;, n$ , 每次可以选择两个数 $a, b$ 删掉, 再从 $a + b$ , $a - b$, $a × b$ 中选择一个加入序列. 经过 $n - 1$ 次操作后, 序列中只会剩下一个数, 如果这个数可能为 $24$ , 输出 $YES$ 并给出构造方案, 否则输出 $NO$ .\nSolution 1 # 由于任何数 $×1$ 都为其本身, 而 $1$ 可以由相邻的数相减得到, 我们可以轻易地用 $n = k$ 的操作方案构造出 $k + 2$ 的操作方案. 因此我们检验比较小的 $n$ 即可. 容易发现 $n = 1, 2, 3$ 时不存在合法的构造方案, 而 $n = 4, 5$ 时存在, 故 $\\forall n \\geq 4$ , 合法的构造方案都是存在的. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; if (n \u0026lt; 4) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } else if (n % 2 == 0) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 5; i \u0026lt;= n; i += 2) { cout\u0026lt;\u0026lt;i + 1\u0026lt;\u0026lt;\u0026#34; - \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;3\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;6\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;6\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;4\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;24\u0026lt;\u0026lt;endl; } else if (n % 2 == 1) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 6; i \u0026lt;= n; i += 2) { cout\u0026lt;\u0026lt;i + 1\u0026lt;\u0026lt;\u0026#34; - \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;4\u0026lt;\u0026lt;\u0026#34; * \u0026#34;\u0026lt;\u0026lt;5\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;20\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;3\u0026lt;\u0026lt;\u0026#34; - \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; + \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;4\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;4\u0026lt;\u0026lt;\u0026#34; + \u0026#34;\u0026lt;\u0026lt;20\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;24\u0026lt;\u0026lt;endl; } return 0; } ","date":"14 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-468a-24-game/","section":"Posts","summary":"CodeForces-468A 24 Game # 题目大意 # 有一个长度为 $n$ 的序列 $1, 2, \u0026hellip;, n$ , 每次可以选择两个数 $a, b$ 删掉, 再从 $a + b$ , $a - b$, $a × b$ 中选择一个加入序列.","title":"CodeForces-468A 24 Game"},{"content":"CodeForces-788A Functions again # 题目大意 # 输入一个数组 $a_1, a_2,\u0026hellip;, a_n$ , 定义一个函数, 函数如下: $$ f[l,r]=\\sum^{r-1}{i=l}|a_i-a{i+1}| × (-1)^{i-l} $$ 其中 $1\\leq l,r\\leq n$ . 求 $f$ 的最大值.\nSolution 1 # 注意到 $f$ 只和 $a$ 的差分有关, 我们求出差分数组 $d$ 之后, 根据 $l$ 的奇偶性分类讨论, 可以直接将 $d$ 的一部分变为相反数, 在新的 $d\u0026rsquo;$ 数组上计算最大子段和即可.\n代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;long long\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } for (int i = 1; i \u0026lt; n; i++) { a[i] = abs(a[i] - a[i + 1]); // 转化为差分数组 } // 计算奇数下标开头的函数值 for (int i = 2; i \u0026lt;= n; i += 2) { a[i] = -1 * a[i]; // 此时偶数下标值反转 } vector\u0026lt;long long\u0026gt; dp(n, 0); // dp[j] 以j为终点的最大子段和 dp[1] = a[1]; long long ans = a[1]; for (int i = 2; i \u0026lt;= n - 1; i++) { dp[i] = max(dp[i - 1] + a[i], a[i]); // 经典最大子段和dp ans = max(ans, dp[i]); // ans其实需要和开头是奇数的比, 不过我们的处理过程已经保证了奇数开头的大于偶数开头的, 因此这里不会出错. } // 计算偶数下标开头的函数值 for (int i = 1; i \u0026lt; n; i++) { a[i] = (-1) * a[i]; // 此时奇数下标值反转, 偶数之前反转了一次, 需要转回来 } dp[1] = a[1]; for (int i = 2; i \u0026lt; n; i++) { dp[i] = max(dp[i - 1] + a[i], a[i]); ans = max(ans, dp[i]); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"14 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-788a-functions-again/","section":"Posts","summary":"CodeForces-788A Functions again # 题目大意 # 输入一个数组 $a_1, a_2,\u0026hellip;, a_n$ , 定义一个函数, 函数如下: $$ f[l,r]=\\sum^{r-1}{i=l}|a_i-a{i+1}| × (-1)^{i-l} $$ 其中 $1\\leq l,r\\leq n$ .","title":"CodeForces-788A Functions again"},{"content":"CodeForces-1084C The Fair Nut and String # 题目大意 # 给出一个只包含小写字母的字符串 $s$ , 求满足以下条件的子序列(不要求连续)的个数：\n这个子序列中的所有字符都是小写字母 $a$。 如果这个子序列的长度大于$1$, 原序列中在这个子序列中的每两个字母之间一定要包含一个小写字母 $b$ . Solution 1 # 显然答案只和原序列中的 $a$ 和 $b$ 有关, 并且和 $b$ 的位置关系密切. 对于不含 $b$ 且含有 $k$ 个 $a$ 的一段子字符串, 我们要么从中选一个, 要么不选, 共有 $k + 1$ 种选择, 用乘法原理相乘得到所有可能的选择. 但是全不选(即空字符串)不符合答案, 减去这一种情况就得到最终答案. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int MOD = 1e9 + 7; int main() { string str; cin\u0026gt;\u0026gt;str; str += \u0026#39;b\u0026#39;; long long ans = 1; long long cnt = 0; for (int i = 0; i \u0026lt; str.size(); i++) { if (str[i] == \u0026#39;a\u0026#39;) { cnt++; } else if (str[i] == \u0026#39;b\u0026#39;) { ans *= cnt + 1; ans %= MOD; cnt = 0; } } cout\u0026lt;\u0026lt;ans - 1\u0026lt;\u0026lt;endl; return 0; } ","date":"14 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1084c-the-fair-nut-and-string/","section":"Posts","summary":"CodeForces-1084C The Fair Nut and String # 题目大意 # 给出一个只包含小写字母的字符串 $s$ , 求满足以下条件的子序列(不要求连续)的个数：","title":"CodeForces-1084C The Fair Nut and String"},{"content":"","date":null,"permalink":"/tags/%E8%AE%A1%E6%95%B0/","section":"Tags","summary":"","title":"计数"},{"content":"CodeForces-1583C Omkar and Baseball # 题目大意 # 给你一个 $1, 2,\u0026hellip;, n$ 的排列, 每次操作可以选择一段区间进行排列, 要求排列后不能有元素留在自己的原位上, 求把排列变为升序的最少操作次数.\nSolution 1 # 首先考虑最简单的情况, 即原排列就是升序的, 此时不需要操作. 对于其它情况, 我们先分析一次操作能带来什么. 很明显, 一段区间如果存在一个元素在自己应在的位置上, 那么这次操作将会破坏这一点. 因此, 我们尽量考虑对全部错排的区间进行操作, 一次操作就可以让这个区间有序. 对于原排列, 如果错位的数字刚好构成一段连续的区间, 那么我们可以用 $1$ 次操作解决. 对于其它情况, 很明显至少要 $2$ 次操作. 事实上, $2$ 次操作总是足够的. 我们第一次选定所有元素进行操作, 让其完全构成一个错排(有序元素置换, 错位元素仍能错排成一个新的错排, 限于篇幅不作严格证明), 第 $2$ 次操作再归位即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; int cnt = 0; vector\u0026lt;int\u0026gt; a(n + 1, 0); vector\u0026lt;int\u0026gt; b; for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; if (a[i] == i) { b.push_back(i); } } if (b.size() == n) { cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; } else { int cnt = 0; int p = 1; while (a[p] == p) { p++; } while (a[p] != p \u0026amp;\u0026amp; p \u0026lt;= n) { cnt++; p++; } if (cnt == n - b.size()) { cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; } } } return 0; } 心灵对换机 # 看到这道题, 我很快想到， Matrix67在其著作《浴缸里的惊叹》中提到了一个《Futurama》中一个很精彩的数学问题: 心灵对换机, 这篇文章最早收录在他的博客中, 链接在此: Futurama S06E10中的数学问题. 这是一个看上去复杂得多的问题, 但同样拥有惊人的结论与精巧的解法.\n问题描述 # 有一台\u0026quot;心灵对换机\u0026quot;可以交换两个人的心灵, 但不同重复作用于同一对人(说成身体更准确一点)上. 现在给出 $n$ 个心灵错乱的人和他们之前所有的心灵交换记录, 为了让所有人的心灵重新归位, 需要引进多少个人, 才能使得合法的方案存在呢?\n解决方案 # 这是一个构造性的方案. 引进 $2$ 个人 $x, y$ , 同时考虑一个完全乱序的环, 不妨设为 $2, 3,\u0026hellip;, k, 1$ . 按照如下策略交换: $$ 2\\ 3\\ 4\\ 5\\ 6\\ …\\ k\\ 1\\ x\\ y\\ x\\ 3\\ 4\\ 5\\ 6\\ … k\\ 1\\ 2\\ y\\ x\\ y\\ 4\\ 5\\ 6\\ … k\\ 1\\ 2\\ 3\\ x\\ y\\ 3\\ 5\\ 6\\ … k\\ 1\\ 2\\ 4\\ x\\ y\\ 3\\ 4\\ 6\\ … k\\ 1\\ 2\\ 5\\ x\\ y\\ 3\\ 4\\ 5\\ … k\\ 1\\ 2\\ 6\\ …\\ …\\ …\\ x\\ y\\ 3\\ 4\\ 5\\ … k-1\\ 1\\ 2\\ k\\ x\\ y\\ 3\\ 4\\ 5\\ … k-1\\ k\\ 2\\ 1\\ x\\ 2\\ 3\\ 4\\ 5\\ … k-1\\ k\\ y\\ 1\\ 1\\ 2\\ 3\\ 4\\ 5\\ … k-1\\ k\\ y\\ x\\ $$ 最后有需要再对换 $x, y$ 即可.\n","date":"13 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1583c-omkar-and-baseball/","section":"Posts","summary":"CodeForces-1583C Omkar and Baseball # 题目大意 # 给你一个 $1, 2,\u0026hellip;, n$ 的排列, 每次操作可以选择一段区间进行排列, 要求排列后不能有元素留在自己的原位上, 求把排列变为升序的最少操作次数.","title":"CodeForces-1583C Omkar and Baseball"},{"content":"","date":null,"permalink":"/tags/%E9%94%99%E6%8E%92/","section":"Tags","summary":"","title":"错排"},{"content":"LeetCode-735 行星碰撞 # Solution 1 # 一颗向右的行星总是能摧毁比它小的向左的行星(如果目标星球在这之前被摧毁了, 也可以视作被该行星摧毁), 向左的同理. 考虑用一个数据结构模拟行星运动的过程, 我们可以从左向右遍历, 同时维护一个栈 $st$ , 用 $st$ 存储向右的行星, 如果遇到向左的行星, 一直执行 $pop()$ 操作直到栈顶元素大于行星即可. 一颗向左的行星只有在栈空时才能存活. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; asteroidCollision(vector\u0026lt;int\u0026gt;\u0026amp; asteroids) { int n = asteroids.size(); vector\u0026lt;int\u0026gt; ans; // priority_queue\u0026lt;int\u0026gt; pq; stack\u0026lt;int\u0026gt; st; for (int i = 0; i \u0026lt; n; i++) { if (asteroids[i] \u0026lt; 0) { if (st.empty()) { ans.push_back(asteroids[i]); } else { while (st.top() \u0026lt; -asteroids[i]) { st.pop(); if (st.empty()) { ans.push_back(asteroids[i]); break; // 只有把向右的全部摧毁, 才能存活 } } if (!st.empty()) { if (st.top() + asteroids[i] == 0) { st.pop(); // 同归于尽 } } } } else { st.push(asteroids[i]); } } // st中存储着存活到最后的向右行星 stack\u0026lt;int\u0026gt; res; // 用res栈把st栈中的元素颠倒一下 while (!st.empty()) { res.push(st.top()); st.pop(); } while (!res.empty()) { ans.push_back(res.top()); res.pop(); } return ans; } }; ","date":"13 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-735-%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/","section":"Posts","summary":"LeetCode-735 行星碰撞 # Solution 1 # 一颗向右的行星总是能摧毁比它小的向左的行星(如果目标星球在这之前被摧毁了, 也可以视作被该行星摧毁), 向左的同理.","title":"LeetCode-735 行星碰撞"},{"content":"","date":null,"permalink":"/tags/%E6%A0%88/","section":"Tags","summary":"","title":"栈"},{"content":"","date":null,"permalink":"/tags/%E6%A8%A1%E6%8B%9F/","section":"Tags","summary":"","title":"模拟"},{"content":"CodeForces-1015D Walking Between Houses # 题目大意 # 在一条路上, $n$ 个房子被排成一排, 从左到右编号为 $1-n$ . 一开始，你站在 $1$ 号房子前. 你需要移动到其他的房子恰好 $k$ 次. 每一次移动必须从 $x$ 房子移动到 $y$ 房子( $x\\not = y$), 走过的距离为 $\\left| x-y \\right|$. 可以多次到达同一个房子. 你的目标是一共走 $s$ 个单位长度. 如果是不可能的, 输出 $NO$ ; 否则输出 $YES$ , 并输出任意一种可行的方案.\nSolution 1 # 我们每一步最多走 $n - 1$ 步(从一个端点到另一个端点), 最少走 $1$ 步. 初步估计可行的范围是 $[k, k × (n - 1)]$ . 如果 $s$ 不在这个范围里, 直接输出 $NO$ 即可. 如果 $s$ 在这个范围里, 我们可以证明一定存在合法的方案. 构造可行方案时, 我们可以借鉴显微镜粗细准焦螺旋的思路: 先走大的, 再走小的. 首先初始化走最大步的步数 $cnt = \\lfloor \\frac{s}{n - 1}\\rfloor$ , 此时剩余步数为 $step = k - cnt$ , 剩余距离为 $res = s - cnt × (n - 1)$ , 如果方案可行必须有 $res \u0026lt; step$ , 我们不断从 $cnt$ 中减少步数分配到 $step$ 中, 直到有 $res \u0026gt;= step$ . 这时尽量走最小的步数, 直到最后一步把剩余的走掉. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long n, k, s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; if (k * (n - 1) \u0026lt; s || k * 1 \u0026gt; s) { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; return 0; } cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; long long step = k; long long cnt = s / (n - 1); step -= cnt; long long res = s - cnt * (n - 1); while (res \u0026lt; step) { cnt--; res += (n - 1); step++; } long long pos = 1; for (int i = 1; i \u0026lt;= cnt; i++) { if (i % 2 == 1) { pos = n; cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } else { pos = 1; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } for (int i = 1; i \u0026lt; step; i++) { if (i % 2 == 1) { if (pos == n) { pos = n - 1; cout\u0026lt;\u0026lt;n - 1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } else { pos = 2; cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } else { if (pos == n - 1) { pos = n; cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } else { pos = 1; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } } res--; } if (res != 0) { if (pos + res \u0026gt; n) { cout\u0026lt;\u0026lt;pos - res\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;pos + res\u0026lt;\u0026lt;endl; } } return 0; } 这里补充一个点, 我自己写代码时也没有考虑清楚, 就是 if (res = 0) 的这个判断框, 会不会导致一共只走了 $cnt + (step - 1)$ 步呢? 其实不会, 我们在处理 $cnt$ 时就已经保证了 $res\\geq step$ , 所以如果 $res = 0$ 的情况发生了, 说明 $step$ 的循环根本没有走, 也就只有 $cnt = k$ 一部分构成决策方案. 这一点是我后来才注意到的, 写代码还是要仔细.\nSolution 2 # 在处理步数时, 我们也可以先计算平均步数 $\\lfloor \\frac{s}{k}\\rfloor$ , 剩余的步数 $s\\ mod\\ k$ 均匀分配即可. 代码见洛谷用户Allanljx的博客文章CF1015D题解.\n","date":"12 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1015d-walking-between-houses/","section":"Posts","summary":"CodeForces-1015D Walking Between Houses # 题目大意 # 在一条路上, $n$ 个房子被排成一排, 从左到右编号为 $1-n$ .","title":"CodeForces-1015D Walking Between Houses"},{"content":"LeetCode-2337 移动片段得到字符串 # Solution 1 # 因为 $\u0026lsquo;L\u0026rsquo;$ 只能向左侧的空地走, $\u0026lsquo;R\u0026rsquo;$ 只能向右侧的空地走, 所以 $\u0026lsquo;L\u0026rsquo;$ 和 $\u0026lsquo;R\u0026rsquo;$ 的相对顺序不会变化. 从这一点出发, 我们分别用两个指针遍历 $start$ 与 $target$ , 不断寻找下一个非 $\u0026rsquo;_\u0026rsquo;$ 的字符, 如果出现字符不匹配, 显然不能满足题意; 如果字符匹配, 我们还要看一下相对位置对不对, 因为我们只能从 $start$ 向 $target$ 移动. 代码如下:\nclass Solution { public: bool canChange(string s, string t) { int n = s.size(); int p = 0; int q = 0; while (p \u0026lt; n \u0026amp;\u0026amp; q \u0026lt; n) { while (s[p] == \u0026#39;_\u0026#39; \u0026amp;\u0026amp; p \u0026lt; n) { p++; } while (t[q] == \u0026#39;_\u0026#39; \u0026amp;\u0026amp; q \u0026lt; n) { q++; } if (s[p] != t[q]) { return false; } else { if (s[p] == \u0026#39;L\u0026#39;) { if (p \u0026lt; q) { return false; } } else { if (p \u0026gt; q) { return false; } } } p++; q++; } return true; } }; ","date":"12 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2337-%E7%A7%BB%E5%8A%A8%E7%89%87%E6%AE%B5%E5%BE%97%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"Posts","summary":"LeetCode-2337 移动片段得到字符串 # Solution 1 # 因为 $\u0026lsquo;L\u0026rsquo;$ 只能向左侧的空地走, $\u0026lsquo;R\u0026rsquo;$ 只能向右侧的空地走, 所以 $\u0026lsquo;L\u0026rsquo;$ 和 $\u0026lsquo;R\u0026rsquo;$ 的相对顺序不会变化.","title":"LeetCode-2337 移动片段得到字符串"},{"content":"LeetCode-2338 统计理想数组的数目 # Solution 1 # 该解法来自0x3F大神的题解. 按末尾数字考虑理想数组 $a$ , 假设末尾是 $k$ 考虑数组相邻位的变化, 把 $a_0$ 视作从 $1$ 变化得到, 经过 $n$ 个位置的变化刚好获得 $k$ , 则以 $k$ 为结尾的数组个数即是把 $k$ 的因子分配到 $n$ 个位置的方法. 对于出现了 $c$ 次的因子 $p$ , 采用隔板法可以计算出次数, 按因子相乘再按末尾元素相加得到最终答案. 代码如下:\nconst int MOD = 1e9 + 7, MX = 1e4 + 1, MX_K = 13; // 至多 13 个质因数 vector\u0026lt;int\u0026gt; ks[MX]; // ks[x] 为 x 分解质因数后，每个质因数的个数列表 int c[MX + MX_K][MX_K + 1]; // 组合数 int init = []() { // 预处理 for (int i = 2; i \u0026lt; MX; ++i) { int x = i; for (int p = 2; p * p \u0026lt;= x; ++p) { if (x % p == 0) { int k = 1; for (x /= p; x % p == 0; x /= p) ++k; ks[i].push_back(k); // 计算出可能末尾元素的因子个数 } } if (x \u0026gt; 1) ks[i].push_back(1); } // 递推计算组合数 c[0][0] = 1; for (int i = 1; i \u0026lt; MX + MX_K; ++i) { c[i][0] = 1; for (int j = 1; j \u0026lt;= min(i, MX_K); ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; } return 0; }(); class Solution { public: int idealArrays(int n, int maxValue) { long ans = 0L; for (int x = 1; x \u0026lt;= maxValue; ++x) { long mul = 1L; for (int k: ks[x]) mul = mul * c[n + k - 1][k] % MOD; ans += mul; } return ans % MOD; } }; ","date":"12 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2338-%E7%BB%9F%E8%AE%A1%E7%90%86%E6%83%B3%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2338 统计理想数组的数目 # Solution 1 # 该解法来自0x3F大神的题解.","title":"LeetCode-2338 统计理想数组的数目"},{"content":"CodeForces-1692H Gambling # 题目大意 # 给定一个长度为 $n$ 的数列 $x$, 寻找 $a, l, r$ 使得 $\\sum_{i = l}^r(I(x_i=a)-I(x_i\\not = a))$ 最大.\nSolution 1 # 选定一个 $a$ , 可以把等于 $a$ 的数看成 $1$ , 不等于 $a$ 的数看成 $-1$ , 则问题转化成了经典的\u0026quot;最大子段和\u0026quot;问题, 我们采取如下策略: 不断向右扩展, 如果区间和 $\u0026lt; 0$ 就舍弃当前区间重新开始, 否则延展区间. 在扩展区间时一定是贪心的, 必须有区间的左右端点都是 $a$ . 基于这一点, 在数据读取阶段用一个哈希表记录各个值的坐标, 再对每个可能的值 $a$ 进行上述处理即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; test; int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n + 1, 0); map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; idx; for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; idx[a[i]].push_back(i); } int maxVal = 1; // 记录当前最大得分 int ansNum = a[1]; // 记录当前最大得分对应的数字 int ansLeft = 1; // 记录当前最大得分对应的区间左端点 int ansRight = 1; // 记录当前最大得分对应的区间右端点 for (auto it = idx.begin(); it != idx.end(); it++) { int sum = 1; // 初始化num的得分, 至少是1 int left = (it-\u0026gt;second)[0]; int right = left; int num = it-\u0026gt;first; for (int j = 1; j \u0026lt; (it-\u0026gt;second).size(); j++) { // 不断向右扩展 int temp = (it-\u0026gt;second)[j]; // 新的右端点 sum = sum - (temp - right - 1) + 1; // 新得分 right = temp; // 右端点变化 if (sum \u0026lt;= 0) { // 新得分\u0026lt;0, 舍弃 sum = 1; left = temp; // 当前左端点右移 // right = left; } else { // 维持左端点, 仅仅变化了右端点 if (sum \u0026gt; maxVal) { // 最好结果更新 ansLeft = left; ansRight = right; ansNum = num; maxVal = sum; } } } } cout\u0026lt;\u0026lt;ansNum\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ansLeft\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;ansRight\u0026lt;\u0026lt;endl; } return 0; } ","date":"12 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1692h-gambling/","section":"Posts","summary":"CodeForces-1692H Gambling # 题目大意 # 给定一个长度为 $n$ 的数列 $x$, 寻找 $a, l, r$ 使得 $\\sum_{i = l}^r(I(x_i=a)-I(x_i\\not = a))$ 最大.","title":"CodeForces-1692H Gambling"},{"content":"CodeForces-1692G 2^Sort # 题目大意 # 输入一个为 $n$ 的数组 $a$, 计算在这个数组中, 长度为 $k + 1 \\ (1\\leq k \u0026lt; n)$ 且符合以下条件的区间个数: $$ 2^0 × a_i \u0026lt; 2^1 × a_{i + 1} \u0026lt; 2^2 × a_{i + 2} \u0026lt; \\dotsi \u0026lt; 2^k × a_{i + k}\\ \\footnotesize{注：i 为这个区间开始的位置} $$\nSolution 1 # 对于每个 $a_i$ , 我们搜索以其为右端点的合法序列, 已经搜过的不用再搜, 对于长度为 $cnt \u0026gt; k$ 的序列, 能够产生 $cnt - k$ 个合法子序列. 为了方便操作, 我们把序列左侧加入一个 $INT_MAX$ , 这个数能够把边界情况考虑进去. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n + 1, 0); a[0] = INT_MAX; for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } int ans = 0; int left = n; int right = n; while (left \u0026gt;= 1) { int cnt = 1; int bd = a[right]; while (a[left - 1] \u0026lt; bd * 2) { left--; bd = a[left]; cnt++; } // 有点类似单调栈 ans += (cnt \u0026gt; k)? (cnt - k): 0; right = left - 1; left = left - 1; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } Solution 2 # 用 $bool$ 数组记录相邻元素是否满足大小要求, 最后在 $bool$ 数组上统计. 同样的我们增加的一个哨兵元素, 防止有元素在栈里没有弹出. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; test; int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; } int ans = 0, cnt = 0; vector\u0026lt;bool\u0026gt; b(n, false); for (int i = 1; i \u0026lt; n; i++) { if (a[i - 1] \u0026lt; 2 * a[i]) { b[i - 1] = true; } } for (int i = 0; i \u0026lt; n; i++) { if (b[i]) { cnt++; } else { ans += (cnt \u0026gt;= k)? (cnt - k + 1): 0; cnt = 0; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"12 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1692g-2sort/","section":"Posts","summary":"CodeForces-1692G 2^Sort # 题目大意 # 输入一个为 $n$ 的数组 $a$, 计算在这个数组中, 长度为 $k + 1 \\ (1\\leq k \u0026lt; n)$ 且符合以下条件的区间个数: $$ 2^0 × a_i \u0026lt; 2^1 × a_{i + 1} \u0026lt; 2^2 × a_{i + 2} \u0026lt; \\dotsi \u0026lt; 2^k × a_{i + k}\\ \\footnotesize{注：i 为这个区间开始的位置} $$","title":"CodeForces-1692G 2^Sort"},{"content":"LeetCode-2333 最小差值平方和 # Solution 1 # 我们考虑 $nums1$ 与 $nums2$ 的差的绝对值数组 $d$ , 注意到对 $nums1$ 的操作与 $nums2$ 的操作没有区别, 都等价于对 $d$ 操作. 这道题转化成有 $k = k_1 + k_2$ 次操作, 使得 $d$ 的元素平方和最小. 容易发现应该优先处理大的元素, 一个常规的想法是使用优先队列维护当前数列, 每次取出最大的元素处理后再入列, 直到操作次数用完. 这种算法没有问题, 但时间复杂度太高. 把数组想成不断上升的山脉, 我们做的事情就是不停地把山峰\u0026quot;削平\u0026quot;, 显然最终的状态必然是数列末尾连续的一些山峰高度相同. 我们考虑二分搜索这个最终高度 $t$ . 把大于 $t$ 的数变为 $t$ 之后可能会剩下一些操作次数, 我们再进行模拟. 代码如下:\nclass Solution { public: // isValid()函数判断一个给定的t是否能在给定操作数内达到 bool isValid(vector\u0026lt;long long\u0026gt; d, long long cnt, long long t) { int n = d.size(); // 寻找idx的过程也可以通过二分进一步优化 int idx = -1; for (int i = n - 1; i \u0026gt;= 0; i--) { if (d[i] \u0026gt;= t) { idx = i; } else { break; } } if (idx == -1) { return true; } for (int i = n - 1; i \u0026gt;= idx; i--) { cnt -= d[i] - t; } return cnt \u0026gt;= 0? true: false; } long long minSumSquareDiff(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k1, int k2) { int n = nums1.size(); long long cnt = k1 + k2; vector\u0026lt;long long\u0026gt; d(n, 0); for (int i = 0; i \u0026lt; n; i++) { d[i] = abs(nums1[i] - nums2[i]); } sort(d.begin(), d.end()); // 对d排序, 方便后续处理 long long left = 0; long long right = d[n - 1] + 1; // 二分搜索目标t while (left \u0026lt; right) { long long mid = left + (right - left) / 2; if (isValid(d, cnt, mid)) { right = mid; } else { left = mid + 1; } } // 找到可行的最小的t, 先把大于t的数减到t, 后续再处理剩余的操作数 long long t = left; for (int i = n - 1; i \u0026gt;= 0; i--) { if (d[i] \u0026lt;= t) { break; } int temp = d[i] - t; if (cnt - temp \u0026gt;= 0) { cnt -= temp; d[i] = t; } else { d[i] -= cnt; break; } } long long ans = 0; if (cnt \u0026gt; 0) { // 有多余操作数, 我们建立优先队列来模拟 priority_queue\u0026lt;long long\u0026gt; q; for (int i = 0; i \u0026lt; n; i++) { q.push(d[i]); } while (cnt \u0026gt; 0 \u0026amp;\u0026amp; q.top() \u0026gt; 0) { long long temp = q.top(); q.pop(); temp -= 1; cnt--; q.push(temp); } while (!q.empty()) { // 因为是在优先队列里进行的操作, 所以我们在里直接计算ans long long temp = q.top(); ans += temp * temp; q.pop(); } return ans; } // 没有多余操作数, 通过数组d计算ans for (int i = 0; i \u0026lt; n; i++) { ans += d[i] * d[i]; } return ans; } }; Solution 2 # 二分的写法还是比较繁琐, 我们考虑模拟的过程能否优化? 对于\u0026quot;削峰\u0026quot;的操作, 观察后可以发现结果相当于同时减少末尾相等的那些数. 如果把这一过程统一操作而不是在优先队列里一个个单独操作, 将会大大减少时间消耗. 我们把差分数组 $d$ 从大到小排序, 当遍历至 $a[i]$ 时, 需要把 $a[0]$ 到 $a[i]$ 都减小到 $a[i + 1]$ , 在这里判断所需的操作数 $cnt$ 与当前剩余操作数 $k$ 的大小关系. 当 $k \\geq cnt$ 时, 正常操作; 如果 $k \u0026lt; cnt$ , 则 $cnt\\ mod\\ (i + 1)$ 个能减小 $\\lfloor \\frac{cnt}{i + 1} \\rfloor + 1$, 而剩余的 $i + 1 - cnt\\ mod\\ (i + 1)$ 能减小 $\\lfloor \\frac{cnt}{i + 1} \\rfloor$ . 为了统一 $i = n - 1$ 时的操作, 我们在数组末尾添加一个 $0$ 即可. 代码如下:\nclass Solution { public: long long minSumSquareDiff(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k1, int k2) { long long ans = 0; int n =nums1.size(); int k = k1 + k2; vector\u0026lt;long long\u0026gt; d(n, 0); for (int i = 0; i \u0026lt; n; i++) { d[i] = abs(nums1[i] - nums2[i]); ans += d[i] * d[i]; } sort(d.begin(), d.end(), greater\u0026lt;int\u0026gt;()); d.push_back(0); // 增加一个哨兵0, 统一操作 for (int i = 0; i \u0026lt; n; i++) { int j = i + 1; long long cnt = j * (d[i] - d[i + 1]); ans -= d[i] * d[i]; // 先把处理过的减掉, 最后再统一加起来 if (k \u0026gt;= cnt) { // 操作数够用, 就把cnt减掉 k -= cnt; continue; } else { // 操作数不够用了, 把之前抹平的加回去 ans += k % j * (d[i] - k / j - 1) * (d[i] - k / j - 1) + (j - k % j) * (d[i] - k / j) * (d[i] - k / j); break; } } return ans; } }; ","date":"11 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2333-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E5%B9%B3%E6%96%B9%E5%92%8C/","section":"Posts","summary":"LeetCode-2333 最小差值平方和 # Solution 1 # 我们考虑 $nums1$ 与 $nums2$ 的差的绝对值数组 $d$ , 注意到对 $nums1$ 的操作与 $nums2$ 的操作没有区别, 都等价于对 $d$ 操作.","title":"LeetCode-2333 最小差值平方和"},{"content":"LeetCode-139 单词拆分 # Solution 1 # 我们考虑题中拼接的特殊性质: 如果字符串 $s_1$ 和 $s_2$ 都合法, 那么 $s_1 + s_2$ 也是合法的, 也就是拼接一个字符串可以分解为相同的子问题. 从这一点出发, 我们考虑把字符串进行分割处理., 对于一个长度为 $n$ 的字符串 $s$ , 分割为 $s[0: i - 1]$ 与 $s[i: n - 1]$ . 为了计算 $s[0: i - 1]$ 的可分性, 我们不妨用 $dp[i]$ 数组记录 $s$ 前 $i$ 位的可分性, 有初始情况 $dp[0] = ture$ (这是因为空字符串自然是可分的). 计算 $dp[i]$ 时, 利用之前所说的枚举分割点 $j$ , 有状态转移方程 $$ dp[i] = \\sum_{0\\leq j\\leq i - 1} dp[j] \\land isValid(s[j: i -1]) $$ 怎么判断 $isValid(s[j: i -1])$ 呢? 是不是还要用同样的方法判别一遍呢? 其实不需要, 判断 $s[j: i -1]$ 是否在单词集合 $wordDict$ 中即可. 因为左侧部分的 $dp[j]$ 会枚举所有可能性的点, 因此右侧只需要枚举单独一个单词的情况即可. 想到这一点, 我们可以把 $j$ 的枚举范围进一步压缩, 记 $m = \\underset{word\\in wordDict}{max}word.size()$, 则 $i - j$ 不能大于 $m$ , 否则右侧不可能与现有单词匹配. 改进后的状态转移方程如下: $$ dp[i] = \\sum_{i - m\\leq j\\leq i - 1} dp[j]\\land wordDict.count(s[j: i - 1]) $$ 代码如下:\nclass Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { set\u0026lt;string\u0026gt; book; int maxWordLen = 0; for (auto word: wordDict) { book.insert(word); maxWordLen = max(maxWordLen, (int)(word.size())); } int n = s.size(); vector\u0026lt;bool\u0026gt; dp(n + 1, false); dp[0] = true; for (int i = 1; i \u0026lt;= n; i++) { // 判断0-(i-1)是否能被拼出 for (int j = i - 1; j \u0026gt;= i - maxWordLen \u0026amp;\u0026amp; j \u0026gt;= 0; j--) { // 枚举分割点j进行状态转移 dp[i] = dp[i] | (dp[j] \u0026amp; book.count(s.substr(j, i - j))); } } return dp[n]; } }; ","date":"11 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","section":"Posts","summary":"LeetCode-139 单词拆分 # Solution 1 # 我们考虑题中拼接的特殊性质: 如果字符串 $s_1$ 和 $s_2$ 都合法, 那么 $s_1 + s_2$ 也是合法的, 也就是拼接一个字符串可以分解为相同的子问题.","title":"LeetCode-139 单词拆分"},{"content":"LeetCode-676 实现一个魔法字典 # Solution 1 # 本题可以暴力求解, 也可以通过字典树优化求解. 这一题最值得注意的是编写递归函数时的逻辑. 递归寻找一个 word 时, 在某一个节点处, 可以选择继续下去, 也可以选择变化, 而不是必须二选一; 在选择变化的过程中, 也是遇到 true 才返回, 遇到 false 不需要返回, 理顺逻辑体系才能写出 bug free 的代码. 代码如下:\nstruct Trie { Trie* children[26]; bool isEnd; Trie() { isEnd = false; fill(begin(children), end(children), nullptr); } }; class MagicDictionary { private: Trie* root; public: MagicDictionary() { root = new Trie(); } void buildDict(vector\u0026lt;string\u0026gt; dictionary) { for (auto word: dictionary) { Trie* cur = root; for (auto ch: word) { ch -= \u0026#39;a\u0026#39;; if (cur-\u0026gt;children[ch] == nullptr) { cur-\u0026gt;children[ch] = new Trie(); } cur = cur-\u0026gt;children[ch]; } cur-\u0026gt;isEnd = true; } } bool searchModifiedWord(Trie* node, string word, int len, bool isModified) { if (len == word.size()) { cout\u0026lt;\u0026lt;word\u0026lt;\u0026lt;\u0026#34; dot 1: \u0026#34;\u0026lt;\u0026lt;(isModified \u0026amp;\u0026amp; node-\u0026gt;isEnd)\u0026lt;\u0026lt;endl; return isModified \u0026amp;\u0026amp; node-\u0026gt;isEnd; } char ch = word[len]; ch -= \u0026#39;a\u0026#39;; if (node-\u0026gt;children[ch] != nullptr) { if (searchModifiedWord(node-\u0026gt;children[ch], word, len + 1, isModified)){ return true; } } if (!isModified) { for (int i = 0; i \u0026lt; 26; i++) { if (node-\u0026gt;children[i] != nullptr \u0026amp;\u0026amp; i != ch) { if (searchModifiedWord(node-\u0026gt;children[i], word, len + 1, true)) { return true; } } } } return false; } bool search(string searchWord) { return searchModifiedWord(root, searchWord, 0, false); } }; ","date":"11 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-676-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","section":"Posts","summary":"LeetCode-676 实现一个魔法字典 # Solution 1 # 本题可以暴力求解, 也可以通过字典树优化求解.","title":"LeetCode-676 实现一个魔法字典"},{"content":"","date":null,"permalink":"/tags/%E5%AD%97%E5%85%B8%E6%A0%91/","section":"Tags","summary":"","title":"字典树"},{"content":"Trie # Trie的示意图, 来自OI Wiki(https://oi-wiki.org/string/trie/)\rTrie 的作用 # Trie (字典树/前缀树)是一种树形数据结构, 用于高效地存储和检索字符串数据集中的键. 这一数据结构有相当多的应用情景, 例如自动补完和拼写检查.\nTrie 的实现 # 以LeetCode-208 实现 Trie (前缀树)为例.\n要求 # 请你实现 Trie 类：\nTrie() 初始化前缀树对象 void insert(String word) 向前缀树中插入字符串 word boolean search(String word) 如果字符串 word 在前缀树中, 返回 true（即在检索之前已经插入）; 否则, 返回 false boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix , 返回 true ; 否则, 返回 false 代码实现 # class Trie { private: // 递归定义, 每个Trie节点拥有一个长为26的子节点数组, 对应26个后继英文字母 vector\u0026lt;Trie*\u0026gt; children; bool isEnd; // isEnd用来记录以当前节点结尾的前缀是否是一个单词, 用来区分Trie中的前缀与单词 // searchPrefix方法, 输入一个前缀, 如果Trie中有该前缀, 则返回最后一个节点, 否则返回nullptr Trie* searchPrefix(string prefix) { Trie* node = this; for (char ch: prefix) { ch -= \u0026#39;a\u0026#39;; if (node-\u0026gt;children[ch] == nullptr) { return nullptr; } node = node-\u0026gt;children[ch]; } return node; } public: // 初始化Trie Trie() : children(26), isEnd(false) {} // 插入word, 沿着前缀树寻找, 没有就新建 void insert(string word) { Trie* node = this; for (char ch: word) { ch -= \u0026#39;a\u0026#39;; if (node-\u0026gt;children[ch] == nullptr) { node-\u0026gt;children[ch] = new Trie(); } node = node-\u0026gt;children[ch]; } node-\u0026gt;isEnd = true; } // 搜索Trie中是否有单词, 调用searchPrefix()方法, 如果存在前缀, 判断是否是一个单词 bool search(string word) { Trie* node = this-\u0026gt;searchPrefix(word); if (node == nullptr) { return false; } if (node-\u0026gt;isEnd == true) { return true; } return false; } // 判断Trie中是否有前缀, 调用searchPrefix()方法即可 bool startsWith(string prefix) { return this-\u0026gt;searchPrefix(prefix) != nullptr; } }; ","date":"11 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E5%85%B8%E6%A0%91/","section":"Posts","summary":"Trie # Trie的示意图, 来自OI Wiki(https://oi-wiki.","title":"Trie 字典树"},{"content":"","date":null,"permalink":"/tags/yolo/","section":"Tags","summary":"","title":"YOLO"},{"content":"YOLO: You Only Look Once # 本文是教学视频【精读AI论文】YOLO V1目标检测，看我就够了的学习笔记.\nYOLO是什么 # Yolo是用来解决计算机视觉领域中目标检测问题的机器学习模型.\n计算机视觉需要解决什么问题 # 分类, 分类 + 定位, 目标检测, 分割\r分类, 语义分割, 目标检测, 实例分割\r更清晰的例子, 可以看出实例分割是最难的\r目标检测: 单阶段模型与双阶段模型 # 单阶段模型: 端到端, 直接提取物体边界 双阶段模型: 先给出一些候选框, 再对候选框进行识别与微调 YOLO属于单阶段模型\rYOLO V1: 预测阶段(前向推断) # YOLO V1网络结构\rYOLO V1预测阶段\r把图片转化成正方形, 切割成 $s × s$ 个Grid Cell, 对于每个Grid Cell, 会生成 $B$ 个中心点在其内部的矩形框, 预测如果拥有物体, 物体是某一类的概率 , 概率越大框越粗. 根据物体类别划分Grid Cell, 根据置信度决定矩形框粗细, 两者结合最后处理得到预测结果. YOLO V1: 预测阶段后处理 # 我们的目标 # 从诸多矩形框中得到最终结果\r把模型中7×7×30的向量转化为最终预测结果\r预测得到的初步结果是什么 # 7×7×30向量结构\r$7 × 7 × 30$ 向量的含义:\n$7 × 7$ 个Grid Cell $30 = 2 × 5 + 20$ : $2$ 个预测矩形框, 每个矩形框拥有 $5$ 个参数: 中心点的归一化横纵坐标 $x, y$, 矩形框的归一化宽和高 $w, h$ , 预测框置信度 $P(obj\\ in\\ box))$; $20$ 个类别, 分别为预测各个类别的条件概率 $P(obj\\ is\\ class_i|obj\\ in\\ box)$ 把$P(obj\\ is\\ class_i|obj\\ in\\ box)$ 与 $P(obj\\ in\\ box)) $ 相乘, 得到 $P(obj\\ is\\ class_i)$ , 一共获得 $7 × 7 × 2$ 个 $20$ 维向量.\n对于上一步获得的 $7 × 7 × 2$ 个 $20$ 维向量, 我们对于其第一维设定一个抹零的阈值, 抹零后进行排序, 再进行NMS处理.\n向量操作\rNMS # NMS(Non Maximum Suppression): 非极大值抑制, 顾名思义就是抑制不是极大值的元素, 搜索局部的极大值.\n去重 # 对于某个类别, 我们把矩形框与概率最大的矩形框进行比较, 如果两者IOU(交并比)大于一定阈值, 就认为这两个矩形框识别的是一个物体, 把概率低的矩形框舍弃, 赋值为 $0$ . 与最大的比较之后再与次大的比较, 依此类推.\n去掉重复的矩形框\r注意NMS只在预测阶段使用.\nYOLO V1: 训练阶段 # YOLO V1预测与实际标注\r如上图所示, 对于Ground Truth中心点落在的Grid Cell, 我们要让与其交并比大的那个预测矩形框尽可能拟合它. 实际上, YOLO V1的损失函数如下图所示:\nYOLO V1损失函数\r损失函数的设计思想是把预测当作回归问题解决, 主要有 $5$ 项组成:\n负责检测物体的矩形框的中心点定位误差 负责检测物体的矩形框的宽高定位误差 负责检测物体的矩形框的置信度误差 不负责预测物体的置信度误差 负责检测物体的分类误差 ","date":"11 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/yolov1/","section":"Posts","summary":"YOLO: You Only Look Once # 本文是教学视频【精读AI论文】YOLO V1目标检测，看我就够了的学习笔记.","title":"YOLO V1学习笔记"},{"content":"CodeForces-1396A Multiples of Length # 题目大意 # 给你一个长度为 $n$ 的序列, 进行恰好三次操作，使得操作结束后序列所有数为 $0$ . 每次操作你将选择一个区间, 假设区间长度为$len$, 你可以这个区间的每个数加上 $len$ 的任意倍. 可以证明这个问题一定有解, 请你给出任意一个合法方案.\nSolution 1 # 恰好进行三次操作, 我们考虑极端一点的情况. 对所有元素进行操作, 可以同时加减 $n$ 的倍数, 如果序列已经满足都是 $n$ 的倍数, 我们这次操作可以使序列全部变为 $0$ . 在这之前还有两次操作, 我们需要把每个元素都变成 $n$ 的倍数. 选中一个长度为 $n - 1$ 的区间, 所有元素全部加上自身的 $n - 1$ 倍. 再单独选择剩下的那个元素, 加上自身的 $n - 1$ 倍即可. 注意 $n = 1$ 时需要特判. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;long long\u0026gt; a(n + 1, 0); for (int i = 1; i \u0026lt;= n; i++) { cin\u0026gt;\u0026gt;a[i]; } if (n == 1) { // 特判 cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;(long long)(-1) * a[1]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;1\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;0\u0026lt;\u0026lt;endl; return 0; } // Step 1 cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;n - 1\u0026lt;\u0026lt;endl; for (int i = 1; i \u0026lt;= n - 1; i++) { cout\u0026lt;\u0026lt;(long long)(n - 1) * a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; // Step 2 cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;(long long)(n - 1) * a[n]\u0026lt;\u0026lt;endl; // Step 3 cout\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; for (int i = 1; i \u0026lt;= n; i++) { cout\u0026lt;\u0026lt;(long long)(-1) * a[i] * n\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } 有关构造题的一些感想 # 0x3F大神说多做构造题有助于开拓思维. 这段时间在做CF上自己分段的题目, 发现CF构造题真的不少, 构造的标签通常和数学的标签一块出现. 看了不少解法, 对于高度抽象的题目, 还是要从极端的情况入手, 从具体的情况想是很难想到正解的. CF上构造题的解法都很精妙, 令人拍案叫绝, 不管是用来学习还是欣赏, 都是很有价值的.\n","date":"9 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1396a-multiples-of-length/","section":"Posts","summary":"CodeForces-1396A Multiples of Length # 题目大意 # 给你一个长度为 $n$ 的序列, 进行恰好三次操作，使得操作结束后序列所有数为 $0$ .","title":"CodeForces-1396A Multiples of Length"},{"content":"LeetCode-873 最长的斐波那契子序列的长度 # Solution 1 # 对于这种最长子序列的问题, 我们一般以其末尾的元素定义状态. 对于这道题, 有一点需要注意的是: 斐波那契子序列的状态推导和最后两个元素密切相关, 因此我们定义 $dp$ 数组时, 应该定义二维数组进行状态转移. 定义 $dp[i][j]$ 为以 $arr[j], arr[i]$ 为结尾的斐波那契子序列的最长长度, 则有如下状态转移方程: $$ dp[i][j]=\\underset{arr[k] = arr[i] - arr[j]}{max}dp[j][k] + 1 $$ 由于数组单调的特点, 我们可以建立哈希表, 快速找到一个值对应的下标. 代码如下:\nclass Solution { public: int lenLongestFibSubseq(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int INF = -(1e9 + 7); int n = arr.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, INF)); map\u0026lt;int, int\u0026gt; idx; for (int i = 0; i \u0026lt; n; i++) { idx[arr[i]] = i; } for (int i = 1; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; i; j++) { dp[i][j] = 2; } } int ans = 2; for (int i = 2; i \u0026lt; n; i++) { for (int j = 1; j \u0026lt; i; j++) { if (idx.count(arr[i] - arr[j])) { dp[i][j] = max(dp[i][j], dp[j][idx[arr[i] - arr[j]]] + 1); } ans = max(ans, dp[i][j]); } } return ans \u0026gt; 2? ans: 0; } }; ","date":"9 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-873-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","section":"Posts","summary":"LeetCode-873 最长的斐波那契子序列的长度 # Solution 1 # 对于这种最长子序列的问题, 我们一般以其末尾的元素定义状态.","title":"LeetCode-873 最长的斐波那契子序列的长度"},{"content":"","date":null,"permalink":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/","section":"Tags","summary":"","title":"哈希表"},{"content":"LeetCode-962 最大宽度坡 # Solution 1 # 代码如下:\n","date":"3 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-962-%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6%E5%9D%A1/","section":"Posts","summary":"LeetCode-962 最大宽度坡 # Solution 1 # 代码如下:","title":"LeetCode-962 最大宽度坡"},{"content":"LeetCode-329 矩阵中的最长递增路径 # Solution 1 # 这个经典问题还有一个别号叫做\u0026quot;滑雪问题\u0026quot;. 记 $dp[i][j]$ 为 $(i, j)$ 为起点的最长递增路径长度. 显然我们需要从 $(i, j)$ 出发, 向四个方向搜索, 对于合法的后继节点 $(x, y)$ 应当有 $dp[i][j] = max\\ dp[x][y] + 1$ . 我们利用深度优先搜索求出所有 $dp[i][j]$ 即可. 代码如下:\nclass Solution { public: int dir[4][2] = {{1,0},{0,-1},{0,1},{-1,0}}; int n, m, ans = 0; int dfs(int x, int y, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp; grid, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp; dp) { if (dp[x][y] != 0) { return dp[x][y]; } int cnt = 1; for (auto\u0026amp; d: dir) { int tx = x + d[0]; int ty = y + d[1]; if (tx \u0026gt;= 0 \u0026amp;\u0026amp; tx \u0026lt; m \u0026amp;\u0026amp; ty \u0026gt;= 0 \u0026amp;\u0026amp; ty \u0026lt; n \u0026amp;\u0026amp; grid[tx][ty] \u0026gt; grid[x][y]) { cnt = max(cnt, dfs(tx, ty, grid, dp) + 1); } } dp[x][y] = cnt; return cnt; } int longestIncreasingPath(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { m = grid.size(); n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { ans = max(ans, dfs(i, j, grid, dp)); } } return ans; } }; LeetCode-6110 网格图中递增路径的数目 与本题类似.\n","date":"3 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-329-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/","section":"Posts","summary":"LeetCode-329 矩阵中的最长递增路径 # Solution 1 # 这个经典问题还有一个别号叫做\u0026quot;滑雪问题\u0026quot;.","title":"LeetCode-329 矩阵中的最长递增路径"},{"content":"","date":null,"permalink":"/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"记忆化搜索"},{"content":"LeetCode-134 加油站 # Solution 1 # 如果从 $x$ 出发到不了 $y$ , 则从 $x, x + 1, \u0026hellip;, y - 1$ 中任一站出发都到不了 $y$ , 因为 $x$ 出发是到达中间某一站时可能还有油, 而直接从中间出发初始油量必为 $0$ . 想明白这一点, 这道题目我们贪心地寻找下一站即可. 代码如下:\nclass Solution { public: int canCompleteCircuit(vector\u0026lt;int\u0026gt;\u0026amp; gas, vector\u0026lt;int\u0026gt;\u0026amp; cost) { int n = gas.size(); int start = 0; while (start \u0026lt; n) { int sum = 0; int cnt = 0; while (cnt \u0026lt; n) { int now = start + cnt; sum += gas[now % n] - cost[now % n]; if (sum \u0026lt; 0) { break; } cnt++; } if (cnt == n) { return start; } else { start += cnt + 1; } } return -1; } }; 一道很有趣的加油站问题: # 本题所给数据不保证存在合法解, 那么加油站在怎样的约束下能够保证一定存在一个合法解呢? 有这样一道经典的加油站问题:\n一个环形轨道上有n个加油站, 所有加油站的油量总和正好够车跑一圈. 证明: 总能找到其中一个加油站, 使得初始时油箱为空的汽车从这里出发, 能够顺利环行一圈回到起点.\n这个结论告诉我们足够的油量是必要且充分的. 证明如下:\nProof 1 # 考虑环形轨道上的加油站必定存在一个加油站, 用它的油足够跑到下一个加油站. 这一点可以用反证法证明. 如果不存在这样的加油站, 对油量求和显然是不够车跑一圈的, 这与题设矛盾. 找到这个加油站之后, 把它和下一个加油站合并(这对汽车没有任何影响), 对新的加油站分布不断重复这一操作, 直到只剩下一个加油站为止, 显然这就是我们所找的加油站.\nProof 2 # 先让汽车油箱里装好足够多的油, 从任一加油站出发试跑一圈. 每到一个加油站时, 记录此时油箱里剩下的油量, 再把加油站的油全部装上. 试跑完一圈后, 检查刚才到各个加油站时所剩的油量, 从最少的那一个站点出发即可, 显然这种策略能保证全程油量 $\u0026gt;0$ .\n","date":"3 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-134-%E5%8A%A0%E6%B2%B9%E7%AB%99/","section":"Posts","summary":"LeetCode-134 加油站 # Solution 1 # 如果从 $x$ 出发到不了 $y$ , 则从 $x, x + 1, \u0026hellip;, y - 1$ 中任一站出发都到不了 $y$ , 因为 $x$ 出发是到达中间某一站时可能还有油, 而直接从中间出发初始油量必为 $0$ .","title":"LeetCode-134 加油站"},{"content":"CodeForces-1348C Phoenix and Distribution # 题目大意 # 给定长度为 $n$ 的字符串 $s$ , 将其不重不漏重组成 $k$ 个字符串, 输出使得字典序最大的字符串字典序最小的分法所得到的字典序最大的字符串.\nSolution 1 # 本题是一道很有趣的构造性问题. 要使得字典序最大的字符串最小, 首先我们考虑开头的第一个字符. 如果 $s$ 中字典序最小的字符 $c$ 个数 $\u0026gt;= k$ , 则每个开头都分配一个 $c$ 即可. 在考虑后面的字符, 如果全都一样, 我们尽可能均摊即可; 如果存在不一样的, 字典序最大的会决定字符串的字典序, 我们希望它尽可能靠后, 因此把所有的字符都\u0026quot;挤\u0026quot;到它前面; 如果 $s$ 中字典序最小的字符 $c$ 个数 $\u0026lt; k$ , 字典序最大的字符同样决定了字符串的字典序, 我们让其单独成为一个字符串. 通俗点讲就是: 已经彻底烂掉的, 我们就不管了; 不那么烂的, 我们抢救一下. 仔细思考这种策略是最优的. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { int n, k; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k\u0026gt;\u0026gt;s; sort(s.begin(), s.end()); if (s[0] != s[k-1]) { cout\u0026lt;\u0026lt;s[k - 1]\u0026lt;\u0026lt;endl; } else if (s[k] != s[n-1]) { cout\u0026lt;\u0026lt;s[0]; cout\u0026lt;\u0026lt;s.substr(k)\u0026lt;\u0026lt;endl; } else if (s[k] == s[n-1]) { cout\u0026lt;\u0026lt;s[0]; for (int i = 1; i \u0026lt;= (n - k) / k; i++) cout\u0026lt;\u0026lt;s[n-1]; if ((n - k) % k != 0) { cout\u0026lt;\u0026lt;s[n-1]; } cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"2 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1348c-phoenix-and-distribution/","section":"Posts","summary":"CodeForces-1348C Phoenix and Distribution # 题目大意 # 给定长度为 $n$ 的字符串 $s$ , 将其不重不漏重组成 $k$ 个字符串, 输出使得字典序最大的字符串字典序最小的分法所得到的字典序最大的字符串.","title":"CodeForces-1348C Phoenix and Distribution"},{"content":"LeetCode-871 最低加油次数 # Solution 1 # 这道题与CodeForces-1926C2 Potions (Hard Version)非常相似, 虽然本题求的是最少加油次数, 而后者求的是最多喝药次数, 但思考逻辑是相同的. 需要尽可能少地加油, 我们考虑尽可能不加油, 计算到下一站的油量. 当油量不够时, 再从之前路过而未加加油站中选择油量最大的加上. 如果加完了油还不足以到达下一站, 则返回 $-1$ . 把终点也视作一个加油站, 便于统一处理. 代码如下:\nclass Solution { public: int minRefuelStops(int target, int startFuel, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; stations) { int ans = 0; vector\u0026lt;int\u0026gt; end; end.push_back(target); end.push_back(0); stations.push_back(end); priority_queue\u0026lt;long long\u0026gt; q; int n = stations.size(); int fuel = startFuel; for (int i = 0; i \u0026lt; n; i++) { fuel -= (i == 0)? stations[i][0]: stations[i][0] - stations[i - 1][0]; if (fuel \u0026lt; 0) { while (!q.empty() \u0026amp;\u0026amp; fuel \u0026lt; 0) { int addFuel = q.top(); q.pop(); fuel += addFuel; ans++; } if (fuel \u0026lt; 0) { return -1; } } q.push(stations[i][1]); } return ans; } }; ","date":"2 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-871-%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0/","section":"Posts","summary":"LeetCode-871 最低加油次数 # Solution 1 # 这道题与CodeForces-1926C2 Potions (Hard Version)非常相似, 虽然本题求的是最少加油次数, 而后者求的是最多喝药次数, 但思考逻辑是相同的.","title":"LeetCode-871 最低加油次数"},{"content":"","date":null,"permalink":"/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","section":"Tags","summary":"","title":"优先队列"},{"content":"CodeForces-1389B Array Walk # 题目大意 # 题面翻译 # 一共有 $n$ 个格子, 每个格子都有它的分值 $a_x$. 当你到达第 $x$ 个格子就能获得 $a_x$ 得分. 初始时你站在第 $1$ 个格子, 每一次移动你可以选择向左或向右, 特别地, 向左移动的次数不能超过 $z$. 求走 $k$ 步所能得到的最大得分.\nSolution 1 # 每一次移动选择向左或向右, 这提示我们或许可以采用动态规划的解法. 由于可以向左走的特点, 可以选择当前位置再分析状态, 也可以选择直接以向左走的步数、向右走的步数作为状态. 这里我们选择后一种. 记 $dp[i][j]$ 为向右走了 $i$ 步, 向左走了 $j$ 步能得到的最大得分, 我们最终要求的就是 $$ \\underset{i + j = k}{max}\\ dp[i][j] $$ 在 $dp[i][j]$ 的前一步, 我们可以向右走, 也可以向左走, 都会走到 $a[i - j]$ 上. 有如下状态转移方程: $$ dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + a[i - j] $$ 这里的递推是不是单纯按行/列进行, 而是沿对角线进行的, 在写循环部分代码时需要注意. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { // cout\u0026lt;\u0026lt;\u0026#34;dot 0\u0026#34;\u0026lt;\u0026lt;endl; int n, k, z; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;k, \u0026amp;z); vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } int ans = 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(6, 0)); dp[0][0] = a[0]; for (int l = 1; l \u0026lt;= k; l++) { for (int i = l; i \u0026gt;= l - z; i--) { int j = l - i; if (j \u0026gt; i || j \u0026gt; z) { continue; } if (i != 0 \u0026amp;\u0026amp; j != 0) { dp[i][j] = max(dp[i - 1][j] + a[i - j], dp[i][j - 1] + a[i - j]); } else if (i == 0 \u0026amp;\u0026amp; j != 0) { dp[i][j] = dp[i][j - 1] + a[i - j]; } else if (i != 0 \u0026amp;\u0026amp; j == 0) { dp[i][j] = dp[i - 1][j] + a[i - j]; } if (i + j == k) { ans = max(ans, dp[i][j]); } } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"2 July 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1389b-array-walk/","section":"Posts","summary":"CodeForces-1389B Array Walk # 题目大意 # 题面翻译 # 一共有 $n$ 个格子, 每个格子都有它的分值 $a_x$.","title":"CodeForces-1389B Array Walk"},{"content":"CodeForces-235A LCM Challenge # 题目大意 # 输入 $n$ , 找到 $3$ 个不超过 $n$ 的正整数（可以相同），使得它们的 $LCM$ (最小公倍数)最大。输出最大的 $LCM$ .\nSolution 1 # 最小公倍数和最大公约数有如下关系: $LCM(n,m)=n∗m/GCD(n,m)$ , 我们需要寻找尽可能大的数, 同时它们的最大公约数尽可能小. 如果 $n$ 为奇数, $n, n - 1, n - 2$ 必然互质, 此时 $LCM$ 最大. 如果 $n$ 为偶数, 则 $n - 1$ 为奇数, 可以有 $n - 1, n - 2, n - 3$ . 有没有更大的呢? $n, n - 1, n - 2$ 不行( $n$ 与 $n - 2$ 都是偶数), 考虑 $n, n - 1, n - 3$, 我们计算 $n$ 与 $n - 3$ 是否互质, 若互质, 则取 $n, n - 1, n - 3$ , 否则取 $n - 1, n - 2, n - 3$ . 注意 $n = 1, 2$ 的情况需要单独处理. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { long long n; cin\u0026gt;\u0026gt;n; if (n \u0026lt;= 2) { cout\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; } else { if (n % 2 == 1) { cout\u0026lt;\u0026lt;n * (n - 1) * (n - 2)\u0026lt;\u0026lt;endl; } else if (__gcd(n, (n - 3)) == 1) { cout\u0026lt;\u0026lt;n * (n - 1) * (n - 3)\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;(n - 1)* (n - 2) * (n - 3)\u0026lt;\u0026lt;endl; } } return 0; } ","date":"30 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-235a-lcm-challenge/","section":"Posts","summary":"CodeForces-235A LCM Challenge # 题目大意 # 输入 $n$ , 找到 $3$ 个不超过 $n$ 的正整数（可以相同），使得它们的 $LCM$ (最小公倍数)最大。输出最大的 $LCM$ .","title":"CodeForces-235A LCM Challenge"},{"content":"CodeForces-1344A Hilbert\u0026rsquo;s Hotel # 题目大意 # 给你一个无限长的数轴还有一个大小为 $n$ 的整数数组 $a_0,a_1\u0026hellip;a_{n-1}$. 对于数轴上的所有表示整数的点按如下规则映射: 对于任意一个整数 $k$ , $k$ 将会被移动到 $k+a_{,k \\bmod n}$ 所在的位置. 现在请你判断移动后是否有任意两个整数的位置相同, 输出 $\u0026ldquo;YES\u0026rdquo;$ 或 $\u0026ldquo;NO\u0026rdquo;$ .\nSolution 1 # 数字 $i$ 被映射到 $i + a[i % n]$ , 注意到对不同 $n$ 长度周期内的数字映射结果都是平移 $n$ 的, 我们考虑一个周期内的像是否存在重复即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { long long n; cin\u0026gt;\u0026gt;n; set\u0026lt;long long\u0026gt; st; long long temp = 0; for (long long i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;temp; st.insert(((i + temp) % n + n) % n); } if ((long long)st.size() == n) { cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } ","date":"30 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1344a-hilberts-hotel/","section":"Posts","summary":"CodeForces-1344A Hilbert\u0026rsquo;s Hotel # 题目大意 # 给你一个无限长的数轴还有一个大小为 $n$ 的整数数组 $a_0,a_1\u0026hellip;a_{n-1}$.","title":"CodeForces-1344A Hilbert's Hotel"},{"content":"CodeForces-1334C Circle of Monsters # 题目大意 # 有 $N$ 头怪兽, 他们围成一个环, 顺时针编号 $1, 2, 3, 4,\u0026hellip;, N$ 每一头怪兽都有 $2$ 个属性, 一个是它的生命值 $a_i$, 第二个是它的爆炸伤害 $b_i$. 你有一把手枪, 可以选中一个怪兽开一枪使其生命值 $-1$ . 当一个怪兽生命值 $\\leq 0$ 时, 它会发生爆炸, 并对后一个怪兽造成 $b_i$ 点伤害. 爆炸可以连环发生, 但不会跨过已死的怪兽发生. 返回杀死所有怪兽所需要开的最少枪数.\nSolution 1 # 为了杀死一个怪兽, 我们可以选择用枪的伤害灌死它, 也可以考虑利用上一个怪兽爆炸的伤害来解决它, 显然后一种方法更省子弹. 为了尽可能多的利用爆炸伤害, 我们的目标就是达成一个理想状态, 使得一个怪兽爆炸后, 所有的怪兽都会连环爆炸. 为了达成这个状态, 我们先要开枪把怪兽的生命值降低到临界值, 如果 $b[i - 1] \u0026gt;= a[i]$ , 我们不需要额外开枪; 如果 $b[i - 1] \u0026lt; a[i]$ , 我们需要先开上 $a[i] - b[i - 1]$ 枪. 达成临界状态后, 需要一个\u0026quot;起爆点\u0026quot; , 我们选择临界值最小的怪兽开枪将其杀死即可. 这道题的测试数据卡cin, 需要用scanf代替. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); while (t--) { long long ans = 0; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); vector\u0026lt;long long\u0026gt; a(n, 0), b(n, 0); long long trigger = 1e12 + 10; for (int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;a[i], \u0026amp;b[i]); } for (int i = 0; i \u0026lt; n; i++) { ans += max(a[i] - b[(i - 1 + n) % n], 0LL); a[i] -= max(a[i] - b[(i - 1 + n) % n], 0LL); trigger = min(trigger, a[i]); } ans += trigger; printf(\u0026#34;%lld\\n\u0026#34;, ans); } return 0; } ","date":"30 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1334c-circle-of-monsters/","section":"Posts","summary":"CodeForces-1334C Circle of Monsters # 题目大意 # 有 $N$ 头怪兽, 他们围成一个环, 顺时针编号 $1, 2, 3, 4,\u0026hellip;, N$ 每一头怪兽都有 $2$ 个属性, 一个是它的生命值 $a_i$, 第二个是它的爆炸伤害 $b_i$.","title":"CodeForces-1334C Circle of Monsters"},{"content":"CodeForces-1926C2 Potions (Hard Version) # 题目大意 # 输入一个长度为 $n$ 的数组 $a$ , 求其前缀和恒非负的最长子序列(不要求连续)的长度.\nSolution 1 # 首先遇到正元素一定要选择, 如果遇到负元素呢? 一个直接的想法是: 很小的不能选, 因为有可能因为选了这个很小的导致后面的一些负元素没办法选取. 如何把这种思考逻辑转化成策略? 我们使用贪心的策略, 遇到任何元素都选取, 当前缀和为负时, 再抛弃所选的最小元素, 这一部分使用优先队列维护即可. 显然这种选法是最优的, 并且能保证序列合法. 思考出贪心的关键点在于把一个依赖后续的决策变成了可以抛弃的贪心决策. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; long long health = 0; int ans = 0; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; q; vector\u0026lt;int\u0026gt; a(n, 0); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; q.push(a[i]); health += a[i]; ans++; if (health \u0026lt; 0) { int temp = q.top(); q.pop(); health -= temp; ans--; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"30 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1926c2-potions-hard-version/","section":"Posts","summary":"CodeForces-1926C2 Potions (Hard Version) # 题目大意 # 输入一个长度为 $n$ 的数组 $a$ , 求其前缀和恒非负的最长子序列(不要求连续)的长度.","title":"CodeForces-1926C2 Potions (Hard Version)"},{"content":"CodeForces-1353D Constructing the Array # 题目大意 # 输入一个 $n$ , 对一个长度为 $n$ 的全 $\u0026lsquo;0\u0026rsquo;$ 串进行 $n$ 次操作，第 $i$ 次操作选中当前长度最长的全 $\u0026lsquo;0\u0026rsquo;$ 子串中最靠左的, 记其左右端点坐标分别为 $left, right$. 如果 $right - left + 1$ 是奇数，那么第 $\\frac{left + right}{2}$ 个数更新为 $i$ ，否则第 $\\frac{left + right - 1}{2}$ 个数更新成 $i$ . 输出 $n$ 次操作后的串.\nSolution 1 # 想办法维护每次需要的取出的区间, 这一点通过优先队列来实现. 定义结构体存储左右端点, 重载运算符, 按照区间大小, 左端点前后排序. 之后模拟题给操作即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct node { int left, right; bool operator \u0026lt; (const node \u0026amp;y) const { int len1 = right - left + 1, len2 = y.right - y.left + 1; return len1 == len2? (left \u0026gt; y.left): (len1 \u0026lt; len2); } }; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n + 1, 0); priority_queue\u0026lt;node\u0026gt; q; q.push((node){1, n}); for (int i = 1; i \u0026lt;= n; i++) { node temp = q.top(); q.pop(); a[(temp.left + temp.right) / 2] = i; if ((temp.left + temp.right) / 2 - temp.left \u0026gt;= 1) { q.push(node{temp.left, (temp.left + temp.right) / 2 - 1}); } if (temp.right - ((temp.left + temp.right) / 2) \u0026gt;= 1) { q.push(node{(temp.left + temp.right) / 2 + 1, temp.right}); } } for (int i = 1; i \u0026lt;= n; i++) { cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"30 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1353d-constructing-the-array/","section":"Posts","summary":"CodeForces-1353D Constructing the Array # 题目大意 # 输入一个 $n$ , 对一个长度为 $n$ 的全 $\u0026lsquo;0\u0026rsquo;$ 串进行 $n$ 次操作，第 $i$ 次操作选中当前长度最长的全 $\u0026lsquo;0\u0026rsquo;$ 子串中最靠左的, 记其左右端点坐标分别为 $left, right$.","title":"CodeForces-1353D Constructing the Array"},{"content":"LeetCode-2321 拼接数组的最大分数 # Solution 1 # 如果我们选择交换 $[left, right]$ 区间, 则对于 $nums1$ 而言, 新的数组和为 $$ \\sum_{i = 0}^{left - 1}nums1[i] + \\sum_{i=left}^{right}nums2[i] + \\sum_{i=right + 1}^{n - 1}nums1[i] $$ 变形为: $$ \\sum_{i = 0}^{n - 1}nums[1] + \\sum_{i = left}^{right}(nums2[i] - nums1[i]) $$ 记 $diff[i] = nums2[i] - nums1[i]$ , 我们求出 $diff$ 的连续子数组最大和即可. 这一部分的处理是很经典的动态规划, 在此不再赘述. 对于 $nums2$ 而言, 处理方法类似, 交换后新的数组和为 $$ \\sum_{i = 0}^{n - 1}nums2[i] - \\sum_{i = left}^{right}(nums2[i] - nums1[i]) $$ 这里应当求 $diff$ 的连续子数组最小和. 最后不要忘记考虑不交换的情形, 把 $ans$ 与 $nums1, nums2$ 的数组和比较一下. 代码如下:\nclass Solution { public: int maximumsSplicedArray(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int n = nums1.size(); vector\u0026lt;int\u0026gt; diff(n, 0); int sum1 = 0, sum2 = 0; for (int i = 0; i \u0026lt; n; i++) { diff[i] = nums2[i] - nums1[i]; sum1 += nums1[i]; sum2 += nums2[i]; } int ans = max(sum1, sum2); vector\u0026lt;int\u0026gt; dp1(n, 0), dp2(n, 0); for (int i = 0; i \u0026lt; n; i++) { dp1[i] = (i == 0)? diff[i]: max(dp1[i - 1] + diff[i], diff[i]); dp2[i] = (i == 0)? diff[i]: min(dp2[i - 1] + diff[i], diff[i]); } for (int i = 0; i \u0026lt; n; i++) { ans = max(ans, max(sum1 + dp1[i], sum2 - dp2[i])); } return ans; } }; ","date":"28 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2321-%E6%8B%BC%E6%8E%A5%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0/","section":"Posts","summary":"LeetCode-2321 拼接数组的最大分数 # Solution 1 # 如果我们选择交换 $[left, right]$ 区间, 则对于 $nums1$ 而言, 新的数组和为 $$ \\sum_{i = 0}^{left - 1}nums1[i] + \\sum_{i=left}^{right}nums2[i] + \\sum_{i=right + 1}^{n - 1}nums1[i] $$ 变形为: $$ \\sum_{i = 0}^{n - 1}nums[1] + \\sum_{i = left}^{right}(nums2[i] - nums1[i]) $$ 记 $diff[i] = nums2[i] - nums1[i]$ , 我们求出 $diff$ 的连续子数组最大和即可.","title":"LeetCode-2321 拼接数组的最大分数"},{"content":"CodeForces-1352G Special Permutation # 题目大意 # 对于$1, 2, \u0026hellip;, n$ 的排列 $p$ , 如果 $\\forall 1\\leq i\\leq n -1, 2\\leq \\vert p_i - p_{i + 1}\\vert \\leq 4$ , 则称其为特殊排列. 输入 $n$ , 如果存在特殊排列, 返回任意一个排列, 否则返回 $-1$ .\nSolution 1 # 首先验证 $n = 1, 2, 3$ 时不存在特殊排列, $n = 4$ 时有特殊排列 $3, 1, 4, 2$. 对于 $n \u0026gt; 4$ , 我们把新增的奇数放到左边, 新增的偶数放到右边即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; if (n \u0026lt; 4) { cout\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; } else { for (int i = (n - 1) / 2 * 2 + 1; i \u0026gt;= 1; i -= 2) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;4\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;2\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for (int i = 6; i \u0026lt;= n / 2 * 2; i += 2) { cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } } return 0; } ","date":"27 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1352g-special-permutation/","section":"Posts","summary":"CodeForces-1352G Special Permutation # 题目大意 # 对于$1, 2, \u0026hellip;, n$ 的排列 $p$ , 如果 $\\forall 1\\leq i\\leq n -1, 2\\leq \\vert p_i - p_{i + 1}\\vert \\leq 4$ , 则称其为特殊排列.","title":"CodeForces-1352G Special Permutation"},{"content":"CodeForces-1398C Good Subarrays # 题目大意 # 如果一个数组满足元素之和等于数组长度, 则称这个数组为\u0026quot;好数组\u0026quot;. 给定一个元素均为 $0$ 到 $9$ 之间整数的数组 $a_1, a_2,\u0026hellip;,a_n$ , 返回其连续子数组中\u0026quot;好数组\u0026quot;的个数.\nSolution 1 # 注意到数组长度只和下标的相对位置有关系, 我们把题给数组从下标 $0$ 开始计数对答案没有影响. 考虑连续子数组 $a[l],\u0026hellip;,a[r](l\\leq r)$ , 若其为\u0026quot;好数组\u0026quot;, 则应当有 $\\sum_{k=l}^{r}a[k]=r - l + 1$ . 由于需要多次计算数组区间和, 使用前缀和进行优化, 记 $pre[i] = \\sum_{k=0}^{i}a[k]$ , 约束改写为 $pre[r] - pre[l - 1] = r - l + 1$. 再记 $b[i] = pre[i] - i$ , 则约束简化为 $b[r] = b[l - 1]$ . 对于 $i = 0, 1,\u0026hellip;,n - 1$, 可以计算出 $b[i]$ , 同时注意到当 $l = 0$ 时, 存在一个形式上的 $b[-1]$ , 其值为 $0 - (-1)=1$. 假设存在 $k_1,\u0026hellip;,k_m$ 满足 $b[k_j]$值相等 , 则可以构成 $\\frac{m × (m - 1)}{2}$ 个\u0026quot;好数组\u0026quot;. 我们遍历 $b[i]$ 能取到的值, 把结果累加即可. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; long long ans = 0; vector\u0026lt;int\u0026gt; a(n, 0); map\u0026lt;long long, long long\u0026gt; book; for (int i = 0; i \u0026lt; n; i++) { a[i] = (i == 0)? s[i] - \u0026#39;0\u0026#39;: s[i] - \u0026#39;0\u0026#39; + a[i - 1]; } for (int i = 0; i \u0026lt; n; i++) { a[i] -= i; book[a[i]]++; } book[1]++; // a[-1] = 1 auto it = book.begin(); while (it != book.end()) { ans += (it-\u0026gt;second - 1) * it-\u0026gt;second / 2; it++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } Solution 2 # 有一种更容易理解的方法. 我们把 $a[i]$ 的每个元素都减去 $1$ , 则寻找和恰为 $0$ 的连续子数组即可. 从前向后计算前缀和, 每次计算前缀和时, 总个数便加上该数值之前出现过的次数. 如果前缀和为 $0$ , 则自身也能构成一个\u0026quot;好数组\u0026quot;, 此时计数再 $+1$. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; string s; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; long long ans = 0; vector\u0026lt;int\u0026gt; a(n, 0); map\u0026lt;long long, long long\u0026gt; book; for (int i = 0; i \u0026lt; n; i++) { a[i] = (i == 0)? s[i] - \u0026#39;0\u0026#39; - 1: s[i] - \u0026#39;0\u0026#39; - 1 + a[i - 1]; } for (int i = 0; i \u0026lt; n; i++) { ans += book[a[i]]; book[a[i]]++; if (a[i] == 0) { ans++; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"27 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1398c-good-subarrays/","section":"Posts","summary":"CodeForces-1398C Good Subarrays # 题目大意 # 如果一个数组满足元素之和等于数组长度, 则称这个数组为\u0026quot;好数组\u0026quot;.","title":"CodeForces-1398C Good Subarrays"},{"content":"CodeForces-1542B Plus and Multiply # 题目大意 # 给定正整数 $a, b$ , 考虑无限集 $S$ , $S$ 由如下规则构造:\n1 $\\in S$ $\\forall x\\in S, x × a\\in S, x + b\\in S$ 输入 $t$ ,代表有 $t$ 组测试数据, 每组数据输入正整数 $n, a, b$ , 判别 $n$ 是否在 $a, b$ 构造的 $S$ 中. Solution 1 # 对于 $x\\in S$ , 可构造出 $x × a$ 和 $x + b$ , 满足 $x\\equiv x × a\\equiv x + b\\ mod\\ b$ , 由于初始元素为 $1$, 所以有 $n\\equiv a^k\\ mod\\ b$ , 这是一个必要条件, 而当 $a^k\\leq n$ 时, 可以构造出 $n$, 此时也充分. 本题在 $a = 1$ 时, 最好特判, 同时注意利用 $(n - 1)\\equiv 0\\ mod\\ b$, 而不是 $n\\equiv 1\\ mod\\ b$ 判断, 后者在 $b = 0$ 时会判断出错. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n, a, b; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; bool flag = false; if (a == 1) { flag = ((n - 1) % b == 0); } else { long long pow = 1; while (pow \u0026lt;= n) { if (pow % b == n % b) { flag = true; break; } pow *= a; } } if (flag) { cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; } else { cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } ","date":"27 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1542b-plus-and-multiply/","section":"Posts","summary":"CodeForces-1542B Plus and Multiply # 题目大意 # 给定正整数 $a, b$ , 考虑无限集 $S$ , $S$ 由如下规则构造:","title":"CodeForces-1542B Plus and Multiply"},{"content":"数据挖掘与机器学习 Section 1 # 什么是机器学习 # 机器学习的核心目标是从经验数据中推导出规律, 并将这种规律应用于新的数据中, 其本质是使用统计技术给计算机系统提供\u0026quot;学习\u0026quot;(即逐步提高特定任务的性能)的能力, 而不是显式编程.\n数据集的加载与分割 # from sklearn import datasets # 加载Scikit-learn自带的数据集 iris = datasets.load_iris() # 鸢尾花卉数据集 digits = datasets.load_digits() # 手写数字数据集 print(digits.data) # 数据集是一个类似字典的对象, 保存有关数据集的所有数据和一些样本特征数据, 通常储存在.data成员中 # 打印结果如下 # [[ 0. 0. 5. ... 0. 0. 0.] # [ 0. 0. 0. ... 10. 0. 0.] # [ 0. 0. 0. ... 16. 9. 0.] # ... # [ 0. 0. 1. ... 6. 0. 0.] # [ 0. 0. 2. ... 12. 0. 0.] # [ 0. 0. 10. ... 12. 1. 0.]] print(digits.target) # 在有监督的学习中, 一个或多个标记类别存储在.target成员中 # 打印结果如下 # [0 1 2 ... 8 9 8] # 通常在训练有监督学习的机器学习模型时, 会将数据集划分为训练集和测试集, 比例一般为0.75:0.25. # 划分的意义在于选出准确率最好, 泛化能力最佳的模型 from sklearn.model_selection import train_test_split # 加载训练集测试集分割部分 x = iris.data y = iris.target print(x.shape) # (150, 4) print(y.shape) # (150,) x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.4, random_state=0) # 划分训练集与测试集, 测试集占比0.4 print(x_train.shape) # (90, 4) print(x_test.shape) # (60, 4) print(y_train.shape) # (90,) print(y_test.shape) # (60,) # 可以看出, 数据集已经按比例分割为了两部分 机器学习的模型 # 模型的选择 # 在机器学习中存在大量实现类似功能的模型, 如何选择合适的模型非常重要, 可以参照以下几点进行思考:\n数据的大小, 质量及性质 可用计算时间 任务的急迫性 数据的使用用途 学习与预测 # 从数据中训练模型的过程称为\u0026quot;学习\u0026quot;(Learning), 这个过程通过执行某个学习型算法来完成. 模型对应了数据的某种潜在的规律, 亦称\u0026quot;假设\u0026quot;(Hypothesis), 这种潜在规律则称为\u0026quot;真相\u0026quot;或\u0026quot;真实\u0026quot;(Ground-Truth). 学习过程就是为了找出或逼近真相.\n实现机器学习模型 # from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split from sklearn.neighbors import KNeighborsClassifier # 导入k最近邻(kNN, k-Nearest Neighbor)分类算法 iris = load_iris() x = iris.data y = iris.target x_train, x_test, y_train, y_test = train_test_split(x, y, random_state=4) # random_state参数可以理解为\u0026#34;随机\u0026#34;划分的种子, 对于一样的random_state, 划分结果相同 # 建立模型 knn = KNeighborsClassifier() # 训练模型 knn.fit(x_train, y_train) # 预测模型 knn.predict(x_test) 模型的评判与保存 # 分类, 回归, 聚类不同的评判指标 # 一般来说, 我们把模型的实际预测输出与样本的真实输出之间的差异称为\u0026quot;误差\u0026quot;(Error), 模型在训练集上的误差叫做\u0026quot;训练误差\u0026quot;(Training Error)或\u0026quot;经验误差\u0026quot;(Empirical Error), 在新样本上的误差叫做\u0026quot;泛化误差\u0026quot;(Generalization Error). 我们希望得到泛化误差小的模型(即面对新数据表现更好的模型). 一个训练误差很小的模型不一定优秀, 事实上, 在训练集上表现过好的模型泛化能力往往较差. 在评判机器学习模型时, 我们需要依据不同的模型选择不同的评测指标. 在分类问题中, 常用指标如下:\n准确率(Accuracy), 对于指定的测试数据集, 分类器正确分类的样本数与总样本数之比. AUC(Area Under Curve), 这是一个概率值. 当随机挑选一个正样本以及一个负样本时, 当前的分类算法根据计算得到的Source值将这个正样本排在负样本前面的概率就是AUC值. 对应的AUC更大的分类器效果更好. 在回归分析中, 常用指标如下: 均方误差(Mean Squared Error, MSE), 指参数估计值与真实值的差的平方的期望值, 计算公式为 $$ MSE(y, \\hat y)=\\frac{1}{n_{sample}}\\sum_{i=0}^{n_{sample}}(y_i-\\hat y_i)^2 $$ 平均绝对误差(Mean Absolute Deviation, MAD), 指参数估计值与真实值之差的绝对值的期望值, 计算公式为 $$ MAD(y, \\hat y)=\\frac{1}{n_{sample}}\\sum_{i=0}^{n_{sample}}\\vert y_i-\\hat y_i\\vert $$ 聚类分析的指标在之后会介绍. 交叉验证 # 为了尽可能提高数据集的利用率, 使用交叉验证的方法来评估模型. 对于 $k$ 折交叉验证(K-Fold Cross Validation), 把数据集 $D$ 划分为 $k$ 个大小相似的互斥子集 $D_1, D_2,\u0026hellip;,D_k$ , 每次选一个子集作为测试集, 其余子集的并集作为训练集, 从而可以进行 $k$ 次训练和测试, 最终评估结果为 $k$ 次测试结果的均值. $k$ 最常见的取值是 $10$ .\n实现分类、回归指标 # 分类:\nimport numpy as np from sklearn.metrics import accuracy_score # 分类模型中评测指标的调用 # 准确率 y_pred = [0, 2, 1, 3] # 预测结果 y_true = [0, 1, 2, 3] # 真实值 print(accuracy_score(y_true, y_pred)) # 评估准确率, 打印结果为0.5 print(accuracy_score(y_true, y_pred, normalize=False)) # 评估准确的个数, 打印结果为2 # AUC值计算 from sklearn import metrics y = np.array([1, 1, 2, 2]) # 二进制标签, 如果标签不是二进制的, 在metrics.roc_curve()中应该显式地给出pos_label pred = np.array([0.1, 0.4, 0.35, 0.8]) # pred为目标得分, 也就是给出一个估计的信心值 fpr, tpr, thresholds = metrics.roc_curve(y, pred, pos_label=2) # fpr为False Positive Rate, tpr为True Positive Rate, thresholds阈值 print(metrics.auc(fpr, tpr)) # 输出结果为0.75 回归:\nfrom sklearn.metrics import precision_recall_curve from sklearn.metrics import mean_squared_error y_true = [3, -0.5, 2, 7] y_pred = [2.5, 0.0, 2, 8] print(mean_squared_error(y_true, y_pred)) # 打印结果为0.375 y_true = [[0.5, 1], [-1, 1], [7, -6]] y_pred = [[0, 2], [-1, 2], [8, -5]] print(mean_squared_error(y_true, y_pred)) # multioutput默认值为\u0026#39;uniform_average\u0026#39;, 返回所有元素的均方误差. 打印结果为0.7083... print(mean_squared_error(y_true, y_pred, multioutput=\u0026#39;raw_values\u0026#39;)) # raw_values, 按列计算均方误差, 返回一个元素数与列数相等的一维数组. 打印结果为[0.416..., 1] print(mean_squared_error(y_true, y_pred, multioutput=[0.3, 0.7])) # 加权计算均方误差, 返回标量. 打印结果为0.825 # 可析方差得分计算 from sklearn.metrics import explained_variance_score y_true = [3, -0.5, 2, 7] y_pred = [2.5, 0.0, 2, 8] print(explained_variance_score(y_true, y_pred)) # 打印结果为0.957... y_true = [[0.5, 1], [-1, 1], [7, -6]] y_pred = [[0, 2], [-1, 2], [8, -5]] print(explained_variance_score(y_true, y_pred, multioutput=\u0026#39;uniform_average\u0026#39;)) # 打印结果为0.983 ","date":"26 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-section-1/","section":"Posts","summary":"数据挖掘与机器学习 Section 1 # 什么是机器学习 # 机器学习的核心目标是从经验数据中推导出规律, 并将这种规律应用于新的数据中, 其本质是使用统计技术给计算机系统提供\u0026quot;学习\u0026quot;(即逐步提高特定任务的性能)的能力, 而不是显式编程.","title":"数据挖掘与机器学习 学习笔记"},{"content":"LeetCode-30 串联所有单词的子串 # Solution 1 # 本题是LeetCode-438 找到字符串中所有字母异位词的进阶版, 把字母变成了单词. 在LeetCode-438中的滑动窗口做法仍然可用, 具体实现只需要修改一部分. 我们把窗口滑动的单位改为单词的长度 $n$, 分类讨论起始位置 $0, 1,\u0026hellip;, n - 1$ 即可. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; findSubstring(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) { vector\u0026lt;int\u0026gt; ans; int n = words[0].size(); // 创建两个哈希表, need存储目标字符串的元素构成, window存储当前窗口字符串的元素构成 unordered_map\u0026lt;string, int\u0026gt; need; for (string word: words) { need[word]++; } for (int i = 0; i \u0026lt; n; i++) { // 分别考虑从0, 1,..., n - 1开头的字符串 以n为单位进行移动 unordered_map\u0026lt;string, int\u0026gt; window; int left = 0, right = 0; //[left * n + i, (right - 1) * n + i] int valid = 0; while (right * n + i \u0026lt; s.size()) { string wordin = s.substr(right * n + i, n); right++; // 扩大窗口 if (need.count(wordin)) { window[wordin]++; if (window[wordin] == need[wordin]) { valid++; // 数据更新 } } while (right - left \u0026gt; words.size() \u0026amp;\u0026amp; valid == need.size()) { string wordout = s.substr(left * n + i, n); left++; // 缩小窗口 if (need.count(wordout)) { if (window[wordout] == need[wordout]) { valid--; // 数据更新 } window[wordout]--; } } // 判断一个合法的窗口是否是我们需要的 if (valid == need.size()) { ans.push_back(left * n + i); } } } return ans; } }; ","date":"23 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/","section":"Posts","summary":"LeetCode-30 串联所有单词的子串 # Solution 1 # 本题是LeetCode-438 找到字符串中所有字母异位词的进阶版, 把字母变成了单词.","title":"LeetCode-30 串联所有单词的子串"},{"content":"LeetCode-438 找到字符串中所有字母异位词 # Solution 1 # 本题是一道经典的滑动窗口问题, 同时有一个值得关注的处理思想: 如何判别异位词? 答案是利用哈希表存储元素构成, 对比是否为异位词. 这道题我们利用滑动窗口, 依照扩大窗口-更新数据-缩小窗口-更新数据的基本流程编写代码即可. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { vector\u0026lt;int\u0026gt; ans; // 创建两个哈希表, need存储目标字符串的元素构成, window存储当前窗口字符串的元素构成 unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c: p) { need[c]++; } int left = 0, right = 0; // [left, right) 左开右闭区间 int valid = 0; while (right \u0026lt; s.size()) { char c = s[right]; right++; // 扩大窗口 if (need.count(c)) { window[c]++; if (window[c] == need[c]) { valid++; // 数据更新 } } while (right - left \u0026gt; p.size() \u0026amp;\u0026amp; valid == need.size()) { char d = s[left]; left++; // 缩小窗口 if (need.count(d)) { if (window[d] == need[d]) { valid--; // 数据更新 } window[d]--; } } // 判断一个合法的窗口是否是我们需要的 if (valid == need.size()) { ans.push_back(left); } } return ans; } }; ","date":"23 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","section":"Posts","summary":"LeetCode-438 找到字符串中所有字母异位词 # Solution 1 # 本题是一道经典的滑动窗口问题, 同时有一个值得关注的处理思想: 如何判别异位词?","title":"LeetCode-438 找到字符串中所有字母异位词"},{"content":"CodeForces-1338A Powered Addition # 题目大意 # 输入正整数 $t$ , 一共有 $t$ 个测试点, 每个测试点输入 $n$ , 之后输入 $n$ 个整数代表 $a_0, a_1,\u0026hellip;,a_{n-1}$ . 在 $x$ 时刻, 可以任意选择 $a$ 中元素使其增加 $2^{x-1}$ . 返回使得 $a$ 为单调不减数列所需的最少时间.\nSolution 1 # 我们从左向右查看数列中的元素, 对于前 $i + 1$ 个数, 需要满足单调不减, 则需要 $a_i$ 增加到 $\\underset{0\\leq k\\leq i}{max}\\ a_k$ , 从二进制的角度考虑, 每一次至多改变差值上的一位, $\\underset{0\\leq k\\leq i}{max}\\ a_k -a_i$ 的位数就是处理前 $i + 1$ 个数所需的时间. 注意到这一操作对后续求解没有影响, 我们所求即是 $\\underset{0\\leq i\\leq n-1}{max}(\\underset{0\\leq k\\leq i}{max}\\ a_k-a_i)$ 的位数. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int t; cin\u0026gt;\u0026gt;t; while (t--) { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n, 0); int ans = 0; int nowmax = -1000000007; int gap = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;a[i]; nowmax = max(nowmax, a[i]); gap = max(gap, nowmax - a[i]); } while (gap) { gap\u0026gt;\u0026gt;=1; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":"23 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-1338a-powered-addition/","section":"Posts","summary":"CodeForces-1338A Powered Addition # 题目大意 # 输入正整数 $t$ , 一共有 $t$ 个测试点, 每个测试点输入 $n$ , 之后输入 $n$ 个整数代表 $a_0, a_1,\u0026hellip;,a_{n-1}$ .","title":"CodeForces-1338A Powered Addition"},{"content":"","date":null,"permalink":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/","section":"Tags","summary":"","title":"二进制"},{"content":"","date":null,"permalink":"/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/","section":"Tags","summary":"","title":"逆序对"},{"content":"CodeForces-545C Woodcutters # 题目大意 # 输入正整数 $n$ 与形状为 $n × 2$ 的数组 $tree$ , 其中 $tree[i][0]$ 代表第 $i$ 棵树在数轴上的坐标, $tree[i][1]$ 代表第 $i$ 棵树的高度. 伐木时需要让树向左倒或向右倒, 要求空区间长度大于树木高度. 返回最多能砍多少棵树.\nSolution 1 # To do or not to do问题, 可以用动态规划进行求解. 对于一棵树, 我们可以选择不砍, 向左倒或者向右倒, 依据这一特点进行状态转移方程的构建. 对于前 $i$ 棵树, 记 $dp[i][0]$ 不砍第 $i$ 棵树最多砍伐的数目, 类似的, $dp[i][1]$ 为向左, $dp[i][2]$ 为向右. 当不砍伐当前树木时, 显然有: $$ dp[i][0] = max(dp[i - 1][0], dp[i][1], dp[i][2]) $$ 如果选择向左倒, 如果左侧区间足够容纳两棵树, 则在前一棵树右倒的情况下左倒; 如果仅能容纳第 $i$ 棵树, 则在前一棵树不砍或左倒的情况下左倒; 如果不能容纳第 $i$ 棵树, 则该操作不合法, 数量为 $0$ . 则有: $$ dp[i][1] = \\begin{cases} dp[i - 1][2] + 1,\\quad tree[i][0] - tree[i - 1][0] \u0026gt; tree[i][1] + tree[i - 1][1]\\ max(dp[i - 1][0], dp[i - 1][1]) + 1,\\quad tree[i][1] + tree[i - 1][1]\\geq tree[i][0] - tree[i - 1][0] \u0026gt; tree[i][1]\\ 0,\\quad tree[i][0] - tree[i - 1][0] \\leq tree[i][1] \\end{cases} $$ 如果选择向右倒, 则考虑右侧区间是否能够容纳第 $i$ 棵树, 状态转移方程如下: $$ dp[i][2] = \\begin{cases} max(dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]) + 1),\\quad tree[i + 1][0] - tree[i][0]) \u0026gt; tree[i][1]\\ 0,\\quad tree[i + 1][0] - tree[i][0]) \\leq tree[i][1] \\end{cases} $$ 最终结果即为 $max(dp[n - 1][0, dp[]n - 1][1], dp[n - 1][2])$ , 注意到最后一颗树向右倒总是最优的, 所以结果其实就是 $dp[n - 1][2]$. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; tree(n + 1, vector\u0026lt;long long\u0026gt;(2, 0)); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;tree[i][0]\u0026gt;\u0026gt;tree[i][1]; } tree[n][0] = 1000000000 * 2 + 10; // 加一棵位置很远的虚拟树, 方便i = n - 1时的处理 // 从左向右考虑tree, tree[i]是否砍倒 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(3, 0)); // dp[i][0]为tree[i]不砍, 1为向左倒, 2为向右倒 dp[0][0] = 0; dp[0][1] = 1; dp[0][2] = (tree[1][0] - tree[0][0]) \u0026gt; tree[0][1]; for (int i = 1; i \u0026lt; n; i++) { dp[i][0] = max(max(dp[i - 1][0], dp[i - 1][1]), dp[i - 1][2]); if (tree[i][0] - tree[i - 1][0] \u0026gt; tree[i][1] + tree[i - 1][1]) { dp[i][1] = dp[i - 1][2] + 1; } else if (tree[i][0] - tree[i - 1][0] \u0026gt; tree[i][1]) { dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]) + 1; } dp[i][2] = (max(max(dp[i - 1][0], dp[i - 1][1]), dp[i - 1][2]) + 1) * ((tree[i + 1][0] - tree[i][0]) \u0026gt; tree[i][1]); } cout\u0026lt;\u0026lt;dp[n - 1][2]\u0026lt;\u0026lt;endl; // 最后一棵树向右倒总是最优的 return 0; } Solution 2 # 本题也可以用贪心的思想求解. 对于一棵树, 如果能向左倒一定选择向左倒, 如果不能向左倒呢? 其实这时向右倒是最优的. 不严谨的证明如下: 不向右倒带来的缺憾(数量 $- 1$)至多被后面的树左倒补足, 所以我们这时选择右倒已经是最优解. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; tree(n + 1, vector\u0026lt;long long\u0026gt;(2, 0)); for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;tree[i][0]\u0026gt;\u0026gt;tree[i][1]; } tree[n][0] = 1000000000 * 2 + 10; int ans = 1; for (int i = 1; i \u0026lt; n; i++) { if (tree[i][0] - tree[i - 1][0] \u0026gt; tree[i][1]) { ans++; } else if (tree[i + 1][0] - tree[i][0] \u0026gt; tree[i][1]) { ans++; tree[i][0] = tree[i][0] + tree[i][1]; } } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; return 0; } ","date":"23 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-545c-woodcutters/","section":"Posts","summary":"CodeForces-545C Woodcutters # 题目大意 # 输入正整数 $n$ 与形状为 $n × 2$ 的数组 $tree$ , 其中 $tree[i][0]$ 代表第 $i$ 棵树在数轴上的坐标, $tree[i][1]$ 代表第 $i$ 棵树的高度.","title":"CodeForces-545C Woodcutters"},{"content":"CodeForces-455A Boredom # 题目大意 # 输入正整数 $n$ 与长度为 $n$ 的数组 $a[n]$ , 可以执行如下操作: 从数组中删去 $a[i]$ , 同时删去所有等于 $a[i] + 1$ 或 $a[i] - 1$ 的数, 得到 $a[i]$ 分. 返回多次操作后得分的最大值.\nSolution 1 # 这道题与经典动态规划问题LeetCode-198 打家劫舍很相似. 注意到删除 $a[i]$ 仅会删除其自身, 而不会影响与其相等的元素, 故我们必然可以得到这些分数, 即值为 $k$ 的元素出现了 $cnt[k]$ 次, 在 $k$ 上我们至多可以得到 $k × cnt[k]$ 分, 把 $k × cnt[k]$ 看成 $k$ 的价值, 记 $nums[i]$ 为第 $i$ 个值(不妨把值按从小到大的顺序排列), $scores[i] = nums[i] × cnt[nums[i]]$ 为第 $i$ 个元素提供的得分, $dp[i]$ 为前 $i$ 个值能够取得的最大得分, 则有如下状态转移方程: $$ dp[i] = \\begin{cases} dp[i - 1] + scores[i],\\ if\\ nums[i] \\not =nums[i - 1] + 1\\ max(dp[i - 1], dp[i - 2] + scores[i]),\\ if\\ nums[i] =nums[i- 1] + 1 \\end{cases} $$ 假设共有 $m$ 个互异的元素, 所求最大得分即为 $dp[m - 1]$. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; int temp = 0; map\u0026lt;int, long long\u0026gt; nummap; // 记录值k出现的次数 for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;temp; nummap[temp]++; } vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; scores; // 存储值k提供的得分 auto it = nummap.begin(); while (it != nummap.end()) { vector\u0026lt;long long\u0026gt; tmpvec; tmpvec.push_back(it-\u0026gt;first); tmpvec.push_back(it-\u0026gt;first * it-\u0026gt;second); scores.push_back(tmpvec); it++; } int m = scores.size(); vector\u0026lt;long long\u0026gt; dp(m, 0); dp[0] = scores[0][1]; if (m == 1) { // m == 1特判 cout\u0026lt;\u0026lt;dp[0]\u0026lt;\u0026lt;endl; return 0; } dp[1] = (scores[1][0] == scores[0][0] + 1) ? max(dp[0], scores[1][1]): dp[0] + scores[1][1]; // dp[1] 单独处理 for (int i = 2; i \u0026lt; m; i++) { dp[i] = (scores[i][0] == scores[i - 1][0] + 1) ? max(dp[i - 2] + scores[i][1], dp[i - 1]): dp[i - 1] + scores[i][1]; } cout\u0026lt;\u0026lt;dp[m - 1]\u0026lt;\u0026lt;endl; return 0; } Solution 2 # 这道题计数/DP用桶排序更简单. 桶排序下DP不需要分类讨论, 另外一点可以优化的就是 $scores$ 数组本身就可以充当 $dp$ 数组. 代码如下:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;long long\u0026gt; scores(100001, 0); int temp = 0; for (int i = 0; i \u0026lt; n; i++) { cin\u0026gt;\u0026gt;temp; scores[temp] += temp; } for (int i = 2; i \u0026lt;= 100000; i++) { scores[i] = max(scores[i - 2] + scores[i], scores[i - 1]); } cout\u0026lt;\u0026lt;scores[100000]\u0026lt;\u0026lt;endl; return 0; } ","date":"22 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/codeforces/codeforces-455a-boredom/","section":"Posts","summary":"CodeForces-455A Boredom # 题目大意 # 输入正整数 $n$ 与长度为 $n$ 的数组 $a[n]$ , 可以执行如下操作: 从数组中删去 $a[i]$ , 同时删去所有等于 $a[i] + 1$ 或 $a[i] - 1$ 的数, 得到 $a[i]$ 分.","title":"CodeForces-455A Boredom"},{"content":"LeetCode-2304 网格中的最小路径代价 # Solution 1 # 本题和经典问题LeetCode-931 下降最小路径和很相似, 不同之处在于多出了节点路径的代价, 这一点不影响动态规划的思路. 记 $dp[i][j]$ 为 $(i, j)$ 出发到达最后一行的最小代价, 则有如下状态转移方程: $$ dp[i][j] = \\underset{0\\leq k\\leq n - 1}{min}(dp[i + 1][j] + grid[i][j] + moveCost[grid[i][j]][k]) $$ 最后 $\\underset{0\\leq j\\leq n - 1}{min}dp[0][j]$ 即为所求最小代价. 代码如下:\nclass Solution { public: int minPathCost(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; moveCost) { int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 1000000007)); for (int j = 0; j \u0026lt; n; j++) { dp[m - 1][j] = grid[m - 1][j]; } for (int i = m - 2; i \u0026gt;= 0; i--) { for (int j = 0; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; n; k++) { dp[i][j] = min(dp[i][j], dp[i + 1][k] + grid[i][j] + moveCost[grid[i][j]][k]); } } } int ans = dp[0][0]; for (int j = 1; j \u0026lt; n; j++) { ans = min(ans, dp[0][j]); } return ans; } }; ","date":"22 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2304-%E7%BD%91%E6%A0%BC%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%BB%A3%E4%BB%B7/","section":"Posts","summary":"LeetCode-2304 网格中的最小路径代价 # Solution 1 # 本题和经典问题LeetCode-931 下降最小路径和很相似, 不同之处在于多出了节点路径的代价, 这一点不影响动态规划的思路.","title":"LeetCode-2304 网格中的最小路径代价"},{"content":"LeetCode-2312 卖木头块 # Solution 1 # 对一个大木块, 我们可以选择纵向切割, 也可以选择横向切割, 其价值为小木块之和, 具有典型的动态规划的特点. 我们记 $dp[i][j]$ 为 $m×n$ 木块的最大价值, 穷举切割方式, 可以得到 $$ dp[i][j] = max(\\underset{1\\leq k\\leq i - 1}{max}(dp[i - k][j] + dp[k][j]), \\underset{1\\leq k\\leq j - 1}{max}(dp[i][j - k] + dp[i][k])), $$ 进一步注意到切割的对称性, 可以优化为 $$ dp[i][j] = max(\\underset{1\\leq k\\leq \\frac{i}{2}}{max}(dp[i - k][j] + dp[k][j]), \\underset{1\\leq k\\leq \\frac{j}{2}}{max}(dp[i][j - k] + dp[i][k])). $$ 最终 $dp[m][n]$ 即为我们想要的答案. 代码如下:\nclass Solution { public: long long sellingWood(int m, int n, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prices) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for (auto \u0026amp;price: prices) { dp[price[0]][price[1]] = price[2]; } for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { for (int k = 1; k \u0026lt;= i / 2; k++) { dp[i][j] = max(dp[i][j], dp[i - k][j] + dp[k][j]); } for (int k = 1; k \u0026lt;= j / 2; k++) { dp[i][j] = max(dp[i][j], dp[i][j - k] + dp[i][k]); } } } return dp[m][n]; } }; ","date":"22 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2312-%E5%8D%96%E6%9C%A8%E5%A4%B4%E5%9D%97/","section":"Posts","summary":"LeetCode-2312 卖木头块 # Solution 1 # 对一个大木块, 我们可以选择纵向切割, 也可以选择横向切割, 其价值为小木块之和, 具有典型的动态规划的特点.","title":"LeetCode-2312 卖木头块"},{"content":"LeetCode-2311 小于等于 K 的最长二进制子序列 # Solution 1 # 本题要求的子序列可以是不连续的, 同时允许前导 $0$ 的存在, 一个重要的性质就是对于某个合法子序列, 我们加上它前面的所有 $0$ 构成一个更优的合法子序列. 现在考虑怎么获得这个合法子序列, 首先由于前导 $0$ 的存在, 我们倾向于让这个子序列更加靠后, 这样前面的 $0$ 也会变多; 事实上, 这种想法是正确的. 在子序列的寻找过程中, $01$ 总是比 $10$ 好, 所以选择 $1$ 时也是右侧的 $1$ 更好. 我们考虑这样一种贪心的寻找方法: 从最右侧开始, 不断向左增加子序列的长度, 直到子序列超过 $k$ 为止. 对于这个子序列, 加上所有先导 $0$ 即为所求最长合法子序列. 代码如下:\nclass Solution { public: int longestSubsequence(string s, int k) { int ans = 0; int pow = 1; // 记录当前位上2的幂次 int n = s.size(); for (int i = n - 1; i \u0026gt;= 0; i--) { if (s[i] == \u0026#39;0\u0026#39; || pow \u0026lt;= k) { // 如果是0, 就选上, 如果是1, 那么不超过当前k也选上 k -= pow * (s[i] - \u0026#39;0\u0026#39;); // 更新k, 减去相当于求和, 不过这样能够避免long long问题, 在0过多时计算pow会出错 ans++; } if (pow \u0026lt;= k) { //更新幂次 pow *= 2; } } return ans; } }; ","date":"22 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2311-%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E5%BA%8F%E5%88%97/","section":"Posts","summary":"LeetCode-2311 小于等于 K 的最长二进制子序列 # Solution 1 # 本题要求的子序列可以是不连续的, 同时允许前导 $0$ 的存在, 一个重要的性质就是对于某个合法子序列, 我们加上它前面的所有 $0$ 构成一个更优的合法子序列.","title":"LeetCode-2311 小于等于 K 的最长二进制子序列"},{"content":"LeetCode-2310 个位数字为 K 的整数之和 # Solution 1 # 题目要求把 $num$ 拆分成尽可能少的个位为 $k$ 的数之和, 假设可以拆分为 $n$ 个数, 我们考虑最直接的约束 $k × i \\equiv num\\ mod\\ 10$ , 由于题意中多重集约束非常宽松(允许有重复值), 只要把 $num$ 与 $k × n$ 之差(很显然这是 $10$ 的倍数)加到集合中的某一个元素上即可, 这里有一个隐藏条件 $num \u0026gt;= k × n$ . 要求的 $num$ 为 $0$ 时最好单独处理. 代码如下:\nclass Solution { public: int minimumNumbers(int num, int k) { if (num == 0) { return 0; } for (int i = 1; i \u0026lt;= 10; i++) { if (k * i % 10 == num % 10 \u0026amp;\u0026amp; k * i \u0026lt;= num) { return i; } } return -1; } }; ","date":"20 June 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2310-%E4%B8%AA%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B8%BA-k-%E7%9A%84%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/","section":"Posts","summary":"LeetCode-2310 个位数字为 K 的整数之和 # Solution 1 # 题目要求把 $num$ 拆分成尽可能少的个位为 $k$ 的数之和, 假设可以拆分为 $n$ 个数, 我们考虑最直接的约束 $k × i \\equiv num\\ mod\\ 10$ , 由于题意中多重集约束非常宽松(允许有重复值), 只要把 $num$ 与 $k × n$ 之差(很显然这是 $10$ 的倍数)加到集合中的某一个元素上即可, 这里有一个隐藏条件 $num \u0026gt;= k × n$ .","title":"LeetCode-2310 个位数字为 K 的整数之和"},{"content":"LeetCode-2156 查找给定哈希值的子串 # Solution 1 # 构思非常好的一道题. 需要求出长度为 $k$ 字串的哈希值, 并选择第一个哈希值等于目标的字串, \u0026ldquo;第一个\u0026quot;很容易让人联想到从左向右维护一个长度为 $k$ 的窗口. 考虑窗口滑动的哈希值变化, 会发现这道题的棘手之处: 从左向右移动时, 哈希值需要除以 $p$ 再取模, 然而我们只能维护取模后的哈希值, 而 $p$ 与 $m$ 不一定互素, 即我们不一定能求得 $p$ 在模 $m$ 意义下的逆元, 因此这一想法很难实施. 这时不妨逆向思考一下: 除法难于进行, 有没有办法转化成乘法? 当然有! 从右向左滑动窗口即可. 想到这一点后面的代码就不难实现了. 这道题由于数据大小的原因需要频繁取模, 需要注意一下. 代码如下:\nclass Solution { public: string subStrHash(string s, int power, int modulo, int k, int hashValue) { // 只需要考虑power % modulo即可 power %= modulo; // 记录最靠左的合法字串头坐标 int pos = 0; // 当前窗口字串哈希值 long long now = 0; int n = s.size(); // 预处理power^i的值 vector\u0026lt;long long\u0026gt; expmod(k, 1); for (int i = 1; i \u0026lt; k; i++) { expmod[i] = expmod[i - 1] * power; expmod[i] %= modulo; } // 最右侧子串 for (int i = n - 1; i \u0026gt;= n - k; i--) { now += val(s[i]) * expmod[k + i - n]; now = now % modulo; } if (now == hashValue) { pos = n - k; } for (int i = n - 2; i \u0026gt;=k - 1; i--) { now -= val(s[i + 1]) * expmod[k - 1]; now %= modulo; now *= power; now += val(s[i - k + 1]); now %= modulo; // now取模后可能为负值, 加上modulo即可 if(now \u0026lt; 0) { now += modulo; } // 注意找到一个子串后不能立刻返回, 我们需要的是最左侧的 if (now == hashValue) { pos = i- k + 1; } } // 得出答案 return s.substr(pos, k); } int val(char c) { return c - \u0026#39;a\u0026#39; + 1; } }; ","date":"17 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2156-%E6%9F%A5%E6%89%BE%E7%BB%99%E5%AE%9A%E5%93%88%E5%B8%8C%E5%80%BC%E7%9A%84%E5%AD%90%E4%B8%B2/","section":"Posts","summary":"LeetCode-2156 查找给定哈希值的子串 # Solution 1 # 构思非常好的一道题.","title":"LeetCode-2156 查找给定哈希值的子串"},{"content":"","date":null,"permalink":"/tags/%E6%9C%BA%E5%99%A8%E7%BE%8E%E5%AD%A6/","section":"Tags","summary":"","title":"机器美学"},{"content":"","date":null,"permalink":"/tags/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89/","section":"Tags","summary":"","title":"现代主义"},{"content":" \u0026lt;中外艺术史\u0026gt;课程以及自己看的一些资料的笔记, 没有条理是正常的.\n现代主义简介 # 工业革命带来了科技, 文化及社会上的剧变: 现代工业的兴起, 资本主义的扩张, 异化了人与人之间的关系, 社会变成了一种异己的力量. 这促使西方文明重新思考\u0026quot;人\u0026quot;. 现代主义推崇简约: \u0026ldquo;Less is more\u0026rdquo;.\n现代主义大师: 勒·柯布西耶 # 勒·柯布西耶是二十世纪最为著名的建筑大师之一, 被称作\u0026quot;功能主义之父\u0026quot;, 同时也是\u0026quot;机械美学\u0026quot;的重要奠基人. 作为现代建筑运动的激进分子和主将，同时也是现代主义建筑的主要倡导者, 柯布西耶也被称作\u0026quot;现代建筑的旗手\u0026quot;. 重要著作: \u0026lt;走向一种建筑\u0026gt;(亦被译作\u0026lt;走向新建筑\u0026gt;) 拒绝装饰, 歌颂机器之美, 将功能主义的设计观念提升到了美学的地步. 推崇工程制造的美学: 工程师与工人推敲比例, 形体与材料, 让工业造物成为了艺术品. 柯布西耶所说的成为艺术品的机器, 首先是指飞机, 轮船和汽车.这些机器未经艺术家的装饰, 未经古代风格的点缀, 反倒具有一种更和谐而扣人心弦的美. 现代科技衍生出的形式简洁, 结构严谨的机器, 而非复古的\u0026quot;装饰风\u0026quot;.\n城市化与工人问题 # 资本主义下经济迅速发展, 工业化, 城市化使得工厂聚集了一大批工人劳动力, 但他们的住宅条件却很难得到满足. 建筑还是革命? 柯布西耶提出的解决办法: 批量制造房屋 (现代主义的崇高性: 把艺术落实到对伦理的关切上) 1947-1952 马赛公寓 1957 柏林公寓 两座整齐而美观的建筑恰如柯布西耶所说: \u0026ldquo;住宅是居住的机器\u0026rdquo;. 机器经由人的意志被操纵, 住宅则同样应服务于人的居住体验与需求, 人本情怀是柯布西耶设计理念中重要的一环, 与建筑冰冷的外表反差甚大. 对时代的反思, 对人伦的重视, 是现代主义者的崇高之处.\n后现代主义 # 对欧洲传统现代主义的不满, 催生出后现代主义. 相较于现代主义的\u0026quot;Less is more\u0026quot;, 后现代主义的\u0026quot;Less is boring\u0026quot;充满了挑衅. 如果说现代主义是对令人失望的现实的怀疑与反思, 后现代主义是沉思许久后无所顾忌的疯癫. 莫瑞吉奥·卡特兰的著名作品 \u0026lt;喜剧演员\u0026gt;: 包豪斯 # 包豪斯学院由格罗皮乌斯创办. Bauhaus, 德语的\u0026quot;造房子\u0026quot;: 不是为了有钱人与资本家造房子, 而是为了平民, 为了无产阶级造房子. 理念原因, 不受右派待见 主要经历三个阶段: 魏玛时期, 德绍时期, 柏林时期. 包豪斯风格认为: 形式应该由功能决定. 现代主义的高光时刻: 包豪斯校舍 夹带私货: 泰州中学 # 刚考进泰州中学, 去看新校区的时候, 我就觉得非常简约而优雅. 高二选修艺术课程, 那个讲色彩的美术老师谈到新校区, 用\u0026quot;监狱\u0026quot;二字给它的设计打了零分. 高中的我仅能同意\u0026quot;监狱\u0026quot;这一形容, 但设计还是相当不错的. 附一些母校的图片, 我认为这种风格一定程度上借鉴了包豪斯风格. ","date":"16 May 2022","permalink":"/posts/%E9%9A%8F%E7%AC%94/%E7%8E%B0%E4%BB%A3%E4%B8%BB%E4%B9%89/","section":"Posts","summary":"\u0026lt;中外艺术史\u0026gt;课程以及自己看的一些资料的笔记, 没有条理是正常的.","title":"现代主义的一些笔记"},{"content":"LeetCode-1105 填充书架 # Solution 1 # 动态规划问题. 记 $dp[i]$ 为前 $i$ 本书的最小书架高度, 思考状态转移方程. 对于新加入的一本书 $i$, 假设有 $i - j$ 本书和 $i$ 在同一层, 则这一层高度为 $max(books[k][1]), i - j\\leq k \\leq i$ , 同时其余层数高度为 $dp[j]$. 对于每个 $i \\geq 1$ 我们遍历 $j = i - 1,\u0026hellip;,0$ 计算得到最小的 $dp[i]$ , 同时用两个变量 $nowHeight$ 和 $nowWidth$ 维护该层最大高度与剩余宽度. 代码如下:\nclass Solution { public: int minHeightShelves(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; books, int shelfWidth) { int n = books.size(); vector\u0026lt;int\u0026gt; dp(n + 1, 1000000009); dp[0] = 0; for (int i = 1; i \u0026lt;= n; i++) { int nowWidth = shelfWidth; int nowHeight = 0; for (int j = i - 1; j \u0026gt;= 0; j--) { nowWidth -= books[j][0]; nowHeight = max(nowHeight, books[j][1]); if (nowWidth \u0026gt;= 0) { dp[i] = min(dp[i], dp[j] + nowHeight); } else { break; } } } return dp[n]; } }; ","date":"15 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1105-%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6/","section":"Posts","summary":"LeetCode-1105 填充书架 # Solution 1 # 动态规划问题.","title":"LeetCode-1105 填充书架"},{"content":"LeetCode-56 合并区间 # Solution 1 # 给定一组区间, 要求合并区间, 首先对区间按照起始端点进行排序. 考虑什么样的区间需要合并, 可以发现当区间右端点大于下一个区间左端点时, 需要进行区间合并, 我们把下一个区间改写成合并后的区间. 合并时需要注意合并区间的左端点总是当前区间的左端点, 而右端点是两个区间的最大值. 注意这种做法当最后一个端点单独向后合并时需要另外处理. 代码如下:\nclass Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { sort(intervals.begin(), intervals.end()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge; int p = 0; while (p \u0026lt; intervals.size() - 1) { while (p \u0026lt; intervals.size() - 1 \u0026amp;\u0026amp; intervals[p][1] \u0026gt;= intervals[p + 1][0]) { intervals[p + 1][0] = intervals[p][0]; intervals[p + 1][1] = max(intervals[p + 1][1], intervals[p][1]); p++; } merge.push_back(intervals[p]); p++; } if (merge.size() == 0) { merge.push_back(intervals.back()); } if (merge.back() != intervals.back()) { merge.push_back(intervals.back()); } return merge; } }; ","date":"15 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","section":"Posts","summary":"LeetCode-56 合并区间 # Solution 1 # 给定一组区间, 要求合并区间, 首先对区间按照起始端点进行排序.","title":"LeetCode-56 合并区间"},{"content":"","date":null,"permalink":"/tags/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/","section":"Tags","summary":"","title":"区间合并"},{"content":"LeetCode-691 贴纸拼词 # Solution 1 # 这道题要用给定的字符串中的字符来拼出目标字符串, 其中给定字符串中每一个都可以使用无数次. 由题意, 对于每个字符串, 我们可以使用一个数组记录其可以提供的字符种类及个数. 首先思考贪心做法是否可以, 但没能找到解决办法. 再考虑动态规划, 对于一个给定的字符串, 其所需步骤为 $min(f(sticker) + 1), for\\ each\\ sticker\\ in\\ stickers[]$ .那么怎样记录状态呢? 一个办法是用 $1$ 表示当前字符已经处理完, $0$ 表示当前字符需要被处理, 这样我们就可以用 $0,1,\u0026hellip;,2^n-1$ 来表示字符串拼接过程中所有可能的状态. 由于拼接过程的特性, 我们倾向于使用自顶向下递归的做法来处理状态转移, 通过记忆化搜索避免重复运算, 这一递归过程本质上是广度优先搜索. 代码如下:\nclass Solution { public: int minStickers(vector\u0026lt;string\u0026gt;\u0026amp; stickers, string target) { int n = target.size(); vector\u0026lt;int\u0026gt;dp(1 \u0026lt;\u0026lt; n, -1); // 赋值, 未被处理的为-1 dp[0] = 0; int ans = recursive(dp, stickers, (1 \u0026lt;\u0026lt; n) - 1, target); return ans \u0026gt; n ? -1: ans; // 如果ans\u0026gt;n说明没有可行方案, 返回-1 } // 记忆化搜索, 注意数组dp要引用, 否则值不会传回去 int recursive(vector\u0026lt;int\u0026gt;\u0026amp; dp, vector\u0026lt;string\u0026gt;\u0026amp; stickers, int mask, string target) { // 记忆化搜索, 如果之前搜索到这一步了, 直接返回答案即可 // 这一情况也包含了边界情况dp[0], 我们在调用递归函数之前已经给dp[0]赋值为0了 if (dp[mask] != -1) { return dp[mask]; } dp[mask] = target.size() + 1; // mask如果可以处理完, 那么至多target.size()步可以处理完 for (string sticker: stickers) { int left = mask; // left记录当前sticker处理完后剩余的状态 vector\u0026lt;int\u0026gt; cnt(26, 0); // 记录可用字符 for (char c: sticker) { cnt[c - \u0026#39;a\u0026#39;]++; } for (int i = 0; i \u0026lt; target.size(); i++) { // mask对应的字符串如果未被处理, 且我们有剩余字符可以处理它, 就进行处理. if ((mask \u0026gt;\u0026gt; i \u0026amp; 1) \u0026amp;\u0026amp; cnt[target[i] - \u0026#39;a\u0026#39;] \u0026gt; 0) { left = left ^ (1 \u0026lt;\u0026lt; i); // left二进制下对应位归0 cnt[target[i] - \u0026#39;a\u0026#39;]--; // 可用字符减少 } } // 处理后的left必须比mask小 if (left \u0026lt; mask) { dp[mask] = min(dp[mask], recursive(dp, stickers, left, target) + 1); // 状态转移方程 } } return dp[mask]; } }; ","date":"14 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-691-%E8%B4%B4%E7%BA%B8%E6%8B%BC%E8%AF%8D/","section":"Posts","summary":"LeetCode-691 贴纸拼词 # Solution 1 # 这道题要用给定的字符串中的字符来拼出目标字符串, 其中给定字符串中每一个都可以使用无数次.","title":"LeetCode-691 贴纸拼词"},{"content":"LeetCode-2167 移除所有载有违禁货物车厢所需的最少时间 # Solution 1 # 很有趣的一道动态规划题. 需要移除字符串中的所有 $\u0026lsquo;1\u0026rsquo;$ , 由于移除操作的对称性, 在思考状态转移方程时, 我们不妨也从两个方向思考. 考虑字符串中的一个下标 $i$ , 要移除字符串中所有的 $\u0026lsquo;1\u0026rsquo;$ , 需要我们移除 $i$ 左侧的所有 $\u0026lsquo;1\u0026rsquo;$ 与 $i$ 右侧的所有 $\u0026lsquo;1\u0026rsquo;$ , 因此我们考虑这样的状态量: $left[i], right[i]$ 分别表示移除 $[0, i]$ 和 $[i, n - 1]$ 所需的最少步骤. 很明显最终答案等于 $min(left[i] + right[i + 1]), i=0, 1,\u0026hellip;,n - 1$ (注意不要越界, 记 $right[n] = 0$). 接下来考虑状态转移方程. 当 $s[i] == \u0026lsquo;0\u0026rsquo;$, 有 $left[i] = left[i-1]$. 当 $s[i] == \u0026lsquo;1\u0026rsquo;$ 时, 我们有两种移除策略, 移除左侧所有 $\u0026lsquo;1\u0026rsquo;$ ,再单独移除 $s[i]$, 或者直接把前 $i + 1$ 个字符全部移除, 故有状态转移方程 $left[i] = min(left[i - 1] + 2, i + 1)$. 对于 $right$ 的处理类似. 代码如下:\nclass Solution { public: int minimumTime(string s) { int n = s.size(); vector\u0026lt;int\u0026gt; left(n + 1, 0); vector\u0026lt;int\u0026gt; right(n + 1, 0); if (s[0] == \u0026#39;1\u0026#39;) { left[0] = 1; } for (int i = 1; i \u0026lt; n; i++) { if (s[i] == \u0026#39;0\u0026#39;) { left[i] = left[i - 1]; } else { left[i] = min(left[i - 1] + 2, i + 1); } } if (s[n - 1] == \u0026#39;1\u0026#39;) { right[n - 1] = 1; } for (int i = n - 2; i \u0026gt;= 0; i--) { if (s[i] == \u0026#39;0\u0026#39;) { right[i] = right[i + 1]; } else { right[i] = min(right[i + 1] + 2, n - i); } } int ans = 1919810; for (int i = 0; i \u0026lt; n; i++) { ans = min(ans, left[i] + right[i + 1]); } return ans; } }; ","date":"13 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2167-%E7%A7%BB%E9%99%A4%E6%89%80%E6%9C%89%E8%BD%BD%E6%9C%89%E8%BF%9D%E7%A6%81%E8%B4%A7%E7%89%A9%E8%BD%A6%E5%8E%A2%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4/","section":"Posts","summary":"LeetCode-2167 移除所有载有违禁货物车厢所需的最少时间 # Solution 1 # 很有趣的一道动态规划题.","title":"LeetCode-2167 移除所有载有违禁货物车厢所需的最少时间"},{"content":"LeetCode-2178 拆分成最多数目的正偶数之和 # Solution 1 # 题目要求把一个数拆分成互不相等的偶数之和, 并且要求给出一个元素个数最多的构造. 首先, 奇数必定不存在这样的拆分. 考虑偶数的情况, 自己试验几个数之后很容易发现一个贪心的构造方法(证明不难): 把$N$拆分成 $2, 4,\u0026hellip;,2 k$ 与一个无法再分的 $M$ .接下来考虑约束关系. 因为 $M$ 不能继续分割, 可以得到 $2k + 2 \\leq M \u0026lt; (2k + 2) + (2k + 4) = 4k + 6$ , 再由 $M$ 是偶数可以得到 $2k + 2\\leq M \\leq 4k + 4$, 再由和的关系, 有 $k^2 + 5 k + 4 \\geq N \\geq k^2 + 3k + 2$ . 需要求出满足这一式子的最大 $k$ . 事实上, 对于一个给定的 $N$, 满足这一式子的 $k$ 只有一个. 我们可以从两个角度证明这个结论: 一方面, 我们可以考虑如果 $k+1$ 也满足这个式子, 那么把数列 $2,4,\u0026hellip;,2k,2k+2$ 最后一项 $2k + 2$加到 $M\u0026rsquo;$ 上, 就所得的等于 $k$ 构造中的 $M$ , 这与 $M$ 不可分矛盾. 另一方面, 我们可以证明区间 $[ k^2 + 3k + 2, k^2 + 5 k + 4]$ 两两不重合, 最多有一个区间框住 $N$. 综上求出一个 $k$ 即可. 这里我们考虑 $k^2 + 5 k + 4 \\geq N$ , 求解其左边界, 由单调性质可以考虑使用二分搜索. 实战中有一些细节需要注意:\n由于$long\\ long$ 相乘会越界, 判断 $k^2 + 5 k + 4 \\geq N$ 时需要作除法, 这时候需要考虑整型除法去尾的性质, 分 $N \\equiv 0 \\ mod\\ k$ 与 $N \\not\\equiv 0 \\ mod\\ k$ 讨论. 由于使用了除法, 二分搜索时对 $mid$ 是否为 $0$ 需要讨论, 我这里直接把 $N$ 较小时 $mid$ 可能为 $0$ 的情况单独讨论了. 结果返回 $long\\ long$ 的时候, 涉及结果运算的地方全部要使用 $long\\ long$, 不然很可能越界. 代码如下: class Solution { public: vector\u0026lt;long long\u0026gt; maximumEvenSplit(long long finalSum) { vector\u0026lt;long long\u0026gt;ans; if (finalSum % 2 == 1) { return ans; } // mid可能为0 if (finalSum == 2) { ans.push_back(2); return ans; } // mid可能为0 if (finalSum == 4) { ans.push_back(4); return ans; } // 记得开long long long long left = 1; long long right = finalSum - 5; // 二分搜索左边界 while (left \u0026lt; right) { long long mid = left + (right - left) / 2; if (isOver(mid, finalSum)) { right = mid; } else { left = mid + 1; } } for (long long i = 1; i \u0026lt;= left; i++) { ans.push_back(2 * i); finalSum -= 2 * i; } ans.push_back(finalSum); return ans; } // 记得开long long bool isOver(long long mid, long long finalSum) { if ((finalSum - 4) % mid == 0) { return (mid + 5) \u0026gt;= (finalSum - 4) / mid; } else { return (mid + 4) \u0026gt;= (finalSum - 4) / mid; } } }; Solution 2 # 上面是我自己的解法, 构造和论证有点啰嗦, 以下是更为简洁的官方做法: 我们考虑一种构造方式: 从 $N$ 上逐步拆出当前最小的正偶数, 直到剩余数值不大于当前被拆分的最大偶数, 这时把剩余数值加到这个最大的偶数上. 假设我们利用这种拆分方式把 $N$ 拆分成了 $k$ 个正偶数, 则可以计算出 $N$ 的上下界: $k^2 + k = \\sum_{i = 1}^k 2i \\leq N \\leq \\sum_{i = 1}^{k} 2i + 2k = k^2 + 3k$, 现在假设 $N$ 能够被拆分成 $k + 1$ 个正整数, 则必定有 $N \\geq \\sum_{i = 1}^{k + 1}2i = k^2 + 3k + 2$, 这与前面推导出的结论矛盾, 故 $k$ 就是所能拆分 出的最大个数. 代码如下:\nclass Solution { public: vector\u0026lt;long long\u0026gt; maximumEvenSplit(long long finalSum) { if (finalSum % 2) { return {}; } vector\u0026lt;long long\u0026gt; res = {2}; finalSum -= 2; while (res.back() \u0026lt; finalSum) { finalSum -= res.back() + 2; res.push_back(res.back() + 2); } res.back() += finalSum; return res; } }; 不得不感叹一句, 与我的解答相比, 官方的思路更清晰, 构造更加直白. 下次用贪心写题目时, 还是从贪心的角度出发比较好, 能少绕就少绕.\n","date":"9 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2178-%E6%8B%86%E5%88%86%E6%88%90%E6%9C%80%E5%A4%9A%E6%95%B0%E7%9B%AE%E7%9A%84%E6%AD%A3%E5%81%B6%E6%95%B0%E4%B9%8B%E5%92%8C/","section":"Posts","summary":"LeetCode-2178 拆分成最多数目的正偶数之和 # Solution 1 # 题目要求把一个数拆分成互不相等的偶数之和, 并且要求给出一个元素个数最多的构造.","title":"LeetCode-2178 拆分成最多数目的正偶数之和"},{"content":"LeetCode-456 132 模式 # 这道题运用单调栈的解法过于精妙, 特此记录.\nSolution 1 # 对于三元组 $(i,j,k)$ , 我们考虑枚举 $i$ , 怎么维护 $(j, k)$ 使得 $nums[j] \u0026gt; nums[k]$ 呢? 答案是单调栈. 将 $i$ 右侧第一个数据入栈, 之后遇到比栈顶小的数据就入栈, 否则出栈, 用 $maxk$ 表示出栈元素的最大值, 假如有 $maxk \u0026gt; nums[i]$ , 则必有合法的三元组 $(i,j,k)$ , 这是因为 $maxk$ 出栈是因为有一个更大元素要入栈使得单调减序列不再成立, 这个序列的下标就是我们要找的 $j$ , 而 $maxN$ 的下标就是我们要找的 $k$ . 代码如下 (来自LeetCode用户宫水三叶的题解):\nclass Solution { public: bool find132pattern(vector\u0026lt;int\u0026gt;\u0026amp; nums) { stack\u0026lt;int\u0026gt; st; int n = nums.size(), k = INT_MIN; for(int i = n - 1; i \u0026gt;= 0; i--){ if(nums[i] \u0026lt; k) return true; while(!st.empty() and st.top() \u0026lt; nums[i]) { k = max(k,st.top()); st.pop(); } st.push(nums[i]); } return false; } }; ","date":"9 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-456-132-%E6%A8%A1%E5%BC%8F/","section":"Posts","summary":"LeetCode-456 132 模式 # 这道题运用单调栈的解法过于精妙, 特此记录.","title":"LeetCode-456 132 模式"},{"content":"LeetCode-2183 统计可以被 K 整除的下标对数目 # Solution 1 # 计数问题, 思路要清晰. 我们思考怎样的 $x,y$ 满足乘积是 $k$ 的倍数? 或者说, 对于一个给定的 $x$ , 什么样的 $y$ 能够保证两数之积为 $k$ 的倍数? 我们只管心共同因子的部分, $gcd(x, k)$ 是 $k$ 中 $x$ 所提供的部分, 从这方面考虑, 我们需要 $y$ 来提供 $k / gcd(x, k)$ 的那部分, 因此应当有 $y = m * k / gcd(x, k)$. 怎样进行相对快速的统计呢? 对每个 $k / gcd(x, k)$, 我们需要知道其倍数在数组中出现了多少次, 因此我们先统计数组中各个数的分布情况, 再来统计每个数的倍数在数组中出现了多少次. 需要注意的是, 这种统计方法会把 $(i, j)(i \\neq j)$ 计算两次, 把 $(i, i)$ 计算一次. 对于初步计算出的答案, 我们需要统计后一种情况的个数, 减去后再除以二得到最终结果. 代码如下:\nclass Solution { public: long long countPairs(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int maxN = k; for (int num: nums) { maxN = max(maxN, num); } vector\u0026lt;int\u0026gt; cnt(maxN + 1, 0); for (int num: nums) { cnt[num]++; } for (int i = 1; i \u0026lt;= maxN; i++) { for (int j = 2 * i; j \u0026lt;= maxN; j += i) { cnt[i] += cnt[j]; } } long long ans = 0; for (int num: nums) { ans += cnt[k / __gcd(num, k)]; if ((long long)(num) * (long long)(num) % k == 0) { ans--; } } return ans / 2; } }; ","date":"9 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2183-%E7%BB%9F%E8%AE%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB-k-%E6%95%B4%E9%99%A4%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2183 统计可以被 K 整除的下标对数目 # Solution 1 # 计数问题, 思路要清晰.","title":"LeetCode-2183 统计可以被 K 整除的下标对数目"},{"content":"LeetCode-2267 检查是否有合法括号字符串路径 # LeetCode周赛292T4, 考试时写了个深搜果然超时了\u0026hellip; 深搜最好配合记忆化搜索, 转化成动态规划更好处理一点.\nSolution 1 # 首先注意到括号匹配问题相当于任何时候路径上的\u0026quot;(\u0026ldquo;都不能少于\u0026rdquo;)\u0026quot;, 如何设计一个便于转移的状态? 从路径上的\u0026quot;(\u0026ldquo;与\u0026rdquo;)\u0026ldquo;差的个数不能为负数入手, 我们建立一个 $bool$ 数组 $dp[m][n][k]$ , 表示终点为 $i, j$ 且值为 $k$ 的路径是否存在. 考虑 $dp[m][n][k]$ 的值, 只需要观察这一格点的括号情况就可以结合已求出的 $dp$ 计算. 代码如下:\nclass Solution { public: bool hasValidPath(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); // 一个简单的剪枝 if ((m + n) % 2 == 0) { return false; } // 不需要返回路径个数, 我们建立bool数组就好, 如果要路径个数记得开long long bool dp[110][110][1010]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; m + n; k++) { dp[i][j][k] = false; } } } if (grid[0][0] == \u0026#39;(\u0026#39;) { dp[0][0][1] = true; } // 处理第0行 for (int j = 1; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; m + n; k++) { if (grid[0][j] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; k != 0) { dp[0][j][k] = dp[0][j - 1][k - 1]; } else if (grid[0][j] == \u0026#39;)\u0026#39;){ dp[0][j][k] = dp[0][j - 1][k + 1]; } } } // 处理第0列 for (int i = 1; i \u0026lt; m; i++) { for (int k = 0; k \u0026lt; m + n; k++) { if (grid[i][0] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; k != 0) { dp[i][0][k] = dp[i - 1][0][k - 1]; } else if (grid[i][0] == \u0026#39;)\u0026#39;) { dp[i][0][k] = dp[i - 1][0][k + 1]; } } } // 处理其他的格子 for (int i = 1; i \u0026lt; m; i++) { for (int j = 1; j \u0026lt; n; j++) { for (int k = 0; k \u0026lt; n; k++) { if (grid[i][j] == \u0026#39;(\u0026#39; \u0026amp;\u0026amp; k != 0) { dp[i][j][k] = dp[i - 1][j][k - 1] + dp[i][j - 1][k - 1]; } else if (grid[i][j] == \u0026#39;)\u0026#39;){ dp[i][j][k] = dp[i - 1][j][k + 1] + dp[i][j - 1][k + 1]; } } } } return dp[m - 1][n - 1][0]; } }; ","date":"8 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2267-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E5%90%88%E6%B3%95%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B7%AF%E5%BE%84/","section":"Posts","summary":"LeetCode-2267 检查是否有合法括号字符串路径 # LeetCode周赛292T4, 考试时写了个深搜果然超时了\u0026hellip; 深搜最好配合记忆化搜索, 转化成动态规划更好处理一点.","title":"LeetCode-2267 检查是否有合法括号字符串路径"},{"content":"","date":null,"permalink":"/tags/%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"路径搜索"},{"content":"动态规划的套路: 从入门到精通到弃坑 # 本文是视频残酷刷题群算法小讲座：动态规划的套路的学习笔记.\n动态规划的思考艺术 # 暴力枚举为什么不优秀? # 大量的重复计算 需要具体的路径 动态规划对比暴搜的优点? # 只关心状态, 也就是路径的数目 利用子问题向上求解 舍弃了冗余信息(路径的具体实现), 只关心状态的变化 动态规划适用的场景? # 能将问题拆分为子问题, 同时具有两大特点:\n无后效性 # 一旦状态确定, 就不用关心\u0026quot;如何计算出状态\u0026quot;; 想要确定一个状态, 只需要知道某些过去的状态; 至于过去的状态是怎么计算出的, 对问题没有任何影响. 最优子结构 # 定义状态时已经蕴含了\u0026quot;最优\u0026quot;; 大问题的最优解可以由小问题的最优解推导出. 动态规划的常见套路 # 第Ⅰ类基本型 时间序列 # 特点 # 给出一个序列(数组/字符串), 其中每一个元素可以认为是\u0026quot;一天\u0026quot;, 并且\u0026quot;今天\u0026quot;的状态只取决于\u0026quot;昨天\u0026quot;的状态.\n解法 # 定义 $dp[i]$ , 表示第 $i$ 轮的状态; 设法将 $dp[i]$ 与 $dp[i - 1]$ 产生联系; 最终结果为 $dp[last][j]$ 中的某种最优值. 例题 # LeetCode-198 打家劫舍 LeetCode-213 打家劫舍 II LeetCode-123 买卖股票的最佳时机 III LeetCode-309 最佳买卖股票时机含冷冻期 LeetCode-376 摆动序列 注: 不知道题目有没有修改过, 依据2022-05-06的题意, 视频中给出的状态转移方程的说明是错误的, 这道题严格来说不属于时间序列型这一分类, 我会专门用一篇文章分析这道真正的状态转移方程. LeetCode-276 栅栏涂色 注: 这道题是会员题, 与 LeetCode-1289类似. LeetCode-1289 下降路径最小和 II LeetCode-487 最大连续1的个数 II 注: 这道题是会员题. LeetCode-1186 删除一次得到子数组最大和\n思考题 # 给 $N$ 个房子, 涂白色和涂黑色的花费分别是 $a$ 和 $b$ , 要求不能有连续三间房子涂同一种颜色, 求喷涂所有房子的最小价格.\n第一眼看上去不是前面同类型的时间序列型问题(涉及前两个时间点的状态), 但是我们可以这样设定状态: 结尾有连续 $1$ 间为黑色, 结尾有连续 $2$ 间为黑色, 结尾有连续 $1$ 间为白色, 结尾有连续 $2$ 间为白色. 这样就可以像之前那样推导了. (注意状态必须是互斥且包含所有情况的.) 状态转移方程如下:\ndp[i][0] = min(dp[i - 1][2], dp[i - 1][3]) + blackCost; dp[i][1] = dp[i - 1][1] + blackCost; dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + whiteCost; dp[i][3] = dp[i - 1][2] + whiteCost; 第Ⅱ类基本型 时间序列加强版 # 特点 # 给出一个序列(数组/字符串), 其中每一个元素可以认为是\u0026quot;一天\u0026quot;, 但\u0026quot;今天\u0026quot;的状态和之前\u0026quot;某一天\u0026quot;有关, 需要挑选.\n解法 # 定义 $dp[i]$ , 表示第 $i$ 轮的状态; 一般这个状态要求与元素 $i$ 直接有关. 设法将 $dp[i]$ 与 $dp[i\u0026rsquo;]$ 产生联系; $i\u0026rsquo;$ 要求小于 $i$ (否则违反了无后效性). 最终结果为 $dp[i]$ 中的某一个. 例题 # LeetCode-300 最长递增子序列 LeetCode-673 最长递增子序列的个数 LeetCode-368 最大整除子集 LeetCode-1105 填充书架\n","date":"6 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%A5%97%E8%B7%AF_%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%E5%88%B0%E5%BC%83%E5%9D%91/","section":"Posts","summary":"动态规划的套路: 从入门到精通到弃坑 # 本文是视频残酷刷题群算法小讲座：动态规划的套路的学习笔记.","title":"动态规划的套路: 从入门到精通到弃坑(未完成)"},{"content":"LeetCode-376 摆动序列 # 直入主题, 这道题可以用动态规划解决, 不过这次我们先看代码, 再来思考状态转移方程的意义.\nSolution 1 # class Solution { public: int wiggleMaxLength(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int len = nums.size(); int dp[1001][2]; dp[0][0] = 1; dp[0][1] = 1; for (int i = 1; i \u0026lt; len; i++) { if (nums[i] \u0026gt; nums[i - 1]) { dp[i][0] = max(dp[i - 1][1] + 1, dp[i - 1][0]); dp[i][1] = dp[i - 1][1]; } else if (nums[i] \u0026lt; nums[i - 1]) { dp[i][0] = dp[i - 1][0]; dp[i][1] = max(dp[i - 1][0] + 1, dp[i - 1][1]); } else { dp[i][0] = dp[i - 1][0]; dp[i][1] = dp[i - 1][1]; } } return max(dp[len - 1][0], dp[len - 1][1]); } }; 一个直觉是 $dp[i][0]$ 代表了以 $nums[i]$ 为结尾的最长上升摆动序列长度, $dp[i][1]$ 代表了以 $nums[i]$ 为结尾的最长下降摆动序列长度, 然后考虑状态转移方程. 这种一种典型的错误, 原题意义下的 $dp[i][0]$ 未必由 $dp[i - 1][0]$ 直接\u0026quot;接上\u0026quot; $nums[i]$ 得来. 事实上, 这种推导方式适用于连续子序列问题, 很可惜这一题并不是这样的, $dp[i][0]$ 的倒数第二位未必是 $nums[i - 1]$. 让我们重新思考 $dp[i][j]$ 数组的含义, 下面我们以 $dp[i][0]$ 为例( $j = 1$ 时完全对称): 首先, 我们认识到一开始的意义设定是不便于推导状态转移方程的. 考虑把 $dp[i][0]$ 的意义修改为\u0026quot;以$nums[0],\u0026hellip;,nums[i]$中某一元素为结尾的最长上升摆动序列长度\u0026quot; . 那么状态 $dp[i][0]$ 与 $dp[i- 1][0]$ 之间可能的变化因素就是以 $nums[i]$ 为结尾的上升子序列. 接下来让我们来推导状态转移方程. 如果 $nums[i] \\leq nums[i - 1]$, 考虑变化因素, 对于任何一个 $nums[i]$ 结尾的上升序列, 把 $nums[i]$ 替换成 $nums[i - 1]$ 同样是一个上升序列, 而这部分已经囊括在 $dp[i - 1][0]$ 中了, 故有 $dp[i][0] = dp[i - 1][0]$ ; 再考虑 $nums[i] \u0026gt; nums[i - 1]$ , 一方面, $dp[i][0]$ 可能与 $dp[i - 1][0]$相等; 另一方面, 考虑变化因素, 我们需要寻找 $dp[i - 1][1]$ 接上 $nums[i]$ 后带来的可能性, 接下来我们需要考虑的问题是, 是否一定存在这样的最长下降子序列, 其末尾值小于 $nums[i]$ (只有这样, 才能把 $nums[i]$ 接上)? 答案是肯定的. 我们假定对于 $dp[i - 1][1]$ 意义下的每一个最长下降子序列都满足末尾值(不妨记作 $nums[j]$ )都 $\\geq$ $nums[i]$ , 自然有 $nums[j] \u0026gt; nums[i - 1]$ , 这时我们把 $nums[j]$ 用 $nums[i - 1]$ 替换, 就得到了一个同样长的下降子序列, 这个子序列却不符合假设(因为有 $nums[i] \u0026gt; nums[i - 1]$ ), 故假设不成立, 即必能找到一个长度为 $dp[i - 1][1]$ 的下降子序列, 后面能接上 $nums[i]$ 成为一个长度为 $dp[i - 1][1] + 1$ 的上升子序列. 这一情况对应的状态转移方程为 $dp[i][1] = max(dp[i - 1][0] + 1, dp[i - 1][1])$ . 这样我们就圆满地解决这道题了.\n","date":"6 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/","section":"Posts","summary":"LeetCode-376 摆动序列 # 直入主题, 这道题可以用动态规划解决, 不过这次我们先看代码, 再来思考状态转移方程的意义.","title":"LeetCode-376 摆动序列"},{"content":"LeetCode-76 最小覆盖子串 # 参考文章: 我写了首诗，把滑动窗口算法算法变成了默写题 Solution 1 # 本题可以说是滑动窗口的代表了. 根据需求, 我们需要寻找包含目标字符串中所有字符的一个连续字串, 考虑利用哈希表存储目标与当前子串. 一个需要注意的点是对于当前子串也只需要考虑目标中含有的字符. 对于滑动窗口, 一共分为四步, 扩大窗口, 更新数据\u0026amp;判断,, 缩小窗口, 更新数据\u0026amp;判断, 本质上是一个寻找可行解、优化可行解的过程. 代码如下:\nclass Solution { public: string minWindow(string s, string t) { unordered_map\u0026lt;char, int\u0026gt; need, window; for (char c: t) { need[c]++; } // 左闭右开,[left, right) int right = 0; int left = 0; // valid记录当前窗口与目标的匹配的字符种类数 int valid = 0; // 记录答案的左右端点 int start = 0, len = INT_MAX; // 开始滑动 while (right \u0026lt; s.size()) { // 扩大窗口 char c = s[right]; right++; // 更新数据 if (need.count(c)) { window[c]++; if (window[c] == need[c]) { valid++; } } // 判断, 如果是可行解, 那么优化 while(valid == need.size()) { if (right - left \u0026lt; len) { start = left; len = right - left; } // 缩小窗口 char d = s[left]; left++; // 更新数据, 注意这一部分与扩大窗口的更新对称 if (need.count(d)) { if (window[d] == need[d]) { valid--; } window[d]--; } } } // 返回结果 return len == INT_MAX ? \u0026#34;\u0026#34; : s.substr(start, len); } }; ","date":"5 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/","section":"Posts","summary":"LeetCode-76 最小覆盖子串 # 参考文章: 我写了首诗，把滑动窗口算法算法变成了默写题 Solution 1 # 本题可以说是滑动窗口的代表了.","title":"LeetCode-76 最小覆盖子串"},{"content":"LeetCode-713 乘积小于 K 的子数组 # Solution 1 # 题目中所求的是满足元素乘积小于 $K$ 的连续子数组的数目, 连续子数组可以考虑动态规划或者滑动窗口. 本题中元素全部为正整数, 符合使用滑动窗口的要求. 我们从最左侧开始, 建立一个长度只有 $1$ 的窗口 $[left=0, right = 0]$, 同时用 $pro$ 来记录当前窗口元素之积. 现在计算以 $nums[right]$ 为结尾的符合要求的连续子数组个数: 每次窗口更新后, 我们通过右移 $left$ 来减少 $pro$ 使 $pro \u0026lt; k$, 由于元素都是正整数, 第一个满足 $pro \u0026lt; k$ 的 $left$ 右侧的所有 $left$ 一定也满足 $pro \u0026lt; k$, 因此以 $nums[right]$ 为结尾的合法子数组个数即为 $right - left + 1$. 把结果累加到 $ans$ 后, $right++$, 继续考虑下一位, 当到达数组末尾时跳出循环. 代码如下:\nclass Solution { public: int numSubarrayProductLessThanK(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int ans = 0; int right = 0; int left = 0; int pro = 1; while (right \u0026lt; nums.size()) { pro = pro * nums[right]; //考虑新窗口, 更新pro while (pro \u0026gt;= k \u0026amp;\u0026amp; left \u0026lt;= right) { pro = pro / nums[left]; left++; } ans = ans + right - left + 1; right++; } return ans; } }; 一个需要注意的地方是 $pro$ 何时更新, 把 $pro$ 放在循环开始时更新可以保证 $nums[right]$ 不越界.\n","date":"5 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-713-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","section":"Posts","summary":"LeetCode-713 乘积小于 K 的子数组 # Solution 1 # 题目中所求的是满足元素乘积小于 $K$ 的连续子数组的数目, 连续子数组可以考虑动态规划或者滑动窗口.","title":"LeetCode-713 乘积小于 K 的子数组"},{"content":"LeetCode-390 消除游戏 # Solution 1 # 这一题的形式很容易让人想到约瑟夫环问题, 事实上, 这道题也有巧妙的数学解法. 题中的操作是先从左到右删除元素, 再从右到左删除元素, 如此反复直至数列只剩一个元素, 对于一个数列 $1,2,\u0026hellip;,i$ , 我们把题给操作下最终保留的元素记作 $F(i)$ ; 现在考虑其对称操作: 先从右至左删除元素, 再从左至右删除元素, 如此反复直至数列只剩一个元素, 同样地, 我们给这一操作最终保留的元素一个记号, 记作 $G(i)$ . 由于这两种操作具备完全的对称性, 故有 $$ F(i) + G(i) = 1 + i $$\n由于我们最终的目标是找到 $F(i)$ 的一个递推式, 现在需要消去 $G(i)$ . 对数列 $1,2,\u0026hellip;,i$ , 考虑第一步从左至右删除元素, 得到数列$2, 4,\u0026hellip;, \\lfloor i/2 \\rfloor$ , 我们想要对新得到的数列进行 $G$ 操作, 由于 $G(n)$ 是对 $1,2,\u0026hellip;,n$ 进行的操作, 我们先建立起 $2, 4,\u0026hellip;,2× \\lfloor i/2 \\rfloor$ 与 $1,2,\u0026hellip;,k$ 的联系, 容易发现 $x_{j}^{new} = x_{j}^{old} /2$ , 故对 $2, 4,\u0026hellip;,2× \\lfloor i/2 \\rfloor$ 进行 $G$ 操作之后所得的数应为 $2×G( \\lfloor i /2 \\rfloor )$ , 即有\n$$ F(i) = 2 × G( \\lfloor i /2 \\rfloor ) $$ 得到了 $F(n)$ 与 $G(n)$ 的两个公式, 消去 $G(n)$ 可以得到仅含有 $F(n)$ 的递推式: $$ F(i) = 2 × (1 + \\lfloor i/2 \\rfloor - F(\\lfloor i/2 \\rfloor)) $$ 边界情况为 $F(1) = 1$ . 代码如下:\nclass Solution { public int lastRemaining(int n) { return n == 1 ? 1 : 2 * (n / 2 + 1 - lastRemaining(n / 2)); } } ","date":"4 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-390-%E6%B6%88%E9%99%A4%E6%B8%B8%E6%88%8F/","section":"Posts","summary":"LeetCode-390 消除游戏 # Solution 1 # 这一题的形式很容易让人想到约瑟夫环问题, 事实上, 这道题也有巧妙的数学解法.","title":"LeetCode-390 消除游戏"},{"content":"","date":null,"permalink":"/tags/%E5%AF%B9%E7%A7%B0%E6%80%A7/","section":"Tags","summary":"","title":"对称性"},{"content":"LeetCode-2251 花期内花的数目 # Solution 1 # 本题本质上是求一个点被多少区间覆盖的问题, 或者理解成维护一个数组, 这个数组需要频繁地把某个区间的元素进行增减. 常规的思想是利用差分数组进行维护, 考虑原数组 $nums$ ,我们建立一个数组 $diff$ ,它满足 $diff[i] = nums[i] - nums[i - 1]$(便于形式的统一, 我们认为 $nums[-1] = 0$ ) ,这样将区间 $[a,b]$ 的元素全部加上 $k$ 的操作就变成了 $diff[a] = diff[a] + k,diff[b + 1] = diff[b + 1] -k$ , 要得到原数组的某个元素 $nums[j]$ , 只需要把 $diff[0], \u0026hellip;, diff[j]$ 累加即可. 回到本题, 由于数据量的问题, 建立差分数组并依次求来访时间点的花数量会超时. 因此我们需要优化算法.\n优化一: 重复计算 # 首先考虑是否有重复计算的部分, 很明显, 对差分数组求原数组的一个元素相当于求差分数组的前缀和, 而在计算前缀和数组时, 我们利用一个 $Sum$ 按下标依次累加就可以得到所有前缀和. 因此, 根据游客来访的先后排序, 可以避免相当一部分的重复计算. 由于最后输出答案时需要按初始顺序输出, 我们必须在排序后仍能知道原始的顺序. 在这方面我定义了一个结构体:\nstruct visitTime{ int time; int index; visitTime(int time, int index): time(time), index(index){} }; 把结构体 $visitTime$ 存入数组中再排序. 但有一种更简洁的实现方法, 建立一个内容为 $0,1,\u0026hellip;,n - 1$的数组, 将其排序方法定义为与结构体类似的即可, 大致如下:\niota(id.begin(), id.end(), 0); sort(id.begin(), id.end(), [\u0026amp;](int i, int j) { return persons[i] \u0026lt; persons[j]; }); 这样也得到了一个按照来访先后排序的序号数组, 累加时按照这一数组顺序即可.\n优化二: 无效计算 # 从数据范围中可以看出, 时间轴很长, 但时间轴中真正用到的点并不多. 如果定义普通的差分数组 $vectordiff(1000000001,0)$ , 我们在累加答案时大部分时间都花费在了 $+0$ ,上, 这无疑是超时的一大原因. 为了解决这个问题, 需要离散化. 对于用到的(有变化的) $diff[k]$ ,我们才需要考虑它. 这一部分用数据结构 $map$ 实现, 大致如下:\nmap\u0026lt;int, int\u0026gt; diff; for (int i = 0; i \u0026lt; flowers.size(); i++) { diff[flowers[i][0]]++; diff[flowers[i][1]+1]--; } 在从小到大遍历时, 用 $auto\\ it = diff.begin()$ 遍历即可.\n代码实现 # 使用结构体存储的代码如下:\nclass Solution { struct visitTime{ int time; int index; visitTime(int time, int index): time(time), index(index){} }; public: static bool cmp(visitTime vt1, visitTime vt2) { return vt1.time \u0026lt; vt2.time; } vector\u0026lt;int\u0026gt; fullBloomFlowers(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; flowers, vector\u0026lt;int\u0026gt;\u0026amp; persons) { map\u0026lt;int, int\u0026gt; diff; for (int i = 0; i \u0026lt; flowers.size(); i++) { diff[flowers[i][0]]++; diff[flowers[i][1]+1]--; } int pN = persons.size(); vector\u0026lt;int\u0026gt; ans(pN); vector\u0026lt;visitTime\u0026gt; vt; for (int i = 0; i \u0026lt; pN; i++) { vt.push_back(visitTime(persons[i], i)); } sort(vt.begin(), vt.end(), cmp); int nowSum = 0; auto it = diff.begin(); for (int i = 0; i \u0026lt; pN; i++) { while (it != diff.end() \u0026amp;\u0026amp; it-\u0026gt;first \u0026lt;= vt[i].time){ nowSum = nowSum + it-\u0026gt;second; it++; } ans[vt[i].index] = nowSum; } return ans; } }; ","date":"4 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2251-%E8%8A%B1%E6%9C%9F%E5%86%85%E8%8A%B1%E7%9A%84%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2251 花期内花的数目 # Solution 1 # 本题本质上是求一个点被多少区间覆盖的问题, 或者理解成维护一个数组, 这个数组需要频繁地把某个区间的元素进行增减.","title":"LeetCode-2251 花期内花的数目"},{"content":"","date":null,"permalink":"/tags/stl/","section":"Tags","summary":"","title":"STL"},{"content":"","date":null,"permalink":"/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"差分数组"},{"content":"","date":null,"permalink":"/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/","section":"Tags","summary":"","title":"离散化"},{"content":"LeetCode-1823 找出游戏的获胜者 # 本题是一道非常经典的问题: \u0026ldquo;约瑟夫环问题\u0026rdquo;.\nSolution 1 # 在大一的编程课上就做过这道题, 当时用的是模拟的方法. 这道题给人的第一印象就是一道模拟题. 我们用一个 $bool$ 数组来模拟出局情况, 初始都设定为 $true$ ,当有人出局时将其修改为 $false$ . 首先注意到每一轮必定有一人出局, 初始有 $n$ 人, 最后剩余 $1$ 人, 所以游戏一共经历了 $n-1$ 轮. 我们利用一个指针 $p$ 来模拟点名的状况, 为了防止数组越界, 考虑对 $p$ 取模来模拟\u0026quot;循环\u0026quot;的过程. 最后不要忘记题目中序号从 $1$ 开始, 而数组中从 $0$ 开始, 返回的答案应该取模后 $+1$. 代码如下:\nclass Solution { public: int findTheWinner(int n, int k) { // 0,...,n - 1 vector\u0026lt;bool\u0026gt; isLive(n, true); int p = 0; for (int i = 0; i \u0026lt; n - 1; i++) { for (int j = 0; j \u0026lt; k; j++) { while (!isLive[p % n]){ //寻找下一个未出局的人 p++; } if (j != k -1) { p++; } // 在前k - 1次点名中, 点名后直接跳过, 而第k次点名到的人要出局 } isLive[p % n] = false; p++; } while (!isLive[p % n]){ p++; } return p % n + 1; // 输出时返回原来的序号 } }; Solution 2 # 这道题的数学模型相对简洁, 我们可以直接从数学上入手. 设 $P(n, k)$ 是初始 $n$ 人, 每次点名 $k$ 人最终的获胜者, 考虑其与 $P(n - 1, k)$ 的关系. 对于 $P(n, k)$ ,第一次点名结束后就能到达了 $P(n - 1, k)$ 的情况, 只不过序号发生的变化: 每个存活者的序号都前移了 $k$ 位( $mod\\ n$ 的意义下), 故可以得到如下的递推关系: $$ P(n, k) = (P(n - 1, k) + k)\\ mod\\ n $$ 注意到每个状态只和它前一个状态有关, 用两个变量即可完成递推. 代码如下:\nclass Solution { public: int findTheWinner(int n, int k) { int p_0 = 0; int p_1 = 0; for (int i = 1; i \u0026lt; n; i++) { p_1 = (p_0 + k) % (i + 1); p_0 = p_1; } return p_1 + 1; } }; ","date":"4 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-1823-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/","section":"Posts","summary":"LeetCode-1823 找出游戏的获胜者 # 本题是一道非常经典的问题: \u0026ldquo;约瑟夫环问题\u0026rdquo;.","title":"LeetCode-1823 找出游戏的获胜者"},{"content":"","date":null,"permalink":"/tags/%E6%B8%B8%E6%88%8F%E7%90%86%E8%AE%BA/","section":"Tags","summary":"","title":"游戏理论"},{"content":"","date":null,"permalink":"/tags/%E8%89%BA%E6%9C%AF/","section":"Tags","summary":"","title":"艺术"},{"content":" 写在前面: 这篇文章是我大一刚进校时选修的《写作与沟通》课程的期末作业。 在真正动笔前，我才发现理解一些陌生的、学术化的概念，并用清晰的语言阐述给别人，并不是一件很容易的事。四处查找文献、反复删改文章成了我期末长文写作路上最常见的事。 很高兴这些辛苦是值得的，这门课让我学会了一些文学、艺术上理论与技巧，但更重要的是它启示了我：即使是再愚钝的人，坚持不懈地努力也是可以有所收获的。 注: 本文封面图是《史丹利的寓言》（The Stanley Parable），一款非常经典的meta游戏。\n摘要 # 角色扮演游戏（RPG游戏）要素中，玩法与叙事是吸引玩家的关键。传统的RPG游戏设计理念认为玩法优先于叙事，先思考游戏的核心玩法，再将剧本文本穿插进游戏进程中。而这种“预设叙事”的游戏不可避免会出现“玩法”与“叙事”的不协调，从而产生“叙事失调”的问题。元游戏利用元艺术理念生发的“生成叙事”理论，将叙事逻辑与行为逻辑纳入一个体系，将局限在游戏内的叙事拓展到游戏内外联动的叙事，从而将“叙事失调”问题转化为了自身特色之一。元游戏的设计理念是值得被借鉴用于“叙事失调”问题的解决的。\n引言 # 电子游戏发展至今，画面的进步、产业的繁荣，催生出了一批批的优秀作品。角色扮演游戏（Role-playing game，后文中简称为RPG游戏）作为电子游戏的一个重要分支，以玩家扮演游戏中的角色推进故事情节发展，以完成游戏故事的叙述。优秀的叙事会在游戏交互中让玩家领略故事的真实与震撼，而失败的叙事则会让游戏失去原有的艺术魅力。因此，可以认为叙事是RPG游戏的核心之一。 RPG游戏作为电子游戏的分支，另一核心则是游戏共有的交互性——不同于传统的小说、电影，电子游戏的叙事依赖玩家的触发、参与，而非编剧的一厢情愿。这种“自由的不自由”为RPG游戏的叙事逻辑带来挑战：叙事体系的完善与游戏追求的自由度、可玩性产生了矛盾。当玩家在游戏中的行动违背了当初叙事设定的逻辑，就不可避免地会产生“叙事失调”的问题。在杰作《生化奇兵》发售不久、收获赞誉无数时，游戏编剧克林特·霍金就指出其“叙事失调”的问题：\n克林特认为，《生化奇兵》的叙事逻辑，是安兰德的理性自利主义。即个人在不妨碍、不侵犯他人以及社会利益的前提下，有资格做最自由的选择，做最自利的事情。 而在实际的游戏中，主角却处处受到阿特拉斯（Atlas）控制，具体体现在玩家必须“帮助”阿特拉斯，才能继续推进游戏。直到杀死雷恩，我们才发现一切都是“骗局”，自己实际上是被洗脑、被控制的。$^①$\n在克林特的观点提出后，业界逐渐认识到不少杰作在叙事上的致命缺陷：《刺客信条》刺客暗中潜入的剧情被玩家演绎成“大杀四方”；《古墓丽影》中考古学家劳拉拿起枪械后就杀人无数\u0026hellip;\u0026hellip;不仅是角色塑造与游戏玩法自由的叙事矛盾，RPG游戏在叙事上的其他普遍矛盾都被挖掘出来，成为了其叙事与玩法上最脆弱的一环。\n叙事失调反映出的本质问题：游戏设计中的“预设叙事” # 正如克林特对《生化奇兵》的分析中所指出的，游戏叙事失调的本质原因正是“玩法”与“叙事”的矛盾。传统叙事学理论认为，叙事动力包括作者动力和文本动力：作者动力为作者想要表现某种主题、传达某种思想而产生的“外部动力”，而文本动力则为事件之中人物行动自身具有的动力，即叙事的内在逻辑动力。 $^②$ 两者在游戏叙事上的投射即为“由玩法驱动游戏叙事”与“由剧本驱动游戏叙事”。 游戏开发者Thomas Grip曾在网络论坛中撰写了他开发游戏的一些体会与心得。关于游戏中的叙事，Thomas Grip认为：玩游戏时玩家会很快地觉察到游戏的核心机制，然后慢慢地接触到游戏具体策略和关卡。而玩家意识到叙事的时间比较长，通常以小时为单位。几乎所有游戏设计都集中在前两个较低的层次上，即核心机制和策略，而叙事主要是作为副产品出现的。叙事的设计成为一种拼凑的过程，通常是在机制和策略留下的小缝隙中勉强创造出连贯的叙事感。随后他在文章中指出了依据玩法设计叙事体系的逻辑：从游戏玩法开始，然后不断添加叙事要素，包括叙事目标，叙事背景以及心理模型。概括而言，即是以玩法为核心，将设计好的玩法中填入剧情。这种设计理念纯粹将游戏的交互性看待为最优先的，叙事、角色塑造等都是为游戏的交互性（即玩法）所服务的。 $^③$ 以叙事学的角度分析，这样的游戏叙事体系中的叙事动力是以“作者动力”为主的，游戏内在的“文本动力”则被放在了次要的位置上。这种叙事逻辑即为“预设叙事”，有效地将传统艺术形式中的叙事设计体系移植到了游戏叙事中。但其缺点是明显的：如果玩家的自由度并不算低，那么预设的剧本就有可能无法应付玩家可能在游戏中做出的一些违反游戏设定的初衷的行为，从而导致叙事失调——因为玩法与叙事本身就是一种割裂的状态。究其原因，正是游戏追求的“自由度”与“预设叙事”的限制始终存在难以调和的矛盾。传统的叙事艺术，如小说、叙事诗、戏剧、电影等，都是缺乏交互性的：创作者先将作品完成，整个故事的叙事体系已经搭建好，在这之后观众才能接触到成品。通常，观众接触的叙事是预设好的，单向且缺乏变化。但游戏与小说、电影等都不同，后者是纯粹的“仅供欣赏”艺术，艺术的解读可以是多样的，但艺术的内容是恒定的；而游戏却并非如此，玩家的一举一动，都可能在原本看似完好的叙事逻辑中撕开裂缝，从而造成叙事失调的后果。 传统RPG游戏作为以“预设叙事”为叙事逻辑的游戏，先有玩法、后有故事，在叙事逻辑与行为逻辑的博弈中，叙事被迫做出让步；而在游玩过程中，叙事的内容、模式又是既定的，玩家仅仅充当一个“触发剧情”、开启游戏玩法的开关，因此不可避免地产生叙事与玩法的不协调感。只要“预设叙事”的叙事逻辑仍在，RPG游戏就难以解决“叙事失调”的问题。\n另一种叙事逻辑与“另一种游戏” # “预设叙事”型RPG游戏背后的矛盾是“玩法”与“叙事”的矛盾，因此，寻找另一种“叙事逻辑”构筑的“另一种游戏”，才能从根本上解决叙事失调问题。与“预设叙事”的“玩法优先”相对的设计理念，则是“生成叙事”的“两者并重”。 $^④$ “生成叙事”的核心理念就是跳出“预设叙事”的藩篱，将叙事融入到游戏系统中，成为玩法的一部分，以叙事-玩法结合的游戏机制来推动游戏过程的进行。这种理念在在游戏上的应用是十分新颖的，但如果将视角从电子游戏扩大到整个叙事艺术领域，我们可以发现，“生成叙事”的概念并不陌生，它与文艺理论中的“元艺术”概念有着紧密的关联。所谓“元艺术”,就是关于艺术的艺术,它通过在艺术中展示艺术创作过程,或者对艺术家、艺术等进行评论而体现出艺术的自我意识。 $^⑤$ 元艺术的最重要的特征之一即为“自我指涉”。元艺术理论在游戏中的应用，表现在电子游戏叙事上就是元游戏中的“生成叙事”：玩家作为游戏叙事的参与者、创作者，而非往常传统游戏中被动的观众（受迫参与一个预设好的剧情），其“玩游戏”的这一行为、作为玩家本人而非生硬地带入角色的行为逻辑，都融入了游戏的叙事逻辑中。“系统驱动型”游戏因此获得一种自由，那就是让玩家自由的自由，玩家在游戏内外的操作的一切都是合理的，它要么完成了游戏内的叙事，要么完成了对游戏外“玩家”的叙事。换言之，元艺术理念指导下的元游戏是两款游戏：一款是传统的RPG游戏，让安分守己的玩家观看到一个传统的故事；另一款则是准备给不愿循规蹈矩的玩家的，他们看到的会是一个关于“玩家”、关于“自我”的故事。后者听起来似乎更迷人。这与元艺术产生之初的观者感受是相似的：打破“沉浸感”的叙事体系，更容易引起思考，从而让人进入到一种更深的沉浸中。这正是叙事学家Genette所提出来的“共时叙事”。 共时叙事是与动作同时发生的。元游戏的“共时叙事”让玩家有机会成为游戏剧情的构建者，从而获得了叙事上的正反馈。 $^⑥$\n以《Undertale》等游戏为例看元游戏如何应对“叙事失调” # 2015年9月15日发布的独立游戏《Undertale》注定将留名游戏史，这款游戏以自身的优秀素质再次引发了对“元游戏”的讨论，其自身的诸多设计也是研究“元游戏”叙事的绝佳范例。 《Undertale》的画面在当今看来并不算优秀，像素画面、干涩的色彩搭配，以及朴实无华乃至有些简陋的系统界面，都让它看上去像上个世纪的RPG游戏。正如同上文所说，《Undertale》其实是两个游戏：一个是常规的冒险RPG游戏，玩家会像游玩传统RPG游戏一样看到一个普通的叙事体系；另一个则是展现“系统驱动”魅力的元游戏。对于一个循规蹈矩、耐心遵照传统设计者意图的玩家，他将收获一个普通的故事；而对于常常挑战游戏叙事逻辑的“刺头”玩家，《Undertale》则准备了应付玩家游戏内外各种行为的叙事文本与游戏系统，并且将为他们展示常规路线下看似普通的故事背后更深刻的设定与思考。 《Undertale》里探讨的内容、讲述的故事复杂而深刻，其游戏系统也是别具一格。根据玩家对待游戏角色的不同态度，会得到不同的剧情和结局。多结局的设定在传统RPG里并不罕见，为了打出最理想的结局，玩家一般都会通过多次存档/读档达成目标。但《Undertale》叙事逻辑中最精彩的一点在于，虽然提供了存档/读档功能，但玩家并不能通过存档/读档真正弥补过去的一切错误；游戏里的角色不仅知道玩家有着存档/读档的能力，个别角色还会反过来利用存档/读档对付玩家。甚至在玩家达成完美结局通关后，游戏还会恳求玩家不要重启这个世界，让这个世界真正地归于平静。 传统像素RPG冒险游戏的自由度有限，相对而言不会出现太多线性剧情上的叙事失调。但游戏往往拥有的存档/读档要素，很容易让玩家的沉浸感幻灭，割裂游戏中的“角色”与玩家本人的统一感。存档/读档在传统的游戏中，是一种不会留下痕迹的“作弊”手段，无论在游戏中曾经伤害过多少人，读取存档后都可以继续以英雄姿态进行接下来的剧情，这种局限在游戏内部、纯粹以表面上的叙事推动游戏进程（即“叙事驱动”）的游戏，给玩家带来的是相当程度的失调感。 而在《Undertale》中，玩家同样可以无限制的存档/读档，但真正展现它作为一款元游戏的地方就在于：玩家的每一步存档/读档，看似是玩法逻辑的一部分，实则也纳入到了叙事逻辑的一部分中——游戏内的部分人物会对玩家在“系统层面”的操作给出回应，叙事的走向也会随之改变。例如，玩家在游戏中，如果在杀害善良的角色Toriel后感到了后悔并选择读取存档到先前的游戏进度中，则会被游戏中的另一个角色讽刺：“你杀死了她（Toriel），于是你后悔了，又回到了现在。” 《Undertale》中的“生成叙事”同样体现在多结局的设计上。根据玩家杀死怪物的多少，游戏会触发“和平”“普通”与“屠杀”结局，而不同于常规的多结局设计的地方在于，当玩家杀死游戏中所有的人物达成“屠杀”结局后，游戏会修改本地的文件并将记录上传于网络，将玩家游戏内的“屠杀”行为永久烙在其账号记录上。并且，一旦玩家完成“屠杀”结局后，便无法再次完成“和平”结局。传统RPG游戏的叙事失调中出现的玩家“选择成为恶人后，再次开始游戏试图扮演一个好人”的行为，在元游戏的叙事逻辑中将不会被允许。这种跨越游戏与现实边界的叙事将“生成叙事”的范畴从游戏内扩展到了游戏外（如玩家的网络账号），让现实也成为了元游戏叙事体系的一部分，从而依托叙事展现了“元游戏”对游戏行为与现实世界的反思。 $^⑦$ 《Undertale》在叙事逻辑的设置上选择了“生成叙事”，将游戏内的叙事扩展到了游戏内外一体的叙事，完成了游戏内叙事的革新与升华。 诸如《Undertale》的元游戏不仅为诸多不走寻常路的玩家提供了更为精彩的叙事，也让游戏内的角色、故事不再是局限在程序之中的一行行冷冰冰的代码，而是在虚拟与现实地交界处震撼了玩家。当可能会导致“叙事失调”的情形也被纳入了叙事的范畴中，它便不再是一个让创作者与玩家头疼的顽疾了。作为传统游戏叙事逻辑中的一个重要缺陷的“叙事失调”，本身并未被元游戏破解，但是其背后折射出的游戏的“交互性”、玩家的游戏心态等却被元游戏巧妙地利用，以“生成叙事”的叙事逻辑纳入叙事范畴中，引导玩家从对游戏剧情的思考到对游戏行为的思考，最终到达对现实行为的思考——“玩游戏”还是“在游戏中探讨游戏”以至“在游戏探讨现实”，元游戏的叙事体系达到了一个令人满意的平衡。 从《Undertale》的分析中可以看到，元游戏在叙事上吸收了“元艺术”理论中自我指涉、自我反思、不为形式所拘束的特征 $^⑧$ ，以“生成叙事”为游戏叙事理论提供一个新的方向。\n反思与展望 # 《Undertale》等元游戏的成功、玩家们对这类叙事结构的赞誉在一定程度上反映了“叙事失调”的问题困扰业界、玩家已久，而元游戏正提供解决这个问题的一个方向。正如小说中的《堂吉诃德》、戏剧中的《徒劳》一样，一种元艺术形式的成功会给艺术带来更多可能。近年来，有更多地“元游戏”出现在了大众面前，足以说明，“元游戏”的艺术理念是受到大众认可的。 但另一方面，我们应当认识到，艺术也不止元艺术这一种发展方向。“叙事失调”固然是个不小的问题，但并不意味着不依赖元游戏形式创作的游戏就不是杰作，我们也不应限制所有的游戏都应用“系统驱动”的设计理念。“叙事失调”的提出与关注，是游戏叙事艺术受到关注与重视的体现，而艺术，恰恰是最忌讳单一的。 笔者认为，参考元艺术理论，以“生成叙事”作为叙事逻辑的元游戏为解决“叙事失调”问题提供了一种新的思路，正确运用相关理论可以提高游戏叙事的质量，与此同时，也应当注重其他叙事理论的探索，为电子游戏叙事艺术开辟新的道路。\n参考文献 # ①: 果其然：《当英雄被玩成了杀人狂：论游戏中的叙事失调》，2019年03月17日，https://zhuanlan.zhihu.com/p/59229372，2021年1月1日。 ②: 郭明玉：《论叙事动力的流程和类型》，硕士学位论文，江西师范大学文学院，2008年，第5-17页。胡亚敏：《叙事学》，武汉：华中师范大学出版社，2004年，第36-52页。 ③: Thomas Grip:“4-Layers, A Narrative Design Approach”,2014.4.29. https://www.gamasutra.com/blogs/ThomasGrip/20140429/216467/4Layers_A_Narrative_Design_Approach.php. 2021年1月1日。 ④: 刘梦霏：《叙事VS互动：影游融合的叙事问题》，《当代电影》， 2020年10期 ，第50-59页。 ⑤ ⑧: 张新科：《元艺术与后现代主义》，《艺术评论》，2020年03期，第34-42页。 李心峰：《关注“元艺术”》，《艺术评论》，2020年03期，第20-27页。 ⑥: 关萍萍：《电子游戏叙事性解读》，《淮阴师范学院学报》(哲学社会科学版)，2010年01期，第110-114页。 ⑦: 温彩云：《伪存在、时间消费与分离效果:网络游戏的景观性特征》，《现代传播》，2020年第04期，第106-110页。\n","date":"4 May 2022","permalink":"/posts/%E9%9A%8F%E7%AC%94/%E8%AE%BA%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E5%8F%99%E4%BA%8B%E5%A4%B1%E8%B0%83%E4%B8%8E%E5%85%83%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BA%94%E5%AF%B9%E4%B9%8B%E9%81%93/","section":"Posts","summary":"写在前面: 这篇文章是我大一刚进校时选修的《写作与沟通》课程的期末作业。 在真正动笔前，我才发现理解一些陌生的、学术化的概念，并用清晰的语言阐述给别人，并不是一件很容易的事。四处查找文献、反复删改文章成了我期末长文写作路上最常见的事。 很高兴这些辛苦是值得的，这门课让我学会了一些文学、艺术上理论与技巧，但更重要的是它启示了我：即使是再愚钝的人，坚持不懈地努力也是可以有所收获的。 注: 本文封面图是《史丹利的寓言》（The Stanley Parable），一款非常经典的meta游戏。","title":"论角色扮演游戏中的“叙事失调”与元游戏的应对之道"},{"content":"二维偏序问题 # 设 $R$ 是集合 $A$ 上的一个二元关系, 若 $R$ 满足:\n自反性: 对$\\forall x\\in A$ , 有 $xRx$; 反对称性: 对$\\forall x,y\\in A$ , 若 $xRy$ , 且 $yRx$ , 则有 $x=y$ . 传递性: 对$\\forall x,y,z\\in A$, 若 $xRy$ , 且 $yRz$ , 则有 $xRz$ . 则称 $R$ 是 $A$ 上的一个偏序关系. 一个典型的二维偏序问题如下: 输入二维坐标下一系列不相同的点, 对每个点, 输出横纵坐标均小于它的点的个数.\n一般处理方法 # 二维偏序问题涉及数组维护和区间查询两个方面, 考虑利用树状数组来进行处理. 接收数据后, 我们将数据按照一个维度排好序, 这时候考虑其第二个维度即可. 例如, 将平面上的点按照横坐标从小到大排序, 此时根据横坐标依次处理点只需要考虑排在其位置之前的点的纵坐标即可. 对每个点, 我们按照如下流程处理:\n读取纵坐标 输出其前缀和 更新树状数组 ","date":"3 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%8E%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","section":"Posts","summary":"二维偏序问题 # 设 $R$ 是集合 $A$ 上的一个二元关系, 若 $R$ 满足:","title":"二维偏序问题与树状数组"},{"content":"","date":null,"permalink":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","section":"Tags","summary":"","title":"树状数组"},{"content":"","date":null,"permalink":"/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/","section":"Tags","summary":"","title":"区间查询"},{"content":"树状数组 # 引入 # 对于一个数组, 最常见的操作有两种: 单点修改与区间查询. 对于常规数组而言, 单点修改的时间复杂度是 $O(1)$ , 但区间求和的时间复杂度是 $O(n)$ ; 如果使用前缀和来维护数组, 区间求和的时间复杂度是 $O(1)$ , 单点修改的时间复杂度则增长到了 $O(n)$. 如果既需要单点修改又需要区间查询, 显然这两种数据结构都不够好, 它们在某一特定方面表现得非常糟糕. 因此, 我们需要寻找这样一种数据结构, 它相对均衡, 在单点修改与区间查询方面都做得不错.\n代码实现与分析 # 先看看树状数组的代码实现:\n//定义lowbit()函数, 返回二进制数最右边的一个1及其后面的0 #define lowbit(x) ((x) \u0026amp; (-x)) // 全局变量数组 int tree[MAXN]; //单点修改\u0026amp;初始化操作, 将tree[i]修改为x, inline void update(int i, int x) { for (int pos = i; pos \u0026lt; MAXN; pos += lowbit(pos)) tree[pos] += x; } //求前n项和 inline int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) ans += tree[pos]; return ans; } //区间查询操作, 求第a, a + 1,..., b项之和 inline int query(int a, int b) { return query(b) - query(a - 1); } 核心项为三块:\n$lowbit()$ 函数 //定义lowbit()函数, 返回二进制数最右边的一个1及其后面的0 #define lowbit(x) ((x) \u0026amp; (-x)) 原理: 计算机中有符号数一般通过补码存储, $-x$ 为 $x$ 按位取反再$+1$, 从右往左直至第一个 $1$ 都相同, 再往左的位数全部相反, 两者按位与之后恰好得到二进制数最右边的一个 $1$ 及其后面的 $0$ .\n单点修改 首先需要明白 $C_i$ 维护了区间 $(A_i-lowbit(Ai), Ai]$ , 对于某一点进行修改, 需要相应地修改包含它的所有区间. 这一修改过程, 实质上相当于不停地给节点下标加上其 $lowbit()$ 值. //单点修改\u0026amp;初始化操作, 将tree[i]增加x, inline void update(int i, int x) { for (int pos = i; pos \u0026lt; MAXN; pos += lowbit(pos)) tree[pos] += x; } 区间查询 我们考虑前 $i$ 项和, 将 $i$ 转化成二进制, 前 $i$ 项和恰等于对 $(j-lowbit(j), j]$ 区间累加(每次去掉最右边一个 $0$). inline int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) ans += tree[pos]; return ans; } 对于树状数组, 每次操作涉及的区间数不超过 $log_2MAXN$, 对于单点修改和区间查询而言, 时间复杂度都为 $O(logn)$ .\n","date":"3 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","section":"Posts","summary":"树状数组 # 引入 # 对于一个数组, 最常见的操作有两种: 单点修改与区间查询.","title":"树状数组"},{"content":"LeetCode-2250 统计包含每个点的矩形数目 # 正如上图所示, 本题数据量较大\u0026hellip;$O(n^2)$的暴力算法完全过不了, 必须优化.\nSolution 1 # 从 $1\\leq h_i, y_j\\leq 100$ 可以想到本题的第一个优化方向, $y$ 范围不大, 可以单独为每个 $y$ 建立一个数组 $logs[y]$ 用于存放纵坐标为 $y$ 的矩形顶点的横坐标.对每个点 $(px, py)$, 依次遍历 $logs[py],\u0026hellip;,logs[100]$ , 统计不小于 $px$ 的元素个数, 累加存入答案数组中即可. 但这次优化后依然会超时, 原因是统计 $logs[py],\u0026hellip;,logs[100]$ 不小于 $px$ 的元素个数效率过低. 基于这一缺点我们再次优化, 将 $logs[1],\u0026hellip;,logs[100]$ 排序, 再利用二分查找得到不小于 $px$ 的元素个数. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; countRectangles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rectangles, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { vector\u0026lt;int\u0026gt; ans; int rN = rectangles.size(); int pN = points.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; logs(101, vector\u0026lt;int\u0026gt;(0)); //记录每个y对应的x for (int i = 0; i \u0026lt; rN; i++) { logs[rectangles[i][1]].push_back(rectangles[i][0]); } for (int i = 1; i \u0026lt;= 100; i++) { sort(logs[i].begin(), logs[i].end()); } for (int i = 0; i \u0026lt; pN; i++) { int px = points[i][0]; int py = points[i][1]; int res = 0; for (int j = py; j \u0026lt;= 100; j++) { if (logs[j].size() != 0) { int left = 0; int right = logs[j].size(); while(left \u0026lt; right) { int mid = left + (right - left) / 2; if (logs[j][mid] == points[i][0]) { right = mid; } else if(logs[j][mid] \u0026lt; points[i][0]) { left = mid + 1; } else if(logs[j][mid] \u0026gt; points[i][0]) { right = mid; } } } res = res + logs[j].size() - left; } } ans.push_back(res); } return ans; } }; Solution 2 # 思考本题的目标:对每个点, 统计横纵坐标都不小于它的矩阵顶点个数. 这是一个二维偏序问题, 我们可以利用树状数组来解决.对所有的点(包含矩阵顶点)按 $x$ 排序,再依照此顺序进行如下操作:\n是否为矩阵顶点? 是: 不输出前缀和, 压入数组中 否: 输出前缀和, 不压入数组中 这和利用树状数组处理一般二维偏序问题的过程类似, 只不过把两种点区别对待了. 代码如下:\n\\\\ 树状数组模板 class BIT { public : BIT(int size) : n(size), c(n + 1) {} void update(int i, int x) { while (i \u0026lt;= n) c[i] += x, i += lowbit(i); return ; } int query(int x) { int sum = 0; while (x) sum += c[x], x \u0026amp;= (x - 1); return sum; } private: int n; // MAXN vector\u0026lt;int\u0026gt; c;//数组 //lowbit()函数定义 int lowbit(int x) { return x \u0026amp; (-x); } }; class Solution { //结构体 定义一个通用的点, 矩阵顶点标记记为-1, 普通点标记记录其原本的下标. struct normalPoint{ int x; int y; int index; normalPoint(int x, int y, int index): x(x), y(y), index(index) {} }; public: static bool cmp(normalPoint p1, normalPoint p2) { if (p1.x - p2.x != 0) { return p1.x \u0026gt; p2.x; } // x大的排在前面 if (p1.y - p2.y != 0) { return p1.y \u0026gt; p2.y; } // x一样, y大的排在前面 if (p1.index \u0026lt; p2.index) { return true; } // x, y都一样, 依据题意只能是一个点一个矩阵, 依据树状数组的输出特性把矩阵排到前面 return false; } vector\u0026lt;int\u0026gt; countRectangles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; rectangles, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; points) { int rN = rectangles.size(); int pN = points.size(); vector\u0026lt;int\u0026gt; ans(pN); vector\u0026lt;normalPoint\u0026gt; np; for (int i = 0; i \u0026lt; rN; i++) { np.push_back(normalPoint(rectangles[i][0], rectangles[i][1], -1)); } for (int i = 0; i \u0026lt; pN; i++) { np.push_back(normalPoint(points[i][0], points[i][1], i)); } sort(np.begin(), np.end(), cmp); //排好序后的数组, 横坐标从大到小, 纵坐标从大到小, 矩阵排在点之前 BIT tree(105); // 我们维护y坐标固定下x的数量 for (int i = 0; i \u0026lt; rN + pN; i++) { int index = np[i].index; if (index \u0026lt; 0) { tree.update(101 - np[i].y, 1); // 横坐标不小于目前点的,纵坐标为101 - np[i].y的点数量+1 } else { ans[np[i].index] = tree.query(101 - np[i].y); //查询横坐标不小于当前点,且纵坐标不小于当前点的点数量 } } return ans; } }; ","date":"3 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-2250-%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E6%AF%8F%E4%B8%AA%E7%82%B9%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/","section":"Posts","summary":"LeetCode-2250 统计包含每个点的矩形数目 # 正如上图所示, 本题数据量较大\u0026hellip;$O(n^2)$的暴力算法完全过不了, 必须优化.","title":"LeetCode-2250 统计包含每个点的矩形数目"},{"content":"","date":null,"permalink":"/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/","section":"Tags","summary":"","title":"二分搜索"},{"content":"LeetCode-937 重新排列日志文件 # 本题是一道自定义排序题, 需要理解题意后设计合适的排序算法.\nSolution 1 # 利用C++中sort函数的自定义排序功能来解决这道问题.\nsort()函数 # // vector\u0026lt;\u0026gt;() vec; // cmp 为自定义的比较函数C++ // 对 vec 原地排序，将其按cmp定义的从小到大的顺序排列 std::sort(vec.begin(), vec.end(), cmp); //若未定义cmp, 则以默认方式从小到大排列 cmp()函数 # // 从大到小: static bool cmp(int a, int b) { return a \u0026gt; b; // 从小到大: static bool cmp(int a, int b) { return a \u0026lt; b; // cmp可以理解为:传入两个参数, (a, b)排序是否是正确的, 若是正确的返回true, 否则返回false // 在这种理解下, 从大到小的cmp函数本质上就是这样: static bool cmp(int a, int b) { if (a \u0026gt; b) { return true; // 符合a \u0026gt; b } return false; // 不符合a \u0026gt; b, 需要交换 题目分析 # 回到本题, 我们利用sort()和自定义cmp()来实现排序功能. 日志共有两种, 字母类和数字类, 同时最后排序完成时字母类需要排在数字类前面, 所以我们考虑分别用两个Vector来存储字母类日志和数字类日志, 对字母类日志排序后将数字类日志插入到字母类Vector的末尾.\n代码实现 # class Solution { public: static bool cmp(string s1, string s2) { //寻找标识符与日志内容的分界线 int p1 = s1.find(\u0026#39; \u0026#39;); int p2 = s2.find(\u0026#39; \u0026#39;); string log1 = s1.substr(p1 + 1); string log2 = s2.substr(p2 + 1); if (log1 != log2) { return log1 \u0026lt; log2;// 日志内容不同时, 对日志内容进行字典序比较, 按字典序从小到大 } return s1 \u0026lt; s2;// 日志内容相同时, 对标识符进行字典序比较, 按字典序从小到大 } vector\u0026lt;string\u0026gt; reorderLogFiles(vector\u0026lt;string\u0026gt;\u0026amp; logs) { vector\u0026lt;string\u0026gt; letter, number; for (int i = 0; i \u0026lt; logs.size(); i++) { int p = logs[i].find(\u0026#39; \u0026#39;); if (logs[i][p + 1] \u0026lt; \u0026#39;a\u0026#39;) { number.push_back(logs[i]); } else { letter.push_back(logs[i]); } } sort(letter.begin(), letter.end(), cmp);// 自定义排序 letter.insert(letter.end(), number.begin(), number.end()); return letter; } }; ","date":"3 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-937-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/","section":"Posts","summary":"LeetCode-937 重新排列日志文件 # 本题是一道自定义排序题, 需要理解题意后设计合适的排序算法.","title":"LeetCode-937 重新排列日志文件"},{"content":"#线性规划\n定义\u0026amp;特性 # 对决策变量有整数要求的数学规划问题(线性/非线性).\n有广泛的应用背景, 如指派问题、背包问题、旅行推销商问题都是整数规划问题. 是最难求解的问题之一, 至今还没有找到有效算法. 整数规划与线性规划的联系 # 整数规划 = 相关的线性规划 + 整数约束; 整数规划是约束得更紧的问题, 它的可行域是其相关线性规划问题可行域的一个子集. 整数规划的求解难度远大于线性规划. 整数规划的分类 # 纯整数规划: 所有决策变量取整数值; 0-1整数规划: 整数变量只能取0或1; 混合整数规划: 部分决策变量取整数值或二态值. 整数规划求解的困难性 # 问题1 # Q: 为什么不求解对应的线性规划问题, 然后将解四舍五入取整数解呢? A: 如下图所示, 在部分可行域中, 整数规划最优解可能与线性规划最优解相差甚远. 问题2 # Q: 可以使用枚举法来求解整数规划问题吗? A: 当数据量较小时是可以的. 但对于一般的整数规划问题, 枚举法的计算量通常呈指数级增长态势, 即使是计算机也无能为力. 如何克服其困难性? # 割平面法: 有理论意义, 但计算效率较低; 分支定界法: 剪枝, 计算效率高, 应用广泛; 隐枚举法: 需要精心设计; 启发算法: 效率高, 但不保证能够找到最优解, 可以解大规模问题 割平面法 # 考虑纯整数规划问题: $$ max\\ z = \\sum_{i=1}^{n}c_ix_i\\ s.t. \\begin{cases} \\sum_{j=1}^{n}a_{ij}x_j\\leq b_i, (i=1,\u0026hellip;,m)\\\nx_j\\geq 0, (j=1,\u0026hellip;,n)\\ x_j取整数 \\end{cases} $$ 割平面法的基本思想: 先求解松弛问题. 设松弛问题的最优解 $X^=(x_1\u0026hellip;x_m\\ y_1\u0026hellip;y_n)$ , 其中基变量为 $(x_1\u0026hellip;x_m)$ , 非基变量 $(y_1\u0026hellip;y_n)$ 假设 $X^$ 不是整数, 考虑某个不为整数的 $b_i$ 对应的诱导方程: $$ x_i+\\sum_{j=1}^n\\overline{a}{ij}y_j=\\overline{b}i $$ 其中, $\\overline{b}i=\\widetilde{b}i+\\beta_i$,$\\overline{a}{ij}=\\widetilde{a}{ij}+\\alpha{ij}$ .($\\widetilde{b}i与\\widetilde{a}{ij}$为整数, $\\beta_i\\in (0,1), \\alpha{ij}\\in [0,1)$). 诱导方程变形后即有: $$ \\beta_i - \\sum_{j=1}^na_{ij}y_j=x_i-\\widetilde{b}i + \\sum{j=1}^{n}\\widetilde{a}{ij}y_j $$ 注意到 $x_i-\\widetilde{b}i + \\sum{j=1}^{n}\\widetilde{a}{ij}y_j$ 为整数,割平面方程即为: $$ \\beta_i - \\sum_{j=1}^na_{ij}y_j+s_i=0 $$ 其中$s_i$为非负整数. 该割平面方程满足:\n没有割去任何一个可行的整数解; 割去了非整数最优解(当前松弛LP问题的最优解) 割平面法相当于一步步缩小可行域, 求解新的线性规划问题, 直到线性规划问题的最优解恰为整数, 这时便得到了原始整数规划问题的最优解; 割平面法只适用于纯整数规划问题. 分支界定法 # 考虑纯整数规划问题: $$ max\\ z=CX\\ s.t.\\begin{cases} AX=b\\ X\\geq 0\\ x_1,x_2,\u0026hellip;,x_k为整数 \\end{cases} $$ 其松弛问题为: $$ max\\ z=CX\\ s.t.\\begin{cases} AX=b\\ X\\geq 0 \\end{cases} $$ 求解该松弛问题, 如果最优解已经满足 $x_1,x_2,\u0026hellip;,x_k$ 为整数, 则该解也是原整数规划问题的最优解;否则,我们选取$x_1,x_2,\u0026hellip;,x_k$中的一个非整数分量 $x_i$ , 假设 $x_i$的取值在两个相邻整数$b_i$和$b_i+1$之间, 将松弛问题划分为子问题 $1$ : $$ max\\ z=CX\\ s.t.\\begin{cases} AX=b\\ x_i\\geq b_i+1\\ X\\geq 0 \\end{cases} $$ 与子问题 $2$ : $$ max\\ z=CX\\ s.t.\\begin{cases} AX=b\\ x_i\\leq b_i\\ X\\geq 0 \\end{cases} $$ 这相当于在松弛问题可行域中割掉了 $b_i\u0026lt;x_i\u0026lt;b_i+1$ 的部分(显然这一部分不会存在满足原整数规划的解). 求解子问题的过程中, 需要通过分支定界法继续分割问题.在这一过程中, 所求得的子问题最优解不一定是原问题最优解, 我们需要比较所有子问题的理论最有解才能得出原问题最优解.\n分支变量选择原则\n按目标函数系数:选系数绝对值最大变量先分支 按使用者经验来对各整数变量排列优先顺序 分支节点选择原则\n深探法: 尽快找到整数解, 解的质量可能一般; 广探法: 选择目标函数当前最大值节点继续分支, 解的质量通常较高. 实践中有一种可行的剪枝方法, 当一个子问题不满足整数约束的最优解 $\u0026lt;$ 当前所得最优整数解时, 不必再在这一部分继续分支, 因为分支所得整数解不会取代当前最优整数解.\n分支界定法优点\n纯整数规划及混合整数规划都可以使用 思路简单灵活 速度快 适合上机 ","date":"3 May 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%BF%90%E7%AD%B9%E5%AD%A6/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92/","section":"Posts","summary":"#线性规划","title":"整数规划"},{"content":"#线性规划\n定义 # 线性规划指目标函数和约束条件均为线性的优化问题.\n数学模型 # 模型特点:包含决策变量,目标函数以及约束条件.\n决策变量:$(x_1,\u0026hellip;,x_n)$,是决策人要考虑和控制的因素; 目标函数:$z=f(x_1,\u0026hellip;,x_n)$,线性形式，通常求$z$的极大或极小值. 约束条件:线性等式或不等式 线性规划数学模型的一般形式: $$ max(或min)\\ z=c_1x_1+c_2x_2+\u0026hellip;+c_nx_n\\ s.t. \\begin{cases} a_{11}x_1+a_{12}x_2+\u0026hellip;+a_{1n}x_n\\leq(=,\\geq)b_1\\ a_{21}x_1+a_{22}x_2+\u0026hellip;+a_{2n}x_n\\leq(=,\\geq)b_2\\ \\qquad\\qquad\\qquad\u0026hellip;\u0026hellip;\\ a_{m1}x_1+a_{m2}x_2+\u0026hellip;+a_{mn}x_n\\leq(=,\\geq)b_m\\ \\end{cases} $$ 亦即: $$ max(或min)\\ z= \\sum_{i=1}^{n} c_ix_i\\ s.t. \\begin{cases} \\sum_{j=1}^{n} a_{ij}x_i\\leq(=,\\geq)b_i,i=1,2,\u0026hellip;,m\\ x_j\\geq 0,j=1,2,\u0026hellip;,n \\end{cases} $$ 数学模型隐含的假设:\n比例性： 决策变量变化引起目标的改变量与决策变量改变量成正比. 可加性： 每个决策变量对目标和约束的影响独立于其它变量. 连续性： 每个决策变量取连续值. 确定性： 线性规划中的参数$a_{ij}$,$b_i$,$c_i$为确定值. 建模步骤 # 三步走:\n需要做哪些决策?$\\longrightarrow$确定决策变量 问题的目标是什么?$\\longrightarrow$写出目标函数 资源和需求之间的情况如何?$\\longrightarrow$确定约束条件 线性规划的标准型 # $$ max\\ z=c_1x_1+c_2x_2+\u0026hellip;+c_nx_n\\ s.t. \\begin{cases} a_{11}x_1+a_{12}x_2+\u0026hellip;+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\u0026hellip;+a_{2n}x_n=b_2\\ \\qquad\\qquad\\qquad\u0026hellip;\u0026hellip;\\ a_{m1}x_1+a_{m2}x_2+\u0026hellip;+a_{mn}x_n=b_m\\ \\end{cases} $$ 亦即: $$ max\\ z=CX\\ s.t. \\begin{cases} AX=b\\ X\\geq0 \\end{cases} $$\n对一般的线性规划模型,我们通过添加松弛变量让其变为标准型.\n线性规划求解:图解法 # 对于决策变量$x_1$,$x_2$,以$x_1$,$x_2$为坐标轴建立平面直角坐标系,依靠约束条件画出可行域,寻找$z=CX$所构成的直线族中满足题意的直线.\n优点:简单、直观，便于了解线性规划基本原理和几何意义; 缺点:只能用来求解两个决策变量的问题. 线性规划的启示:\n可行域： 由约束平面围起来的凸多边形区域，可行域内每一个点代表一个可行解 如果可行域非空，那么它一定是一个凸集。 最优解： 总是在可行域的边界上，一般由可行域的极点（顶点）表示。 积极(紧)与非积极(非紧)约束： 在最优解处满足等式的约束为积极(紧)约束； 在最优解处满足严格不等式的约束为非积极(非紧)约束。 特殊情形： 如果可行域为空集，线性规划问题无可行解； 如果目标函数等值线可以无限地在可行域内向改善的方向移动，线性规划问题无界； 线性规划问题可能存在无穷多个最优解。 线性规划求解:单纯形法 # 在单纯形法之前:一些基本概念与定理 # 考虑线性规划问题: $$ max\\ z=CX\\ s.t. \\begin{cases} AX=b\\ X\\geq0 \\end{cases} $$\n基,基向量,基变量: $B$是矩阵$A$中的一个$m×m$阶的满秩子矩阵，称为线性规划问题的一个基. $B$中的每一个列向量$P_j$为基向量: $$ \\begin{cases} A=(P_1\\ \u0026hellip;\\ P_m\\ \\ P_{m+1}\\ \u0026hellip;\\ P_n)=(B,N)\\ \\quad\\quad\\quad基向量\\quad非基向量\\quad\\quad \\end{cases} $$ 对应的$x_j$为基变量: $$ \\begin{cases} X=(x_1\\ \u0026hellip;\\ x_m\\ \\ x_{m+1}\\ \u0026hellip;\\ x_n)^T=(X_B,X_N)^T\\ \\quad\\quad\\quad基变量\\quad非基变量\\quad\\quad\\quad\\quad \\end{cases} $$ 基解,基可行解,可行基\n求解$AX=b$可得:$X_B=B^{-1}b-B^{-1}NX_N$. 对应于基$B$,$X=(B^{-1}b,0)^{T}$为$AX=b$的一个基解. 满足变量非负约束(即$B^{-1}b\\geq0$)的基解称为基可行解,对应的基$B$称为可行基. 注意:\n基解中最多有$m$个非零分量 基解的数目不超过$C_n^m$ 凸集: 如果集合$D$中任意两点$X_1$和$X_2$,其连线上的所有点也都是集合$D$中的点，称$D$为凸集.(即对任何$X_1,X_2\\in D$和$0\\leq a\\leq 1$,有$X=aX_1 +(1-a)X_2\\in D$) 凸组合: $X_1,X_2,\u0026hellip;,X_k$是$n$维欧氏空间中的$k$个点,若有一组数$\\mu_1,\\mu_2,\u0026hellip;,\\mu_k$ 满足 $0\\leq\\mu_i\\leq 1$ ($i=1,\u0026hellip;,k $),且 $\\sum_{i=1}^{k}\\mu_i=1$ ,那么 $X=\\sum_{i=1}^k\\mu_iX_i$ 是点$X_1,X_2,\u0026hellip;,X_k$ 的凸组合 顶点: 凸集 $D$ ,点 $X\\in D$ ,若找不到两个不同的点 $X_1,X_2\\in D$ ,使得 $X=aX_1+(1-a)X_2,0\u0026lt;a\u0026lt;1$ ,则称$X$为$D$的顶点. 定理1: 如果LP问题存在可行解,那么其可行域一定是凸集. 引理1: $D$为有界凸多面集,$X\\in D$,$X$必可表示为$D$的顶点的凸组合. 定理2: 如果LP问题的可行域有界,则其最优值必可在顶点处获得. 引理2: LP问题的可行解$X$是基可行解的充分必要条件是:$X$的非$0$分量对应的系数列向量线性无关. 定理3: LP问题的基可行解$X$对应可行域的顶点. 单纯形法 # 基本思路:先找出一个基可行解，判断是否为最优，如为否，则转换到相邻的基可行解，并使目标函数值不断增大，直到找到最优解为止. 考虑线性规划问题: $$ max\\ z=CX\\ s.t. \\begin{cases} AX=b\\ X\\geq0 \\end{cases} $$ 设 $A=(I,N)$ ,令 $B=I$ ,则有 $$ x_i=b_i-\\sum_{j=m+1}^na_{ij}x_j,i=1,2,\u0026hellip;,m $$ 带入$z=CX$中,有 $$ z=\\sum_{i=1}^{m}c_ib_i+\\sum_{j=m+1}^n(c_j-\\sum_{i=1}^mc_ia_{ij})x_j $$ 当 $x_j=0,j=m+1,\u0026hellip;,n$ 时, $$ \\begin{cases} X^{(1)}=(b_1,\u0026hellip;,b_m,0,\u0026hellip;,0)^{T}(初始基可行解)\\ z^{(1)}= \\sum_{i=1}^mc_ib_i(对应目标函数值) \\end{cases} $$ 记 $\\lambda_j = c_j-\\sum_{i=1}^mc_ia_{ij},j=m+1,\u0026hellip;,n$ ,称 $\\lambda_j$ 为检验数.\n定理4: 对解 $X^{(1)}$ ,若检验数 $\\lambda _j,j=m+1,\u0026hellip;,n$全部$\\leq0$ ,则 $X^{(1)}$ 为最优解. 定理5: 对解 $X^{(1)}$ ,若有某个非基变量 $x_{m+k}$ 对应的 $\\lambda_{m+k}\u0026gt;0$ ,而且相应的 $P_{m+k} = (a_{1(m+k)},\u0026hellip;,a_{m(m+k)})^{T}\\leq0$ ,则原问题无有界最优解. 若不符合上两种情况,则需要进行换基迭代. ①决定换入变量: 若 $max_{\\lambda_j\u0026gt;0}\\lambda_j=\\lambda_{m+k}$ ,则 $x_{m+k}$ 为换入变量. ②决定换出变量: 若 $\\theta =min{\\frac{b_i}{a_{i(m+k)}}|a_{i(m+k)}\u0026gt;0} = \\frac{b_r}{a_{r(m+k)}}$ ,则 $x_r$ 为换出变量. 定理6 经单纯形法换基迭代获得的新解 $$ X^{(2)}=(b_1-\\theta a_{1(m+k)},\u0026hellip;,b_m-\\theta a_{m(m+k)},0,\u0026hellip;,\\theta,\u0026hellip;,0)^{T}$$ 是基可行解,且满足$z^{(2)}\u0026gt;z^{(1)}$. 单纯形法基础步骤: ①确定初始基,初始基可行解; ②检查非基变量检验数 $\\lambda_j$是否全部 $\\leq0$,若是,则已求得最优解;否则继续下一步; ③若有 $\\lambda_k\u0026gt;0$, $P_k$全部 $\\leq0$,则停止,该问题没有有界最优解;否则继续下一步; ④根据最大非负检验书 $\\lambda_j$确定换入变量$x_{m+k}$,根据最小 $\\theta$值确定换出变量 $x_r$; ⑤以$a_{r(m+k)}$为中心进行换基迭代,之后转第②步. 单纯形法的求解过程可以在单纯形表上进行.\n单纯形法进阶 # 有时标准形式无法直接找到一组初始基可行解,这时候运用单纯形法需要引进人工变量.\n大M法 引进人工变量 $x_p$,\u0026hellip;,$x_q$,同时修改 $z^{*}=z-\\sum_{i=p}^{q}Mx_i$,其中$M$为很大的数,这样做使得取最优解时人工变量值必须为$0$. 两阶段法 一阶段:引进人工变量$x_p$,\u0026hellip;,$x_q$,同时修改 $z^{*}=-\\sum_{i=p}^{q}x_i$.解决一阶段优化问题后,$x_p$,\u0026hellip;,$x_q$取值均为$0$; 二阶段:在一阶段的最终单纯形表中,修改$z$为初始标准型问题的目标函数,在新的单纯形表中解决原问题. 人工变量不能完全出基时,原问题无可行解.\n","date":"2 May 2022","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E8%BF%90%E7%AD%B9%E5%AD%A6/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/","section":"Posts","summary":"#线性规划","title":"线性规划"},{"content":"","date":null,"permalink":"/tags/java/","section":"Tags","summary":"","title":"Java"},{"content":"LeetCode-160 相交链表 # Solution 1 # 利用双指针来一次解决问题.考虑在两条链表长度没有明确关联的情况下,如何让指针的操作有规律且合法?\n我们让指针p1和p2分别指向headA与headB,当指针p1走完A链表后再走B链表,对p2同理.这样一来,两条链表在逻辑上被我们连接到了一起.\n当p1与p2不相等时便让它们一直往前走,若两条链表有共同节点,便会在p1==p2时停下; 若没有共同节点,则两者会同时走到null,注意到这一情况同样符合终止条件. 代码如下:\npublic class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA; ListNode p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } } Solution 2 # 同样是连接,这次我们考虑将链表B连接到链表A的末端.观察新链表的形式,我们会发现,判断是否具有共同节点的问题被转换成了判断新链表是否成环.显然这时返回共同节点等价于返回环节点,而这正是我们利用快慢指针解决过的问题. 代码如下:\npublic class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA, p2 = headA; while (p1.next != null) { p1 = p1.next; } p1.next = headB; p1 = headA; while (p1 != null \u0026amp;\u0026amp; p1.next != null) { p1 = p1.next.next; p2 = p2.next; if (p1 == p2) { break; } } if (p1 == null || p1.next == null) { return null; } p2 = headA; while (p1 != p2) { p1 = p1.next; p2 = p2.next; } return p1; } } 不过这个解法在LeetCode判题系统上过不了,是因为题目中强调了\u0026quot;函数返回结果后,链表必须保持其原始结构\u0026quot;,但这一思路还是值得参考的.\n","date":"2 May 2022","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","section":"Posts","summary":"LeetCode-160 相交链表 # Solution 1 # 利用双指针来一次解决问题.","title":"LeetCode-160 相交链表"},{"content":"","date":null,"permalink":"/tags/%E9%93%BE%E8%A1%A8/","section":"Tags","summary":"","title":"链表"},{"content":"Hello, World! # 王小波在《智慧与国学》中写道:\n拉封丹寓言里, 有一则《大山临盆》, 内容如下: 大山临盆,天为之崩, 地为之裂, 日月星辰,为之无光. 房倒屋坍， 烟尘滚滚， 天下生灵， 死伤无数\u0026hellip;\u0026hellip;最后生下了一只耗子. 中国的人文学者弄点学问, 就如大山临盆一样壮烈. 当然, 我说的不止现在, 而且有过去, 还有未来.\n花了不少时间搭建了自己的第一个博客, 在这里, 希望自己能够坚持更新, 创作一些有意义的文字, 借助博客这一载体学会思辨, 学会学习, 而不是像大山临盆那样, 雷声大雨点小.\n在此以校歌中的一段勉励自己:\n左图右史, 邺架巍巍, 致知穷理, 学古探微. 新旧合冶, 殊途同归, 肴核仁义, 闻道日肥.\n在未来, 多问多学多思考, 成为理想中的那个人.\n","date":"2 May 2022","permalink":"/posts/%E9%9A%8F%E7%AC%94/hello-world/","section":"Posts","summary":"Hello, World!","title":"Hello World!"},{"content":"Queueing Part1 # Vocabulary # $\\lambda$: 平均到达速率\n$\\mu$: 平均服务效率 (服务效率是满负荷状态下的能力)\n$S:$ Job size, 需要的服务量\n瞬时(某些特定时刻/状态下) / 平稳(运行足够长时间达到稳定后的平均状况)\n$\\rho$: utilization, 利用率 (需求 / 服务能力 $=\\frac{\\lambda}{\\mu}$)\n服务器处于繁忙状态的时间占比 Throughput $X$: 单位时间从系统的出口处的流量 (完成的Job的平均数量)\n$T: $ 进入系统到结束的总时长\n$T_Q:$ 耗费在队列里的时间\n$E(T)=E(T_Q + S) = E(T_Q)+ \\frac{1}{\\mu}$ $\\lambda \u0026lt; \\mu$ , 为什么还有排队? 到达的随机性 Squared Coefficient of Variation\nSystems # The behavior of customers # Balking: 要排队就走 (不排队) Reneging: 不想等了就走 Jockeying: 换队 Retrial: 服务器状态\nX/Y/Z/A/B/C (Kendall notation) 以 D/D/1 为例, 确定到达间隔, 确定服务时间, 一个服务器 泊松的相邻到达间隔服从指数分布\n流平衡方程 # 考虑稳态, 状态间转化的 “速率“ 是一样的\n有了 $E[N]$ , 可以应用 Little‘s law.\n应用:\n$$ \\frac{E[S^2]}{2E[S]} $$\n怎么推导?\n","date":"1 January 0001","permalink":"/posts/%E6%95%B0%E5%AD%A6/%E9%9A%8F%E6%9C%BA%E8%BF%90%E7%AD%B9%E5%AD%A6/%E6%8E%92%E9%98%9F%E8%AE%BA/","section":"Posts","summary":"Queueing Part1 # Vocabulary # $\\lambda$: 平均到达速率","title":"about"},{"content":"你好!\n我是 Matriz23, 目前就读于清华大学经济管理学院.\n感兴趣的方面包括数学, 计算机, 音乐, ACG等.\n交流请通过邮件, 欢迎探讨技术, 交流爱好以及一切有趣的事情.\n","date":"1 January 0001","permalink":"/about/","section":"一边吐血一边奔跑着的马拉松","summary":"你好!","title":"About me"},{"content":"LeetCode-368 最大整除子集 # 论排序的重要性\nSolution 1 # 寻找数组中的最大整除子集, 常规思路中最大的难点在于状态转移方程的条件判定, 对于 $j \u0026lt; i$, 如果 $nums[i]$ 为以 $nums[j]$ 为结尾的最大整除子集中最大值的倍数, 则有 $dp[i] = max(dp[i], dp[j] + 1)$, 但如果不是这样, 我们很难判定加入 $nums[i]$ 后能否构成一个新的整除子集, 因为状态转移方程只告诉我们有几个整除子集, 而不会给出它们各自具体的构造. 能否解决这一困境呢? 我们觉得 $nums[i]$ 较小的时候难以处理, 那么保证对 $\\forall j \u0026lt; i$ 有 $nums[j] \u0026lt; nums[i]$ 不就不用处理这种情况了吗? 把原数组排个序再处理, 这道题变得相当简单. 最后题目要求给出一个最大整除子集的构造, 我们不妨从后向前, 把子集个数从 $dp[index]$ 一路降至 $1$, 从大到小构造出这个子集. 代码如下:\nclass Solution { public: vector\u0026lt;int\u0026gt; largestDivisibleSubset(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); vector\u0026lt;int\u0026gt; dp(n, 1); for (int i = 1; i \u0026lt; n; i++) { int key = nums[i]; for (int j = 0; j \u0026lt; i; j++) { if (key % nums[j] == 0 \u0026amp;\u0026amp; dp[j] + 1 \u0026gt; dp[i]) { dp[i] = dp[j] + 1; } } } int max = 0; int index = 0; for (int i = 0; i \u0026lt; n; i++) { if (dp[i] \u0026gt; max) { max = dp[i]; index = i; } } vector\u0026lt;int\u0026gt; ans; for (int i = n - 1; i \u0026gt;= 0; i--) { if (dp[i] == max \u0026amp;\u0026amp; nums[index] % nums[i] == 0) { max--; index = i; ans.push_back(nums[i]); } } return ans; } }; ","date":"1 January 0001","permalink":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA/leetcode/leetcode-368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","section":"Posts","summary":"LeetCode-368 最大整除子集 # 论排序的重要性","title":"LeetCode-368 最大整除子集"}]